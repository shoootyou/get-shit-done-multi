# Phase 12.2: Add NPM Publishing Workflow - Research

**Researched:** 2025-02-01  
**Domain:** GitHub Actions CI/CD, NPM publishing, Git tagging  
**Confidence:** HIGH

## Summary

Research confirms that GitHub Actions with `actions/setup-node@v6` and GitHub CLI (`gh`) form the standard stack for NPM publishing workflows. The workflow pattern is well-established: validate → test → build → pack → install → tag → release → publish. Critical finding: all validation must occur BEFORE git tag creation, as tags are immutable and should not be deleted once pushed.

Key architectural decisions validated:
- Manual workflows with `workflow_dispatch` are standard for version-controlled releases
- Two separate workflows (main vs dev branch) is a common pattern for stable/pre-release separation
- `npm publish` automatically reads version from package.json (no explicit flag needed)
- GitHub CLI `gh release create` is the current recommended approach (replaces deprecated `actions/create-release`)
- Granular NPM access tokens with publish permission are the security best practice

**Primary recommendation:** Use setup-node for NPM auth, validate thoroughly before tagging (point-of-no-return), and leverage built-in tooling (gh CLI, npm commands) rather than third-party actions.

## Standard Stack

The established tools for NPM publishing in GitHub Actions:

### Core
| Tool/Action | Version | Purpose | Why Standard |
|-------------|---------|---------|--------------|
| `actions/setup-node` | v6 | Node.js environment setup, NPM auth | Official GitHub action, handles .npmrc creation with registry-url |
| `actions/checkout` | v4 | Repository checkout | Required for accessing code and package.json |
| GitHub CLI (`gh`) | Pre-installed | Git tag and release creation | Pre-installed on runners, replaces deprecated actions/create-release |
| npm CLI | Built-in | Package operations (pack, publish) | Standard package manager, built into Node.js |

### Supporting
| Tool | Version | Purpose | When to Use |
|------|---------|---------|-------------|
| `jq` | Pre-installed | JSON manipulation for package.json | Updating version, validating fields |
| `semver` CLI | Optional | Semantic version validation | Strict version format validation (can use Node.js semver package) |
| Git commands | Built-in | Tag checking, remote operations | Version control operations |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| GitHub CLI | `actions/create-release@v1` | Deprecated action, no longer maintained |
| setup-node auth | Manual .npmrc creation | More complex, error-prone, setup-node is purpose-built |
| jq for version update | npm version command | npm version creates commits/tags automatically (we want manual control) |

**Installation:**
```yaml
# In GitHub Actions workflow - no installation needed
- uses: actions/checkout@v4
- uses: actions/setup-node@v6
  with:
    node-version: '20.x'
    registry-url: 'https://registry.npmjs.org'
# gh CLI pre-installed on all runners
# npm CLI comes with Node.js
```

## Architecture Patterns

### Recommended Workflow Structure
```
.github/workflows/
├── publish-main.yml      # Stable releases from main branch
└── publish-dev.yml       # Pre-releases from dev branch
```

**Why separate workflows:**
- Different permission requirements (main = admins only)
- Different version validation (main = no pre-release suffixes)
- Different NPM dist-tags (main = latest, dev = beta/alpha)
- Clearer intent and easier to audit

### Pattern 1: Manual Workflow with Version Input
**What:** User triggers workflow manually, provides version as input  
**When to use:** Production releases requiring human approval  
**Example:**
```yaml
# Source: GitHub Actions official documentation
name: Publish to NPM
on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to publish (e.g., 1.9.1 or 2.0.0-beta.1)'
        required: true
        type: string

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # For creating tags and releases
      id-token: write  # For npm provenance (optional)
    
    steps:
      - name: Validate version format
        run: |
          if ! echo "${{ inputs.version }}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$'; then
            echo "Invalid version format: ${{ inputs.version }}"
            exit 1
          fi
```

### Pattern 2: NPM Authentication with setup-node
**What:** Configure npm to authenticate with NPM registry  
**When to use:** All NPM publish workflows  
**Example:**
```yaml
# Source: actions/setup-node README
- uses: actions/setup-node@v6
  with:
    node-version: '20.x'
    registry-url: 'https://registry.npmjs.org'
    
- run: npm publish
  env:
    NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

**Key details:**
- `registry-url` triggers .npmrc creation with auth config
- Token passed via `NODE_AUTH_TOKEN` environment variable (setup-node expects this name)
- NPM_TOKEN stored as GitHub repository secret

### Pattern 3: Validate Before Point-of-No-Return
**What:** Run all checks before creating git tag (immutable)  
**When to use:** All publishing workflows  
**Example:**
```yaml
# Validation phase (can fail without side effects)
- name: Run tests
  run: npm test
  
- name: Build
  run: npm run build  # If build script exists
  
- name: Create and validate tarball
  run: |
    npm pack
    TARBALL=$(ls *.tgz)
    mkdir -p /tmp/npm-test-$$
    cd /tmp/npm-test-$$
    npm install ../$TARBALL
    cd -
    rm -rf /tmp/npm-test-$$
    
# Point of no return - creates immutable tag
- name: Create git tag
  run: |
    git tag v${{ inputs.version }}
    git push origin v${{ inputs.version }}
```

### Pattern 4: Atomic Tag and Release Creation
**What:** Use GitHub CLI to create tag and release together  
**When to use:** When you want tag and release created atomically  
**Example:**
```yaml
# Source: gh CLI documentation
- name: Create GitHub Release
  env:
    GH_TOKEN: ${{ github.token }}
  run: |
    gh release create "v${{ inputs.version }}" \
      --title "Release v${{ inputs.version }}" \
      --notes "Published version ${{ inputs.version }}" \
      --verify-tag
```

**Alternative (tag first, release second):**
```yaml
- name: Create git tag
  run: |
    git config user.name "github-actions[bot]"
    git config user.email "github-actions[bot]@users.noreply.github.com"
    git tag -a "v${{ inputs.version }}" -m "Release v${{ inputs.version }}"
    git push origin "v${{ inputs.version }}"

- name: Create GitHub Release
  env:
    GH_TOKEN: ${{ github.token }}
  run: |
    gh release create "v${{ inputs.version }}" \
      --title "Release v${{ inputs.version }}" \
      --notes "Published version ${{ inputs.version }}"
```

### Pattern 5: Pre-flight Checks
**What:** Validate conditions before starting workflow  
**When to use:** Prevent common mistakes early  
**Example:**
```yaml
- name: Check tag doesn't exist
  run: |
    if git ls-remote --tags origin | grep -q "refs/tags/v${{ inputs.version }}$"; then
      echo "Tag v${{ inputs.version }} already exists"
      exit 1
    fi

- name: Check package.json version
  run: |
    CURRENT_VERSION=$(jq -r '.version' package.json)
    if [ "$(printf '%s\n' "$CURRENT_VERSION" "${{ inputs.version }}" | sort -V | head -n1)" != "$CURRENT_VERSION" ]; then
      echo "Input version ${{ inputs.version }} is lower than current version $CURRENT_VERSION"
      exit 1
    fi

- name: Verify files field exists
  run: |
    if ! jq -e '.files' package.json > /dev/null; then
      echo "package.json must have 'files' field"
      exit 1
    fi
```

### Pattern 6: Update package.json Version
**What:** Update package.json with input version before publishing  
**When to use:** When version needs to be set dynamically  
**Example:**
```yaml
- name: Update package.json version
  run: |
    jq --arg version "${{ inputs.version }}" '.version = $version' package.json > package.json.tmp
    mv package.json.tmp package.json
    
- name: Verify version update
  run: |
    UPDATED_VERSION=$(jq -r '.version' package.json)
    if [ "$UPDATED_VERSION" != "${{ inputs.version }}" ]; then
      echo "Failed to update package.json version"
      exit 1
    fi
```

### Pattern 7: Concurrency Control
**What:** Prevent multiple simultaneous workflow runs  
**When to use:** Avoid race conditions with tags/releases  
**Example:**
```yaml
# At top level of workflow
concurrency:
  group: npm-publish-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel, queue instead
```

### Anti-Patterns to Avoid

- **Don't use deprecated actions/create-release:** Unmaintained, use GitHub CLI instead
- **Don't commit version changes back to repo:** Creates commit spam, version should live in tags
- **Don't delete tags on failure:** Tags are immutable, document manual cleanup instead
- **Don't publish before validating:** Run tests, build, pack, install BEFORE tagging
- **Don't assume scoped packages are public:** Add `--access public` flag or publishConfig
- **Don't use npm version command in CI:** It creates commits/tags automatically, we want manual control

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| NPM authentication in CI | Custom .npmrc creation with token interpolation | `actions/setup-node` with `registry-url` | Handles scope, authentication, and .npmrc creation correctly; tested and maintained |
| Git tag and release creation | Separate API calls to GitHub REST API | GitHub CLI `gh release create` | Atomic operation, handles tag creation, built-in on runners, simpler syntax |
| Version validation | Regex parsing of semver | Node.js `semver` package or shell version comparison | Handles pre-release, build metadata, comparison operators correctly |
| Package tarball creation | Custom archiving with tar/zip | `npm pack` | Uses package.json files field, respects .npmignore, creates standard format |
| Checking if version exists on npm | Parsing npm registry API | `npm view <package>@<version>` exits with error if not found | Standard tool, handles scopes, authentication, mirrors |

**Key insight:** GitHub Actions workflows benefit from using official actions and built-in tooling rather than reimplementing functionality. The ecosystem provides purpose-built tools that handle edge cases.

## Common Pitfalls

### Pitfall 1: Publishing Version That Already Exists on NPM
**What goes wrong:** `npm publish` fails with "cannot publish over existing version"  
**Why it happens:** npm versions are immutable once published  
**How to avoid:** 
```bash
# Check if version exists before publishing
npm view get-shit-done-multi@1.9.1 version
# Exit code 0 if exists, 1 if doesn't exist
```
**Warning signs:** Error message "You cannot publish over the previously published versions"

### Pitfall 2: Tag Already Exists
**What goes wrong:** Git tag creation fails, workflow aborts  
**Why it happens:** Manual tag creation, or previous workflow run  
**How to avoid:**
```bash
# Check remote tags before creating
if git ls-remote --tags origin | grep -q "refs/tags/v${VERSION}$"; then
  echo "Tag already exists"
  exit 1
fi
```
**Warning signs:** "tag 'v1.0.0' already exists" error

### Pitfall 3: Orphaned Tag After Failed Publish
**What goes wrong:** Tag exists but package not published (inconsistent state)  
**Why it happens:** Validation after tag creation instead of before  
**How to avoid:**
- Order matters: validate → test → build → pack → install → **THEN** tag → release → publish
- All checks before point-of-no-return (tag creation)
- Document manual recovery: delete tag, fix issue, retry
**Warning signs:** Tag exists in git but `npm view` shows older version

### Pitfall 4: Authentication Failures
**What goes wrong:** npm publish fails with "authentication error"  
**Why it happens:** Token invalid, expired, or insufficient permissions  
**How to avoid:**
- Use granular access token with publish permission
- Test token setup: `npm publish --dry-run`
- Document token rotation schedule
- Verify `NODE_AUTH_TOKEN` environment variable set
**Warning signs:** "Unable to authenticate", "403 Forbidden"

### Pitfall 5: Scoped Packages Default to Private
**What goes wrong:** npm publish fails for `@org/package` with "payment required"  
**Why it happens:** Scoped packages default to private (requires paid npm account)  
**How to avoid:**
```bash
# Check if scoped
if [[ $(jq -r '.name' package.json) == @* ]]; then
  npm publish --access public
else
  npm publish
fi
```
**Alternative:** Set in package.json:
```json
{
  "publishConfig": {
    "access": "public"
  }
}
```
**Warning signs:** "Package scope must be public" error

### Pitfall 6: Missing Files in Published Package
**What goes wrong:** Users can't import/use package after installation  
**Why it happens:** `files` field in package.json doesn't include necessary files  
**How to avoid:**
```bash
# Preview what will be published
npm pack --dry-run

# Test tarball installation
npm pack
mkdir /tmp/test-install
cd /tmp/test-install
npm install /path/to/tarball
# Validate critical files exist
```
**Warning signs:** Users report "Cannot find module" after installing

### Pitfall 7: Pre-release on Stable Branch
**What goes wrong:** Beta/alpha version published to `latest` dist-tag  
**Why it happens:** Not validating version format matches branch  
**How to avoid:**
```bash
# On main branch, reject pre-release versions
if [[ "$BRANCH" == "main" && "$VERSION" =~ - ]]; then
  echo "Pre-release versions not allowed on main branch"
  exit 1
fi
```
**Warning signs:** Users report getting pre-release when installing package

### Pitfall 8: Concurrent Workflow Runs
**What goes wrong:** Two workflows try to create same tag simultaneously  
**Why it happens:** Multiple users triggering workflow at same time  
**How to avoid:**
```yaml
concurrency:
  group: npm-publish-${{ github.ref }}
  cancel-in-progress: false
```
**Warning signs:** Race condition errors, duplicate tag attempts

### Pitfall 9: package.json Version Mismatch
**What goes wrong:** Published version doesn't match git tag  
**Why it happens:** Forgot to update package.json before publishing  
**How to avoid:**
```bash
# Update package.json
jq --arg v "$VERSION" '.version = $v' package.json > package.json.tmp
mv package.json.tmp package.json

# Verify it worked
if [ "$(jq -r '.version' package.json)" != "$VERSION" ]; then
  echo "Version update failed"
  exit 1
fi
```
**Warning signs:** Git tag says v1.9.1 but npm shows 1.9.0

### Pitfall 10: No Build Step Before Publish
**What goes wrong:** Publishing source code instead of built artifacts  
**Why it happens:** Forgetting build step, or no build script  
**How to avoid:**
```yaml
- name: Build (if needed)
  run: |
    if jq -e '.scripts.build' package.json > /dev/null; then
      npm run build
    fi
```
**Warning signs:** Package size larger than expected, source files in published package

## Code Examples

Verified patterns from official sources:

### Complete Workflow Structure
```yaml
# Source: Composite of GitHub official documentation patterns
name: Publish to NPM (Main Branch)
on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Semantic version (e.g., 1.9.1)'
        required: true
        type: string

concurrency:
  group: npm-publish-main
  cancel-in-progress: false

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20.x'
          registry-url: 'https://registry.npmjs.org'
          cache: 'npm'
          
      - name: Validate version format
        run: |
          if ! echo "${{ inputs.version }}" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Invalid version format"
            exit 1
          fi
          
      - name: Check tag doesn't exist
        run: |
          if git ls-remote --tags origin | grep -q "refs/tags/v${{ inputs.version }}$"; then
            echo "Tag already exists"
            exit 1
          fi
          
      - name: Validate against current version
        run: |
          CURRENT=$(jq -r '.version' package.json)
          if [ "$(printf '%s\n' "$CURRENT" "${{ inputs.version }}" | sort -V | head -n1)" != "$CURRENT" ]; then
            echo "Input version must be higher than current version $CURRENT"
            exit 1
          fi
          
      - name: Verify files field
        run: |
          if ! jq -e '.files' package.json > /dev/null; then
            echo "package.json must have 'files' field"
            exit 1
          fi
          
      - name: Update package.json version
        run: |
          jq --arg v "${{ inputs.version }}" '.version = $v' package.json > package.json.tmp
          mv package.json.tmp package.json
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run tests
        run: npm test
        
      - name: Build
        run: |
          if jq -e '.scripts.build' package.json > /dev/null; then
            npm run build
          fi
          
      - name: Create and test tarball
        run: |
          npm pack
          TARBALL=$(ls *.tgz)
          mkdir -p /tmp/npm-test-$$
          cd /tmp/npm-test-$$
          npm install "../$TARBALL"
          cd -
          rm -rf /tmp/npm-test-$$
          
      - name: Dry-run publish
        run: npm publish --dry-run
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          
      - name: Create git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "v${{ inputs.version }}" -m "Release v${{ inputs.version }}"
          git push origin "v${{ inputs.version }}"
          
      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh release create "v${{ inputs.version }}" \
            --title "Release v${{ inputs.version }}" \
            --notes "Release v${{ inputs.version }}"
            
      - name: Publish to NPM
        run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

### Version Comparison Script
```bash
# Source: Standard shell version comparison
compare_versions() {
  local current=$1
  local input=$2
  
  # Sort versions and check if current is first (older)
  if [ "$(printf '%s\n' "$current" "$input" | sort -V | head -n1)" != "$current" ]; then
    echo "Input version $input is not higher than current $current"
    return 1
  fi
  
  if [ "$current" == "$input" ]; then
    echo "Versions are equal"
    return 1
  fi
  
  return 0
}
```

### Pre-release Validation
```bash
# Source: Semantic versioning specification
validate_prerelease() {
  local version=$1
  local branch=$2
  
  # Check if version has pre-release suffix (contains hyphen)
  if [[ "$version" =~ - ]]; then
    if [ "$branch" == "main" ]; then
      echo "Pre-release versions not allowed on main branch"
      return 1
    fi
    echo "Pre-release version detected: OK for $branch branch"
  else
    echo "Stable version detected"
  fi
  
  return 0
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| actions/create-release@v1 | GitHub CLI `gh release create` | 2021-2022 | Simpler, maintained, atomic operations |
| Manual .npmrc creation | setup-node with registry-url | 2020+ | Less error-prone, handles authentication correctly |
| Classic automation tokens | Granular access tokens | 2023+ | Better security, scope to specific packages |
| npm version command in CI | Manual package.json update | Ongoing | More control, no unwanted commits |
| Publishing on every commit | Manual workflow_dispatch | Ongoing | Intentional releases, prevents accidental publishes |

**Deprecated/outdated:**
- **actions/create-release@v1**: Deprecated, use GitHub CLI instead
- **actions/upload-release-asset**: Deprecated, use `gh release upload` instead
- **Classic automation tokens**: Still work but granular tokens recommended
- **always-auth input**: Removed in setup-node v6, no longer needed

## Open Questions

All questions from context have been answered:

### 1. NPM Token Permissions
**Resolved:** Use granular access token with publish permission scoped to package. Fallback to classic Automation token if granular not available.

### 2. Recommended Actions
**Resolved:** `actions/setup-node@v6` + GitHub CLI (`gh`) + built-in npm commands. No third-party actions needed.

### 3. Tarball Validation
**Resolved:** Create temp directory, install tarball locally, validate, clean up. Pattern documented above.

### 4. Commit Version Back
**Resolved:** NO - Based on user decisions, version change is ephemeral (for publish only). Version tracked in git tags.

### 5. Failed Publish Cleanup
**Resolved:** Validate before point-of-no-return. If publish fails after tag, manual intervention required. Document troubleshooting.

### 6. Dry-run Capability
**Resolved:** Use `npm publish --dry-run` as validation step before actual publish.

### 7. npm publish Version Behavior
**Resolved:** npm automatically reads version from package.json. No explicit flag needed.

### 8. GitHub Release API
**Resolved:** Use `gh release create` with tag name, title, and notes. GITHUB_TOKEN automatically provided.

### 9. Rate Limiting
**Resolved:** Not a concern for normal publishing frequency. NPM and GitHub have high limits for publishing workflows.

## Sources

### Primary (HIGH confidence)
- **actions/setup-node@v6** - https://github.com/actions/setup-node - Official GitHub action README and documentation
- **GitHub Docs: Publishing Node.js packages** - https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages - Official workflow patterns
- **npm CLI documentation** - `npm help publish`, `npm help pack`, `npm help version` - Local npm documentation (v10.x)
- **GitHub CLI documentation** - `gh release create --help` - Pre-installed tool documentation

### Secondary (MEDIUM confidence)
- **npm dist-tags** - npm CLI experience and documentation
- **Semantic Versioning** - semver.org specification for version format validation
- **GitHub Actions permissions** - Official Actions documentation on GITHUB_TOKEN permissions

### Notes on Confidence
- **Standard stack**: HIGH - Official actions and tools, widely adopted
- **Architecture patterns**: HIGH - Verified from official documentation and CLI help
- **Pitfalls**: HIGH - Based on npm CLI behavior, git semantics, and common CI/CD patterns
- **Token types**: MEDIUM - Granular tokens are documented but adoption varies

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Official actions with active maintenance
- Architecture: HIGH - Patterns verified from official sources
- Pitfalls: HIGH - Based on npm/git semantics and real-world failure modes
- Code examples: HIGH - Derived from official documentation

**Research date:** 2025-02-01  
**Valid until:** ~30 days (stable ecosystem, but check for setup-node updates)  
**Review triggers:** 
- setup-node major version release
- npm CLI major version changes
- GitHub Actions runner environment changes
