---
phase: 01-template-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/migrate-to-templates.js
  - scripts/lib/frontmatter-parser.js
  - scripts/lib/validator.js
  - scripts/lib/template-injector.js
  - package.json
autonomous: true
must_haves:
  - migration script exists at scripts/migrate-to-templates.js
  - frontmatter parser can extract and validate YAML from markdown
  - validator collects all errors (not fail-fast) and generates comprehensive reports
  - template injector replaces hardcoded values with {{VARIABLES}}
  - gray-matter and @inquirer/prompts installed as dependencies
---

# Plan 01-01: Migration Script & Frontmatter Parsing

## Objective

Create the foundation for ONE-TIME migration: main script structure, frontmatter parser with YAML validation, error collection engine, and template variable injector.

## Context

This is Wave 1 of Phase 1 - the foundation that all other migration tasks depend on. We're building the core utilities that will be used to migrate 29 skills and 13 agents from `.github/` to `/templates/` with frontmatter corrections.

Key architectural principle: This is ONE-TIME code that gets deleted after approval, so favor clarity over abstraction. No need for reusable frameworks.

From research: Use **gray-matter** for YAML parsing (industry standard), **@inquirer/prompts** for interactive UI, **collect-all-errors pattern** for validation (not fail-fast).

From requirements:
- TEMPLATE-01: Migration to template structure
- TEMPLATE-01C: Frontmatter format correction for skills
- TEMPLATE-01D: Agent frontmatter correction
- TEMPLATE-03: Template variables

## Tasks

<task name="install-dependencies" type="auto">
  <files>package.json</files>
  <action>
    Install migration dependencies:
    
    ```bash
    npm install --save-dev gray-matter@4.0.3 @inquirer/prompts@8.2.0 open@11.0.0
    ```
    
    These are dev dependencies since migration is ONE-TIME and not needed in production.
    
    Verify installation:
    - gray-matter: YAML frontmatter parser
    - @inquirer/prompts: Interactive CLI (input, confirm, select)
    - open: External diff viewer opener
  </action>
  <verify>
    ```bash
    grep -q "gray-matter" package.json && \
    grep -q "@inquirer/prompts" package.json && \
    grep -q "open" package.json && \
    echo "Dependencies installed successfully"
    ```
  </verify>
  <done>package.json contains gray-matter, @inquirer/prompts, and open in devDependencies</done>
</task>

<task name="create-migration-script-foundation" type="auto">
  <files>scripts/migrate-to-templates.js, scripts/lib/frontmatter-parser.js, scripts/lib/validator.js, scripts/lib/template-injector.js</files>
  <action>
    Create migration script structure:
    
    **scripts/migrate-to-templates.js** (main entry point):
    ```javascript
    #!/usr/bin/env node
    import path from 'node:path';
    import fs from 'fs-extra';
    import chalk from 'chalk';
    
    // Helper modules (to be created in this task)
    import { parseFrontmatter, validateFrontmatter } from './lib/frontmatter-parser.js';
    import { Validator } from './lib/validator.js';
    import { injectTemplateVariables } from './lib/template-injector.js';
    
    async function main() {
      console.log(chalk.blue.bold('üîÑ Phase 1: ONE-TIME Template Migration\n'));
      
      // TODO: Skills migration (Plan 02)
      // TODO: Agents migration (Plan 03)
      // TODO: Validation and manual review (Plan 04)
      
      console.log(chalk.green('‚úì Migration foundation ready'));
    }
    
    main().catch(err => {
      console.error(chalk.red('‚úó Migration failed:'), err);
      process.exit(1);
    });
    ```
    
    **scripts/lib/frontmatter-parser.js** (YAML parsing):
    ```javascript
    import matter from 'gray-matter';
    
    /**
     * Parse frontmatter from markdown file
     * @param {string} filePath - Path to markdown file
     * @param {string} content - File content
     * @returns {{data: object, content: string, orig: string}}
     */
    export function parseFrontmatter(filePath, content) {
      try {
        const parsed = matter(content);
        return {
          data: parsed.data,      // Frontmatter object
          content: parsed.content, // Body content
          orig: parsed.orig        // Original raw frontmatter
        };
      } catch (err) {
        throw new Error(`Failed to parse frontmatter in ${filePath}: ${err.message}`);
      }
    }
    
    /**
     * Validate frontmatter against official Claude/Copilot specs
     * @param {string} filePath - Path for error reporting
     * @param {object} data - Parsed frontmatter object
     * @param {string} type - 'skill' or 'agent'
     * @returns {Array<{field: string, issue: string, severity: string}>}
     */
    export function validateFrontmatter(filePath, data, type) {
      const errors = [];
      
      if (type === 'skill') {
        // Official Claude skill frontmatter fields
        // (from https://code.claude.com/docs/en/slash-commands#frontmatter-reference)
        const supported = ['name', 'description', 'argument-hint', 'disable-model-invocation', 
                          'user-invocable', 'allowed-tools', 'model', 'context', 'agent', 'hooks'];
        
        // Unsupported fields from old format
        const unsupported = ['skill_version', 'requires_version', 'platforms', 'metadata', 
                            'arguments', 'tools'];
        
        // Check for unsupported fields
        unsupported.forEach(field => {
          if (data[field] !== undefined) {
            errors.push({
              field,
              issue: `Unsupported field - must be removed (move to version.json)`,
              severity: 'error'
            });
          }
        });
        
        // Check required fields
        if (!data.name) {
          errors.push({ field: 'name', issue: 'Required field missing', severity: 'error' });
        }
        if (!data.description) {
          errors.push({ field: 'description', issue: 'Recommended field missing', severity: 'warning' });
        }
        
        // Validate allowed-tools format (should be comma-separated string)
        if (data['allowed-tools'] && typeof data['allowed-tools'] !== 'string') {
          errors.push({
            field: 'allowed-tools',
            issue: `Must be comma-separated string (e.g., "Read, Write, Bash"), not array`,
            severity: 'error'
          });
        }
        
      } else if (type === 'agent') {
        // Official Claude agent frontmatter fields
        // (from https://code.claude.com/docs/en/sub-agents)
        const supported = ['name', 'description', 'tools', 'disallowedTools', 
                          'model', 'permissionMode', 'skills', 'hooks'];
        
        // Unsupported fields
        const unsupported = ['metadata', 'skill_version', 'requires_version', 'platforms'];
        
        unsupported.forEach(field => {
          if (data[field] !== undefined) {
            errors.push({
              field,
              issue: `Unsupported field - must be removed (move to versions.json)`,
              severity: 'error'
            });
          }
        });
        
        // Check required fields
        if (!data.name) {
          errors.push({ field: 'name', issue: 'Required field missing', severity: 'error' });
        }
        if (!data.description) {
          errors.push({ field: 'description', issue: 'Required field missing', severity: 'error' });
        }
        
        // Validate tools format (should be comma-separated string for Claude)
        if (data.tools && typeof data.tools !== 'string') {
          errors.push({
            field: 'tools',
            issue: `Must be comma-separated string (e.g., "Read, Write, Bash"), not array`,
            severity: 'error'
          });
        }
      }
      
      return errors;
    }
    ```
    
    **scripts/lib/validator.js** (error collection):
    ```javascript
    import chalk from 'chalk';
    
    /**
     * Collect-all-errors validator (not fail-fast)
     * Accumulates validation errors and generates comprehensive reports
     */
    export class Validator {
      constructor() {
        this.errors = [];
        this.warnings = [];
      }
      
      /**
       * Add validation error
       */
      addError(file, field, message) {
        this.errors.push({ file, field, message, severity: 'error' });
      }
      
      /**
       * Add validation warning
       */
      addWarning(file, field, message) {
        this.warnings.push({ file, field, message, severity: 'warning' });
      }
      
      /**
       * Add multiple issues from frontmatter validation
       */
      addIssues(file, issues) {
        issues.forEach(issue => {
          if (issue.severity === 'error') {
            this.addError(file, issue.field, issue.issue);
          } else {
            this.addWarning(file, issue.field, issue.issue);
          }
        });
      }
      
      /**
       * Check if any errors exist
       */
      hasErrors() {
        return this.errors.length > 0;
      }
      
      /**
       * Check if any warnings exist
       */
      hasWarnings() {
        return this.warnings.length > 0;
      }
      
      /**
       * Generate comprehensive validation report
       */
      generateReport() {
        const lines = [];
        
        if (this.errors.length === 0 && this.warnings.length === 0) {
          lines.push(chalk.green('‚úì All validations passed'));
          return lines.join('\n');
        }
        
        lines.push(chalk.red.bold(`\n‚úó Validation Issues Found\n`));
        lines.push(chalk.gray(`Errors: ${this.errors.length} | Warnings: ${this.warnings.length}\n`));
        
        // Group by file
        const byFile = {};
        [...this.errors, ...this.warnings].forEach(issue => {
          if (!byFile[issue.file]) byFile[issue.file] = [];
          byFile[issue.file].push(issue);
        });
        
        // Show issues grouped by file
        Object.keys(byFile).sort().forEach(file => {
          lines.push(chalk.yellow(`\n${file}:`));
          byFile[file].forEach(issue => {
            const icon = issue.severity === 'error' ? '‚úó' : '‚ö†';
            const color = issue.severity === 'error' ? chalk.red : chalk.yellow;
            lines.push(color(`  ${icon} ${issue.field}: ${issue.message}`));
          });
        });
        
        if (this.errors.length > 0) {
          lines.push(chalk.red.bold(`\n‚ùå Migration blocked - fix all errors before proceeding`));
        }
        
        return lines.join('\n');
      }
    }
    ```
    
    **scripts/lib/template-injector.js** (variable replacement):
    ```javascript
    /**
     * Inject template variables into content
     * Replaces hardcoded platform-specific values with {{VARIABLES}}
     */
    
    /**
     * Replace hardcoded paths with template variables
     * @param {string} content - File content
     * @returns {string} - Content with template variables
     */
    export function injectTemplateVariables(content) {
      let result = content;
      
      // Replace platform roots
      result = result.replace(/\.github\//g, '{{PLATFORM_ROOT}}');
      result = result.replace(/\.claude\//g, '{{PLATFORM_ROOT}}');
      result = result.replace(/\.codex\//g, '{{PLATFORM_ROOT}}');
      
      // Replace command prefixes
      result = result.replace(/\/gsd-/g, '{{COMMAND_PREFIX}}');
      result = result.replace(/\$gsd-/g, '{{COMMAND_PREFIX}}');
      
      // Note: Version and platform name injection happens during installation,
      // not during migration. Templates keep placeholder values.
      
      return result;
    }
    
    /**
     * Validate template variable presence in content
     * @param {string} content - File content
     * @param {Array<string>} requiredVars - Variables that must be present
     * @returns {Array<string>} - Missing required variables
     */
    export function validateTemplateVariables(content, requiredVars) {
      const missing = [];
      
      requiredVars.forEach(varName => {
        const pattern = new RegExp(`\\{\\{${varName}\\}\\}`, 'g');
        if (!pattern.test(content)) {
          missing.push(varName);
        }
      });
      
      return missing;
    }
    ```
    
    Make script executable:
    ```bash
    chmod +x scripts/migrate-to-templates.js
    ```
  </action>
  <verify>
    ```bash
    # Check all files exist
    test -f scripts/migrate-to-templates.js && \
    test -f scripts/lib/frontmatter-parser.js && \
    test -f scripts/lib/validator.js && \
    test -f scripts/lib/template-injector.js && \
    echo "‚úì All migration script files created"
    
    # Run script to verify it executes
    node scripts/migrate-to-templates.js
    ```
  </verify>
  <done>Migration script foundation exists with frontmatter parser, validator, and template injector modules</done>
</task>

## Verification

After completing this plan:

1. **Dependencies installed:** gray-matter, @inquirer/prompts, open in package.json devDependencies
2. **Script structure created:** scripts/migrate-to-templates.js and helper modules exist
3. **Frontmatter parser:** Can extract YAML from markdown, validate against Claude/Copilot specs
4. **Validator:** Collects all errors (not fail-fast), generates comprehensive reports
5. **Template injector:** Replaces hardcoded values with {{VARIABLES}}
6. **Script executes:** Running `node scripts/migrate-to-templates.js` shows foundation ready

## Success Criteria

- [ ] gray-matter, @inquirer/prompts, open installed in devDependencies
- [ ] scripts/migrate-to-templates.js exists and is executable
- [ ] scripts/lib/frontmatter-parser.js can parse YAML and validate skills/agents
- [ ] scripts/lib/validator.js implements collect-all-errors pattern
- [ ] scripts/lib/template-injector.js can replace platform-specific values
- [ ] Running migration script shows "Migration foundation ready"
- [ ] All code follows ESM import/export syntax

## Output

Foundation for ONE-TIME migration ready for skills and agents processing in Plans 02 and 03.
