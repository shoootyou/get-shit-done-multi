---
phase: 6.2
discussed: 2026-01-28T11:54:00Z
areas: [Test Coverage Strategy, Frontmatter Serialization Format, Template Variable Processing Scope, Verification & Rollback Approach]
decisions_count: 16
---

# Phase 6.2 Context: Installation Output Verification & Bug Fixes

**Goal:** Fix critical installation bugs affecting frontmatter transformation and template variable replacement

**Discussed:** All 4 gray areas comprehensively explored

---

## Essential Features

### Test Coverage (Must-Have)
- **Structural validation** over exact string matching for frontmatter
  - Parse frontmatter and check fields exist with correct types
  - Avoids brittle tests while ensuring correctness
- **Full coverage testing** - All 13 agents × 3 platforms = 39 test cases
  - No sampling, test every agent for every platform
  - Ensures comprehensive bug detection
- **Exhaustive file type coverage** in get-shit-done/ directory
  - Test variable replacement in every file type present
  - Not just .md, .json, .sh - ALL text files
- **Explicit negative assertions** for critical bugs
  - Assert `skills` field does NOT exist in Copilot/Codex output
  - Assert NO {{VARIABLES}} remain after replacement
  - Catches regressions if bugs reintroduced

### Frontmatter Format (Must-Have)
- **Empty tools array** → Omit `tools` field entirely
  - Don't output `tools: []` for agents with no tools
- **Metadata block indentation** - Multi-line YAML format:
  ```yaml
  metadata:
    platform: copilot
    generated: 2026-01-28
  ```
  - 2-space indentation, NOT inline JSON
- **Claude skills format** - Multi-line array:
  ```yaml
  skills:
    - gsd-help
    - gsd-verify
  ```
  - NOT inline array format
- **Special characters in tool names** - Keep as-is in single quotes
  - `['read', 'custom-mcp/tool-1']` - no escaping needed
  - Trust Copilot CLI parser handles slashes in quoted strings

### Variable Replacement (Must-Have)
- **Extension-based processing** - Process all text extensions:
  - .md, .json, .sh, .bash, .txt, .yml, .yaml, .config
  - NOT just the three known types
- **JSON/YAML validation after replacement**
  - Parse JSON/YAML after variable replacement
  - Rollback file if invalid syntax detected
  - Prevents broken configuration files
- **No post-processing unreplaced variable scan**
  - Trust recursive processing + tests to catch bugs
  - No runtime scan for {{.*}} patterns
- **Binary file detection** - Skip with verbose log
  - Detect binary files by extension or content sniffing
  - Log skip action in verbose mode
  - Don't attempt to process binaries

### Error Handling (Must-Have)
- **No post-installation verification**
  - Integration tests provide sufficient coverage
  - No runtime validation of installed output
- **Best-effort cleanup on failure**
  - If installation fails partway, attempt to remove partial files
  - Aligns with Phase 5 validation-over-rollback approach
  - Don't leave broken partial installations
- **Generic error messages**
  - Simple, concise errors: "Installation validation failed for Copilot"
  - No detailed diagnostics in production errors
- **No repair command**
  - Users with broken installations can reinstall
  - No separate repair/fix functionality
  - Reinstallation overwrites broken files

---

## Technical Boundaries

### Testing Framework
- Use existing test infrastructure (vitest)
- Integration tests in `/tests/integration/`
- Structural assertions via frontmatter parsing (gray-matter)
- NO new testing frameworks or tools

### Serialization
- Custom serializer for Copilot/Codex frontmatter
- Gray-matter for Claude frontmatter (existing library)
- YAML format, not JSON
- 2-space indentation standard

### File Processing
- Recursive directory traversal
- Text file detection via extensions
- Binary detection via content sniffing or extension
- In-memory validation before write (JSON/YAML)

---

## Scope Limits

### Explicitly Out of Scope
- Dry-run or preview mode for installations
- Interactive repair wizard
- Detailed error diagnostics with workarounds
- Automatic rollback on failure (Phase 5 decision: validation-first)
- Post-installation verification runtime checks
- Custom error reporting URLs or bug trackers
- Variable escaping logic for special characters

### Deferred to Future Phases
- None identified (phase is self-contained bug fix)

---

## Open Questions

### For Research Phase
1. **Binary file detection:** What's the most reliable method - extension list, magic number, or heuristic?
2. **JSON/YAML validation:** Which library to use for syntax validation after replacement?
3. **Frontmatter serializer:** Existing libraries for custom YAML serialization or build from scratch?
4. **File extension list:** Complete list of text extensions to process in get-shit-done/
5. **Test assertion library:** Best approach for structural frontmatter assertions (custom parser or library feature)?

### For Planning Phase
1. Wave structure: Should testing be Wave 1 or should serializer come first?
2. Integration point: Where does custom serializer plug into orchestrator?
3. Rollback file logic: How to track which files were written for best-effort cleanup?
4. Test organization: Single test file or separate files per platform?

---

## Notes

**Critical Context:**
- This phase fixes bugs that affect ALL production installations
- Must complete before Phase 7 (security validation needs correct output)
- Bugs discovered after Phase 6.1 completion (urgent insertion)

**User Expectations:**
- Tests must be comprehensive (no sampling shortcuts)
- Format must be exact for CLI parsing
- Variable replacement must be complete (no {{VARIABLES}} visible)
- Errors should be simple and direct

**Decision Rationale:**
- Full coverage testing: Bugs are critical, sampling risks missing edge cases
- Structural validation: Balances thoroughness with test maintainability
- Extension-based processing: More complete than whitelist, safer than blacklist
- No verification/repair: Tests + reinstall provide sufficient quality + recovery
