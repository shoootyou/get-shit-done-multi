---
phase: 03-multi-platform-support
plan: 03
type: execute
wave: 3
depends_on: [03-01, 03-02]
files_modified:
  - bin/install.js
  - bin/lib/installer/orchestrator.js
  - bin/lib/rendering/template-renderer.js
autonomous: true
must_haves:
  - truth: "CLI accepts --claude, --copilot, --codex flags for platform selection"
    observable: "bin/install.js parses platform flags. Multiple flags supported (--claude --copilot installs to both). No flags defaults to interactive (Phase 4)"
  - truth: "CLI accepts --global and --local flags for installation scope"
    observable: "bin/install.js parses scope flags. --global installs to ~/. --local installs to current directory. Default is --local"
  - truth: "Orchestrator uses adapters for platform-specific operations"
    observable: "orchestrator.js imports adapterRegistry. install() method accepts platform parameter. Calls adapter.getTargetDir(), adapter.getCommandPrefix(), adapter.transformFrontmatter() during installation"
  - truth: "Template renderer replaces {{COMMAND_PREFIX}} with platform-specific value"
    observable: "renderTemplate() accepts commandPrefix parameter. Replaces {{COMMAND_PREFIX}} in content. Uses adapter.getCommandPrefix() as source"
  - truth: "Multi-platform installation works end-to-end"
    observable: "npx install --claude --global copies skills to ~/.claude/. npx install --codex --local copies to .codex/. Command prefixes transformed correctly (/gsd- vs $gsd-)"
  - key_link: "CLI flags → orchestrator (platform selection)"
  - key_link: "Orchestrator → adapters (transformation logic)"
  - key_link: "Renderer → adapter.getCommandPrefix() (variable replacement)"
---

# Plan 03-03: Orchestrator Integration and CLI Flags

## Objective
Integrate platform adapters into the installer orchestrator, add platform selection CLI flags (--claude, --copilot, --codex), add scope flags (--global, --local), and enable multi-platform end-to-end installation.

## Context

**Depends On:** 
- Plan 03-01 (registry and detection modules)
- Plan 03-02 (concrete adapters registered)

**Prior Work:**
- Phase 2 created orchestrator.js with basic installation flow
- Phase 2 created template-renderer.js with {{VARIABLE}} replacement
- Phase 2 created bin/install.js as CLI entry point
- Plan 03-02 registered all three adapters in adapterRegistry

**This Plan Modifies:**
- bin/install.js: Add platform and scope flags
- bin/lib/installer/orchestrator.js: Use adapters for platform-specific operations
- bin/lib/rendering/template-renderer.js: Accept commandPrefix parameter for {{COMMAND_PREFIX}}

**Why Wave 3:**
- Depends on adapters being registered (03-02)
- Wires everything together for working multi-platform installation
- Enables end-to-end testing

**Success Means:**
User can run `npx install --claude --global` or `npx install --codex --local` and get working skills installed with correct transformations.

## Tasks

<task name="add-cli-flags" type="auto">
  <files>bin/install.js</files>
  <action>
Update bin/install.js to add platform and scope flags using commander:

Current bin/install.js has basic structure from Phase 2. Add platform flags:

```javascript
#!/usr/bin/env node
import { program } from 'commander';
import { adapterRegistry } from './lib/platforms/registry.js';
import { install } from './lib/installer/orchestrator.js';
import { logger } from './lib/cli/logger.js';
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Read package.json for version
const pkg = JSON.parse(readFileSync(join(__dirname, '../package.json'), 'utf-8'));

program
  .name('get-shit-done-multi')
  .description('Install get-shit-done skills to Claude, Copilot, or Codex')
  .version(pkg.version);

// Platform flags
program
  .option('--claude', 'Install to Claude Code')
  .option('--copilot', 'Install to GitHub Copilot CLI')
  .option('--codex', 'Install to Codex CLI');

// Scope flags
program
  .option('--global', 'Install globally (~/.claude/, ~/.copilot/, ~/.codex/)')
  .option('--local', 'Install locally (.claude/, .github/, .codex/)');

// Other flags
program
  .option('-y, --yes', 'Skip confirmation prompts')
  .option('--dry-run', 'Show what would be installed without writing files')
  .option('-v, --verbose', 'Show detailed output');

program.action(async (options) => {
  try {
    // Determine platforms to install
    const platforms = [];
    if (options.claude) platforms.push('claude');
    if (options.copilot) platforms.push('copilot');
    if (options.codex) platforms.push('codex');
    
    // If no platform flags, enter interactive mode (Phase 4)
    if (platforms.length === 0) {
      logger.info('No platform specified. Interactive mode coming in Phase 4.');
      logger.info('Usage: npx get-shit-done-multi --claude --global');
      process.exit(0);
    }
    
    // Validate platforms
    const supported = adapterRegistry.getSupportedPlatforms();
    for (const platform of platforms) {
      if (!supported.includes(platform)) {
        logger.error(`Unknown platform: ${platform}. Supported: ${supported.join(', ')}`);
        process.exit(1);
      }
    }
    
    // Determine scope (default: local)
    const isGlobal = options.global === true;
    
    // Install to each platform
    for (const platform of platforms) {
      logger.info(`Installing to ${platform} (${isGlobal ? 'global' : 'local'})...`);
      await install(platform, isGlobal, options);
      logger.success(`✓ ${platform} installation complete`);
    }
    
    logger.success('All installations complete!');
    
  } catch (error) {
    logger.error(`Installation failed: ${error.message}`);
    if (options.verbose) {
      console.error(error);
    }
    process.exit(1);
  }
});

program.parse(process.argv);
```

Per CLI-02 and CLI-03: Multiple platform flags supported. --global vs --local for scope. Default is local if neither specified.
  </action>
  <verify>
cat bin/install.js
node bin/install.js --help
node bin/install.js --version
  </verify>
  <done>
CLI accepts --claude, --copilot, --codex flags (multiple supported). Accepts --global, --local flags (default local). --help shows usage. --version shows version from package.json.
  </done>
</task>

<task name="update-orchestrator" type="auto">
  <files>bin/lib/installer/orchestrator.js</files>
  <action>
Update orchestrator.js to use adapters for platform-specific operations:

Current orchestrator.js from Phase 2 has basic install() function. Update to accept platform parameter and use adapters:

```javascript
// bin/lib/installer/orchestrator.js
import { adapterRegistry } from '../platforms/registry.js';
import { renderTemplate } from '../rendering/template-renderer.js';
import { copyDirectory, writeFile, ensureDirectory } from '../io/file-operations.js';
import { resolvePath, validatePath } from '../paths/path-resolver.js';
import { createProgressBar } from '../cli/progress.js';
import { logger } from '../cli/logger.js';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { homedir } from 'os';
import { readdirSync } from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Install GSD skills to specified platform
 * @param {string} platform - Platform name ('claude', 'copilot', 'codex')
 * @param {boolean} isGlobal - Global vs local installation
 * @param {Object} options - CLI options
 */
export async function install(platform, isGlobal, options = {}) {
  // Get platform adapter
  const adapter = adapterRegistry.get(platform);
  
  // Determine target directory
  const targetBase = adapter.getTargetDir(isGlobal);
  const targetDir = isGlobal 
    ? join(homedir(), targetBase.replace('~/', ''))
    : targetBase;
  
  // Get template directory (from package)
  const templatesDir = join(__dirname, '../../../templates');
  
  // Get command prefix for variable replacement
  const commandPrefix = adapter.getCommandPrefix();
  const pathReference = adapter.getPathReference();
  
  const templateVars = {
    PLATFORM_ROOT: pathReference,
    COMMAND_PREFIX: commandPrefix,
    VERSION: '2.0.0',
    PLATFORM_NAME: platform
  };
  
  logger.info(`Target: ${targetDir}`);
  logger.info(`Command prefix: ${commandPrefix}`);
  
  // Create progress bar
  const progress = createProgressBar('Installing', 100);
  
  try {
    // Step 1: Copy skills (directory-based structure)
    progress.update(10, { status: 'Copying skills...' });
    const skillsSource = join(templatesDir, 'skills');
    const skillsTarget = join(targetDir, 'skills');
    await ensureDirectory(skillsTarget);
    
    // Copy each skill directory
    const skillDirs = readdirSync(skillsSource, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name);
    
    for (const skillDir of skillDirs) {
      const source = join(skillsSource, skillDir);
      const target = join(skillsTarget, skillDir);
      await copyDirectory(source, target);
      
      // Apply template variable replacement to SKILL.md
      const skillFile = join(target, 'SKILL.md');
      const content = await renderTemplate(skillFile, templateVars);
      await writeFile(skillFile, content);
    }
    
    progress.update(40, { status: 'Skills copied' });
    
    // Step 2: Copy agents (flat files)
    progress.update(50, { status: 'Copying agents...' });
    const agentsSource = join(templatesDir, 'agents');
    const agentsTarget = join(targetDir, 'agents');
    await ensureDirectory(agentsTarget);
    await copyDirectory(agentsSource, agentsTarget);
    
    // Apply template variable replacement to all agent files
    const agentFiles = readdirSync(agentsTarget)
      .filter(f => f.endsWith('.md') || f.endsWith('.agent.md'));
    
    for (const agentFile of agentFiles) {
      const filePath = join(agentsTarget, agentFile);
      const content = await renderTemplate(filePath, templateVars);
      await writeFile(filePath, content);
    }
    
    progress.update(70, { status: 'Agents copied' });
    
    // Step 3: Copy shared directory
    progress.update(80, { status: 'Copying shared resources...' });
    const sharedSource = join(templatesDir, 'get-shit-done');
    const sharedTarget = join(targetDir, 'get-shit-done');
    await copyDirectory(sharedSource, sharedTarget);
    
    // Write manifest
    const manifest = {
      version: '2.0.0',
      platform: platform,
      scope: isGlobal ? 'global' : 'local',
      installed: new Date().toISOString(),
      targetDir: targetDir
    };
    
    const manifestPath = join(sharedTarget, '.gsd-install-manifest.json');
    await writeFile(manifestPath, JSON.stringify(manifest, null, 2));
    
    progress.update(100, { status: 'Complete!' });
    progress.stop();
    
  } catch (error) {
    progress.stop();
    throw error;
  }
}
```

Orchestrator now:
- Uses adapterRegistry.get() to retrieve platform adapter
- Calls adapter.getTargetDir(), adapter.getCommandPrefix(), adapter.getPathReference()
- Passes template variables to renderTemplate()
- Writes installation manifest per VERSION-01

Note: Frontmatter transformation comes in next phase when we add gray-matter integration.
  </action>
  <verify>
cat bin/lib/installer/orchestrator.js
node -e "import('./bin/lib/installer/orchestrator.js').then(m => console.log('install function exported:', typeof m.install))"
  </verify>
  <done>
orchestrator.js imports adapterRegistry. install() accepts platform, isGlobal, options parameters. Uses adapter methods for target dir, command prefix, path reference. Writes manifest with platform and scope.
  </done>
</task>

<task name="update-template-renderer" type="auto">
  <files>bin/lib/rendering/template-renderer.js</files>
  <action>
Update template-renderer.js to accept template variables object:

Current renderTemplate() from Phase 2 uses simple string replacement. Update signature to accept variables:

```javascript
// bin/lib/rendering/template-renderer.js
import { readFile } from '../io/file-operations.js';

/**
 * Render template by replacing variables
 * @param {string} filePath - Path to template file
 * @param {Object} variables - Template variables to replace
 * @returns {Promise<string>} Rendered content
 */
export async function renderTemplate(filePath, variables) {
  let content = await readFile(filePath);
  
  // Replace all {{VARIABLE}} occurrences
  for (const [key, value] of Object.entries(variables)) {
    const regex = new RegExp(`{{${key}}}`, 'g');
    content = content.replace(regex, value);
  }
  
  return content;
}

/**
 * Replace variables in string content
 * @param {string} content - Content to process
 * @param {Object} variables - Template variables
 * @returns {string} Processed content
 */
export function replaceVariables(content, variables) {
  let result = content;
  
  for (const [key, value] of Object.entries(variables)) {
    const regex = new RegExp(`{{${key}}}`, 'g');
    result = result.replace(regex, value);
  }
  
  return result;
}
```

Simple string replacement approach from Phase 2 is maintained. Variables object contains PLATFORM_ROOT, COMMAND_PREFIX, VERSION, PLATFORM_NAME.

Per RESEARCH-CLARIFICATIONS Q1: Command prefix replacement happens everywhere (text, inline code, code blocks) - this is CORRECT behavior.
  </action>
  <verify>
cat bin/lib/rendering/template-renderer.js
node -e "
import('./bin/lib/rendering/template-renderer.js').then(m => {
  const content = 'Use {{COMMAND_PREFIX}}progress to check status.';
  const vars = { COMMAND_PREFIX: '/gsd-' };
  const result = m.replaceVariables(content, vars);
  console.log('Original:', content);
  console.log('Rendered:', result);
  console.log('Correct:', result.includes('/gsd-progress'));
});
"
  </verify>
  <done>
renderTemplate() accepts filePath and variables object. replaceVariables() helper processes string content. Replacement uses RegExp with global flag. All {{VARIABLE}} occurrences replaced including in code blocks.
  </done>
</task>

<task name="test-multi-platform-installation" type="auto">
  <files>N/A (test execution)</files>
  <action>
Test multi-platform installation end-to-end in /tmp directory:

```bash
# Per TEST-01: All tests execute under /tmp
TEST_DIR="/tmp/gsd-test-$(date +%s)"
mkdir -p "$TEST_DIR"
cd "$TEST_DIR"

# Test 1: Claude local installation
echo "Testing Claude local installation..."
node /workspace/bin/install.js --claude --local --yes
if [ -f ".claude/get-shit-done/.gsd-install-manifest.json" ]; then
  echo "✓ Claude manifest exists"
  cat ".claude/get-shit-done/.gsd-install-manifest.json"
else
  echo "✗ Claude manifest missing"
fi

# Test 2: Check command prefix in skills
if grep -q "/gsd-" ".claude/skills/"*/SKILL.md; then
  echo "✓ Claude uses /gsd- prefix"
else
  echo "✗ Claude prefix incorrect"
fi

# Test 3: Codex local installation
echo "Testing Codex local installation..."
node /workspace/bin/install.js --codex --local --yes
if [ -f ".codex/get-shit-done/.gsd-install-manifest.json" ]; then
  echo "✓ Codex manifest exists"
  cat ".codex/get-shit-done/.gsd-install-manifest.json"
else
  echo "✗ Codex manifest missing"
fi

# Test 4: Check command prefix in skills (should be $gsd-)
if grep -q "\$gsd-" ".codex/skills/"*/SKILL.md; then
  echo "✓ Codex uses \$gsd- prefix"
else
  echo "✗ Codex prefix incorrect"
fi

# Test 5: Multi-platform installation
cd "$TEST_DIR"
mkdir multi-test
cd multi-test
echo "Testing multi-platform installation..."
node /workspace/bin/install.js --claude --copilot --local --yes

if [ -d ".claude" ] && [ -d ".github" ]; then
  echo "✓ Both platforms installed"
else
  echo "✗ Multi-platform installation failed"
fi

# Cleanup
cd /workspace
echo "Test directory: $TEST_DIR (preserved for inspection)"
```

Per TEST-01: Tests execute in /tmp, never modify source files.

Expected outcomes:
- Claude installs to .claude/ with /gsd- prefix
- Codex installs to .codex/ with $gsd- prefix  
- Copilot installs to .github/ with /gsd- prefix
- Manifests written with correct platform and scope
- Multiple platforms can install simultaneously
  </action>
  <verify>
# Run the test script
bash -c 'TEST_DIR="/tmp/gsd-test-$(date +%s)"; mkdir -p "$TEST_DIR"; cd "$TEST_DIR"; node /workspace/bin/install.js --claude --local --yes; ls -la .claude/get-shit-done/'
  </verify>
  <done>
Multi-platform installation tested in /tmp. Claude, Copilot, Codex installs work. Command prefixes transform correctly (/gsd- vs $gsd-). Manifests written with platform and scope. Simultaneous platform installation works.
  </done>
</task>

## Verification

After all tasks complete:

```bash
# Test CLI help
node bin/install.js --help

# Test platform validation
node bin/install.js --invalid-platform 2>&1 | grep -q "Unknown platform"
echo "✓ Invalid platform rejected"

# Test default scope
node -e "
import { program } from 'commander';
const opts = program.parse(['node', 'install.js', '--claude']);
console.log('Default scope is local:', !opts.global);
"

# Test adapter integration
node -e "
import('./bin/lib/installer/orchestrator.js').then(async m => {
  import('./bin/lib/platforms/registry.js').then(async reg => {
    const adapter = reg.adapterRegistry.get('codex');
    console.log('Codex prefix:', adapter.getCommandPrefix());
    console.log('Codex target (local):', adapter.getTargetDir(false));
    console.log('Codex target (global):', adapter.getTargetDir(true));
  });
});
"

# Test template rendering
node -e "
import('./bin/lib/rendering/template-renderer.js').then(m => {
  const vars = {
    COMMAND_PREFIX: '\$gsd-',
    PLATFORM_ROOT: '.codex'
  };
  const content = 'Run {{COMMAND_PREFIX}}progress in {{PLATFORM_ROOT}}';
  const result = m.replaceVariables(content, vars);
  console.log('Input:', content);
  console.log('Output:', result);
  console.log('Correct:', result === 'Run \$gsd-progress in .codex');
});
"

# Full integration test
cd /tmp
TEST_DIR="gsd-integration-$(date +%s)"
mkdir "$TEST_DIR"
cd "$TEST_DIR"
node /workspace/bin/install.js --claude --codex --local --yes
echo "Claude manifest:"
cat .claude/get-shit-done/.gsd-install-manifest.json
echo "Codex manifest:"
cat .codex/get-shit-done/.gsd-install-manifest.json
echo "Claude prefix check:"
grep -o "/gsd-[a-z-]*" .claude/skills/*/SKILL.md | head -3
echo "Codex prefix check:"
grep -o "\$gsd-[a-z-]*" .codex/skills/*/SKILL.md | head -3
cd /workspace
```

## Success Criteria

- [ ] CLI accepts --claude, --copilot, --codex flags (multiple supported)
- [ ] CLI accepts --global, --local flags (default local)
- [ ] CLI validates platform names against adapterRegistry.getSupportedPlatforms()
- [ ] orchestrator.js uses adapter.getTargetDir() for installation path
- [ ] orchestrator.js uses adapter.getCommandPrefix() for template variables
- [ ] renderTemplate() accepts variables object and replaces all {{VARIABLES}}
- [ ] Installation writes manifest to correct location per platform
- [ ] Manifest includes platform, scope, version, timestamp
- [ ] Command prefix transforms correctly: Claude/Copilot use /gsd-, Codex uses $gsd-
- [ ] Multi-platform installation works (--claude --copilot installs to both)
- [ ] Tests execute in /tmp, never modify source files

## Output

Complete multi-platform installer working end-to-end. Users can install to any combination of Claude, Copilot, Codex with global or local scope.

Git commit:
```
feat(installer): integrate platform adapters with orchestrator

- CLI accepts --claude, --copilot, --codex flags (multiple supported)
- CLI accepts --global, --local flags for installation scope
- orchestrator.js uses adapters for platform-specific operations
- renderTemplate() replaces {{COMMAND_PREFIX}} with platform value
- Multi-platform installation tested in /tmp

Per CLI-02, CLI-03, PLATFORM-05, TEMPLATE-02, TEMPLATE-03 requirements
Phase 3 Goal Achieved: User can install to any platform via flags
Ready for Phase 4: Interactive UX
```
