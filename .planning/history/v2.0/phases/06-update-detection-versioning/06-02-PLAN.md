---
phase: 06-update-detection-versioning
plan: 02
type: execute
wave: 2
depends_on:
  - 06-01
files_modified:
  - bin/install.js
  - bin/lib/cli/interactive.js
  - bin/lib/installer/orchestrator.js
  - tests/integration/update-detection.test.js
autonomous: false
must_haves:
  - goal: "User re-runs installer ‚Üí sees installed version, gets prompted if update available"
    truths:
      - "Platform selection shows inline version status (v2.0.0 ‚Üí v2.1.0)"
      - "Selecting outdated platform auto-updates without extra confirmation"
      - "Downgrade attempts blocked with helpful error message"
      - "Major version jumps show warning before proceeding"
      - "Customization preservation prompt appears for updates"
      - "--check-updates flag works without installation"
      - "--verbose flag shows discovery process"
      - "--custom-path flag accepts additional search paths"
    artifacts:
      - "bin/install.js handles --check-updates, --verbose, --custom-path flags"
      - "bin/lib/cli/interactive.js displays inline version status in platform selection"
      - "bin/lib/installer/orchestrator.js integrates version checking into installation flow"
    wiring:
      - "install.js ‚Üí version modules for --check-updates mode"
      - "interactive.js ‚Üí installation-finder + version-checker for inline display"
      - "orchestrator.js ‚Üí version-checker for downgrade blocking + major warnings"
    key_links:
      - "interactive.js platform selection ‚Üí formatPlatformOption() for inline display"
      - "orchestrator.js installation start ‚Üí compareVersions() for update detection"
      - "--check-updates flag ‚Üí discoverInstallationsWithStatus() for status display"
---

# Phase 6 Plan 2: Interactive CLI Integration & Update Flow

## Objective

Integrate version detection into interactive mode and CLI flags: show inline version status, handle updates, block downgrades, warn on major bumps, and add --check-updates / --verbose / --custom-path flags.

## Context

Plan 1 created the core version detection modules. Now we wire them into the user-facing parts:
- Interactive platform selection shows version status inline
- Orchestrator blocks downgrades and warns on major updates
- New CLI flags for checking updates and verbose output

**From 06-CONTEXT.md:**
- Gray Area 1.1: Inline display like CLI detection
- Gray Area 1.2: Auto-update (no extra prompt)
- Gray Area 2.3: Block downgrades completely
- Gray Area 2.4: Warn on major version jumps
- Gray Area 3.1: Ask to preserve customizations
- Gray Area 3.3: --check-updates flag for status-only
- Gray Area 4.3: --verbose flag for discovery details

**Integration points:**
- `bin/install.js` - CLI flag parsing and routing
- `bin/lib/cli/interactive.js` - Platform selection with inline status
- `bin/lib/installer/orchestrator.js` - Version validation and update handling

## Tasks

<task name="add-cli-flags" type="auto">
  <files>bin/install.js</files>
  <action>
    Add three new CLI flags: --check-updates, --verbose, --custom-path.
    
    **Update flag definitions (after existing flags):**
    ```javascript
    program
      .option('--claude', 'Install to Claude Code')
      .option('--copilot', 'Install to GitHub Copilot CLI')
      .option('--codex', 'Install to Codex CLI')
      .option('--local', 'Install to current project (default)')
      .option('--global', 'Install globally to home directory')
      .option('-y, --yes', 'Skip confirmation prompts')
      .option('--check-updates', 'Check for updates without installing')
      .option('--verbose', 'Show detailed discovery process')
      .option('--custom-path <path>', 'Additional search path for installations')
      .version(packageJson.version);
    ```
    
    **Add check-updates handler (before main flow):**
    ```javascript
    // Validate --custom-path usage
    const customPathArgs = process.argv.filter(arg => 
      arg.startsWith('--custom-path')
    );

    if (customPathArgs.length > 1) {
      console.error('');
      console.error('Error: --custom-path can only be specified once.');
      console.error('To check additional paths, run the installer separately for each path.');
      console.error('');
      console.error('Example:');
      console.error('  npx get-shit-done-multi --custom-path=/path1');
      console.error('  npx get-shit-done-multi --custom-path=/path2');
      console.error('');
      process.exit(1);
    }

    // Handle --check-updates flag
    if (options.checkUpdates) {
      await handleCheckUpdates(options);
      process.exit(0);
    }
    
    async function handleCheckUpdates(options) {
      const { findInstallations } = await import('./lib/version/installation-finder.js');
      const { readManifestWithRepair } = await import('./lib/version/manifest-reader.js');
      const { compareVersions, formatPlatformOption } = await import('./lib/version/version-checker.js');
      
      const currentVersion = packageJson.version;
      const customPaths = options.customPath ? [options.customPath] : [];
      
      console.log(`GSD Installer v${currentVersion}`);
      console.log('');
      console.log('Checking installations...');
      console.log('');
      
      // Check global installations
      const globalFound = await findInstallations('global', customPaths);
      
      if (globalFound.length > 0) {
        console.log('Global installations:');
        for (const install of globalFound) {
          const manifestResult = await readManifestWithRepair(install.path);
          if (manifestResult.success) {
            const versionStatus = compareVersions(
              manifestResult.manifest.gsd_version,
              currentVersion
            );
            console.log(`  ${formatStatusLine(install.platform, versionStatus, options.verbose)}`);
          } else {
            console.log(`  ‚úó ${install.platform}: ${manifestResult.reason}`);
          }
        }
      } else {
        console.log('Global installations: none');
      }
      
      console.log('');
      
      // Check local installations
      const localFound = await findInstallations('local', customPaths);
      
      if (localFound.length > 0) {
        console.log('Local installations:');
        for (const install of localFound) {
          const manifestResult = await readManifestWithRepair(install.path);
          if (manifestResult.success) {
            const versionStatus = compareVersions(
              manifestResult.manifest.gsd_version,
              currentVersion
            );
            console.log(`  ${formatStatusLine(install.platform, versionStatus, options.verbose)}`);
          } else {
            console.log(`  ‚úó ${install.platform}: ${manifestResult.reason}`);
          }
        }
      } else {
        console.log('Local installations: none');
      }
    }
    
    function formatStatusLine(platform, versionStatus, verbose) {
      const { formatPlatformOption } = require('./lib/version/version-checker.js');
      const displayName = formatPlatformOption(platform, versionStatus);
      
      if (versionStatus.status === 'up_to_date') {
        return verbose 
          ? `‚úì ${displayName} (up to date)`
          : `‚úì ${displayName}`;
      }
      
      if (versionStatus.status === 'update_available') {
        return `‚¨Ü ${displayName} (${versionStatus.updateType} update available)`;
      }
      
      if (versionStatus.status === 'major_update') {
        return `‚ö†Ô∏è  ${displayName} (major update available)`;
      }
      
      return `? ${displayName}: ${versionStatus.status}`;
    }
    ```
    
    **Pass verbose and customPath to other flows:**
    Update the options object passed to interactive and CLI modes to include these flags.
  </action>
  <verify>
    ```bash
    # Verify flag definitions
    grep -q "check-updates" bin/install.js
    grep -q "verbose" bin/install.js
    grep -q "custom-path" bin/install.js
    
    # Test --check-updates flag
    node bin/install.js --check-updates
    
    # Test with verbose
    node bin/install.js --check-updates --verbose
    ```
  </verify>
  <done>Three new CLI flags added to install.js, --check-updates handler implemented, formatStatusLine helper created</done>
</task>

<task name="integrate-interactive-version-display" type="auto">
  <files>bin/lib/cli/interactive.js</files>
  <action>
    Update interactive mode to show inline version status in platform selection.
    
    **Import version modules at top:**
    ```javascript
    import { findInstallations } from '../version/installation-finder.js';
    import { readManifestWithRepair } from '../version/manifest-reader.js';
    import { compareVersions, formatPlatformOption } from '../version/version-checker.js';
    ```
    
    **Discover installations before platform selection (in runInteractive):**
    ```javascript
    export async function runInteractive() {
      const intro = clack.intro(chalk.bold('üöÄ Get Shit Done - Multi-Platform Installer'));
      
      // Get current version from package.json
      const packageJson = await fs.readJson(path.join(__dirname, '../../../package.json'));
      const currentVersion = packageJson.version;
      
      // Discover existing installations
      const scope = 'global'; // Will be updated based on user selection
      const customPaths = []; // Could come from options if passed
      const installations = await discoverInstallationsWithStatus(scope, currentVersion, customPaths);
      
      // Store for later use
      const installationMap = new Map(
        installations.map(i => [i.platform, i.versionStatus])
      );
      
      // ... rest of interactive flow
    }
    
    async function discoverInstallationsWithStatus(scope, currentVersion, customPaths = []) {
      const found = await findInstallations(scope, customPaths);
      
      const withStatus = await Promise.all(
        found.map(async (install) => {
          const manifestResult = await readManifestWithRepair(install.path);
          
          if (!manifestResult.success) {
            return {
              platform: install.platform,
              path: install.path,
              versionStatus: { status: 'unknown', reason: manifestResult.reason }
            };
          }
          
          const versionStatus = compareVersions(
            manifestResult.manifest.gsd_version,
            currentVersion
          );
          
          return {
            platform: install.platform,
            path: install.path,
            manifest: manifestResult.manifest,
            versionStatus
          };
        })
      );
      
      return withStatus;
    }
    ```
    
    **Update platform selection options (in platform selection prompt):**
    ```javascript
    const platformChoices = [
      {
        value: 'claude',
        label: formatPlatformOption('claude', installationMap.get('claude')),
        hint: getHintForPlatform('claude', binaryDetection.claude)
      },
      {
        value: 'copilot',
        label: formatPlatformOption('copilot', installationMap.get('copilot')),
        hint: getHintForPlatform('copilot', binaryDetection.copilot)
      },
      {
        value: 'codex',
        label: formatPlatformOption('codex', installationMap.get('codex')),
        hint: getHintForPlatform('codex', binaryDetection.codex)
      }
    ];
    
    function getHintForPlatform(platform, binaryDetected) {
      const versionStatus = installationMap.get(platform);
      
      if (versionStatus) {
        if (versionStatus.status === 'update_available') {
          return `${versionStatus.updateType} update available`;
        }
        if (versionStatus.status === 'major_update') {
          return 'Major update available (breaking changes)';
        }
        if (versionStatus.status === 'up_to_date') {
          return 'Already installed (up to date)';
        }
      }
      
      return binaryDetected ? 'Detected' : 'Not detected';
    }
    ```
    
    **Pass version status to orchestrator:**
    Update the call to installation-core to include version status information.
  </action>
  <verify>
    ```bash
    # Verify imports added
    grep -q "findInstallations" bin/lib/cli/interactive.js
    grep -q "compareVersions" bin/lib/cli/interactive.js
    
    # Verify platform option formatting
    grep -q "formatPlatformOption" bin/lib/cli/interactive.js
    
    # Manual test - run interactive mode
    node bin/install.js
    # Should see version status inline if any installations exist
    ```
  </verify>
  <done>Interactive mode discovers installations before platform selection, formats inline version status, updates hints based on update availability</done>
</task>

<task name="checkpoint-manual-testing" type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Interactive version display and --check-updates flag integrated.
    
    **Completed so far:**
    1. Core version modules (finder, reader, checker) from Plan 1
    2. CLI flags (--check-updates, --verbose, --custom-path)
    3. Interactive mode shows inline version status
  </what-built>
  <how-to-verify>
    **Test 1: Check Updates Flag**
    ```bash
    node bin/install.js --check-updates
    ```
    Expected: Shows all global + local installations with version status
    
    **Test 2: Interactive Mode Version Display**
    ```bash
    node bin/install.js
    ```
    Expected: Platform selection shows inline version (e.g., "Claude Code (v2.0.0)")
    
    **Test 3: Verbose Mode**
    ```bash
    node bin/install.js --check-updates --verbose
    ```
    Expected: Shows additional details about discovery process
    
    **Visual checks:**
    - [ ] Version status appears inline with platform names
    - [ ] Update arrows show (v2.0.0 ‚Üí v2.1.0) if applicable
    - [ ] Hints show update type (minor/major)
    - [ ] --check-updates exits without prompting for installation
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe any issues</resume-signal>
</task>

<task name="integrate-orchestrator-version-validation" type="auto">
  <files>bin/lib/installer/orchestrator.js</files>
  <action>
    Add version validation to orchestrator: block downgrades, warn on major updates, ask about customizations.
    
    **Import version modules at top:**
    ```javascript
    import { compareVersions } from '../version/version-checker.js';
    import { readManifestWithRepair } from '../version/manifest-reader.js';
    import { confirm } from '@clack/prompts';
    ```
    
    **Add version check before installation (in runInstallation):**
    ```javascript
    export async function runInstallation(platforms, scope, options = {}) {
      const packageJson = await fs.readJson(path.join(__dirname, '../../../package.json'));
      const currentVersion = packageJson.version;
      
      // Check for existing installations and validate versions
      for (const platform of platforms) {
        await validateVersionBeforeInstall(platform, scope, currentVersion, options);
      }
      
      // ... rest of installation flow
    }
    
    async function validateVersionBeforeInstall(platform, scope, currentVersion, options) {
      // Construct expected manifest path
      const manifestPath = getManifestPath(platform, scope);
      
      // Try to read existing manifest
      const manifestResult = await readManifestWithRepair(manifestPath);
      
      if (!manifestResult.success) {
        // No existing installation or unreadable - proceed normally
        return;
      }
      
      const manifest = manifestResult.manifest;
      const versionStatus = compareVersions(manifest.gsd_version, currentVersion);
      
      // Block downgrades completely (per context 2.3)
      if (versionStatus.status === 'downgrade') {
        throw new Error(`
Cannot downgrade GSD installation for ${platform}

  Installed: v${versionStatus.installed}
  Installer: v${versionStatus.current}

Downgrades are not supported. To use the latest version:

  npx get-shit-done-multi@latest

Or install a specific version:

  npx get-shit-done-multi@${versionStatus.installed}
        `.trim());
      }
      
      // Warn on major version updates (per context 2.4)
      if (versionStatus.status === 'major_update' && !options.yes) {
        console.log('');
        console.log(`‚ö†Ô∏è  Major version update detected for ${platform}`);
        console.log('');
        console.log(`   ${versionStatus.installed} ‚Üí ${versionStatus.current}`);
        console.log('');
        console.log('   Major updates may include breaking changes.');
        console.log('   Your existing workflows might need updates.');
        console.log('');
        
        const confirmed = await confirm({
          message: `Continue with major version update for ${platform}?`,
          initialValue: true
        });
        
        if (!confirmed || confirmed === Symbol.for('cancelled')) {
          throw new Error(`Update cancelled for ${platform}`);
        }
      }
      
      // Ask about customization preservation (per context 3.1)
      if (versionStatus.status === 'update_available' || versionStatus.status === 'major_update') {
        if (!options.yes) {
          console.log('');
          const preserveCustomizations = await confirm({
            message: `Preserve customizations for ${platform}?`,
            initialValue: true
          });
          
          if (preserveCustomizations && preserveCustomizations !== Symbol.for('cancelled')) {
            console.log('');
            console.log('üí° Consider contributing your improvements:');
            console.log(`   ${packageJson.repository?.url || 'https://github.com/shoootyou/get-shit-done-multi'}`);
            console.log('');
            
            // Store preference for installation phase
            options.preserveCustomizations = true;
          } else {
            options.preserveCustomizations = false;
          }
        }
      }
    }
    
    function getManifestPath(platform, scope) {
      const homeDir = require('os').homedir();
      const base = scope === 'global' ? homeDir : process.cwd();
      
      const platformDirs = {
        'claude': '.claude',
        'copilot': scope === 'global' ? '.copilot' : '.github',
        'codex': '.codex'
      };
      
      const platformDir = platformDirs[platform] || `.${platform}`;
      return path.join(base, platformDir, 'get-shit-done', '.gsd-install-manifest.json');
    }
    ```
    
    **Update copy operations to respect preserveCustomizations:**
    If options.preserveCustomizations is true, use fs.copy with overwrite:false.
    
    **Implementation note:**
    The actual file copy logic might be in a different module (installation-core or file-operations).
    Just ensure the preserveCustomizations flag is passed through and respected.
  </action>
  <verify>
    ```bash
    # Verify imports
    grep -q "compareVersions" bin/lib/installer/orchestrator.js
    grep -q "validateVersionBeforeInstall" bin/lib/installer/orchestrator.js
    
    # Check downgrade blocking
    grep -q "Cannot downgrade" bin/lib/installer/orchestrator.js
    
    # Check major version warning
    grep -q "Major updates may include breaking changes" bin/lib/installer/orchestrator.js
    
    # Check customization prompt
    grep -q "Preserve customizations" bin/lib/installer/orchestrator.js
    ```
  </verify>
  <done>Orchestrator validates versions before installation, blocks downgrades with error, warns on major updates with confirmation, asks about customization preservation</done>
</task>

<task name="create-integration-test" type="auto">
  <files>tests/integration/update-detection.test.js</files>
  <action>
    Create integration test for full update detection flow.
    
    ```javascript
    import { describe, it, expect, beforeEach, afterEach } from 'vitest';
    import fs from 'fs-extra';
    import path from 'path';
    import os from 'os';
    import { findInstallations } from '../../bin/lib/version/installation-finder.js';
    import { readManifestWithRepair } from '../../bin/lib/version/manifest-reader.js';
    import { compareVersions, formatPlatformOption } from '../../bin/lib/version/version-checker.js';
    
    describe('update-detection integration', () => {
      let testDir;
      
      beforeEach(async () => {
        testDir = path.join(os.tmpdir(), `gsd-test-update-${Date.now()}`);
        await fs.ensureDir(testDir);
      });
      
      afterEach(async () => {
        await fs.remove(testDir);
      });
      
      it('should detect outdated local installation', async () => {
        // Setup: Create local installation with old version
        const installDir = path.join(testDir, '.claude', 'get-shit-done');
        await fs.ensureDir(installDir);
        
        const manifest = {
          gsd_version: '1.9.0',
          platform: 'claude',
          scope: 'local',
          installed_at: new Date().toISOString(),
          files: []
        };
        
        const manifestPath = path.join(installDir, '.gsd-install-manifest.json');
        await fs.writeJson(manifestPath, manifest);
        
        // Change to test directory
        const originalCwd = process.cwd();
        process.chdir(testDir);
        
        // Act: Find and check version
        const found = await findInstallations('local');
        expect(found.length).toBe(1);
        
        const manifestResult = await readManifestWithRepair(found[0].path);
        expect(manifestResult.success).toBe(true);
        
        const versionStatus = compareVersions(manifestResult.manifest.gsd_version, '2.0.0');
        
        // Assert: Update available
        expect(versionStatus.status).toBe('update_available');
        expect(versionStatus.installed).toBe('1.9.0');
        expect(versionStatus.current).toBe('2.0.0');
        
        // Assert: Format displays correctly
        const formatted = formatPlatformOption('claude', versionStatus);
        expect(formatted).toContain('1.9.0 ‚Üí 2.0.0');
        
        process.chdir(originalCwd);
      });
      
      it('should detect major version jump', async () => {
        const installDir = path.join(testDir, '.codex', 'get-shit-done');
        await fs.ensureDir(installDir);
        
        const manifest = {
          gsd_version: '2.5.0',
          platform: 'codex',
          scope: 'local',
          installed_at: new Date().toISOString(),
          files: []
        };
        
        await fs.writeJson(path.join(installDir, '.gsd-install-manifest.json'), manifest);
        
        const originalCwd = process.cwd();
        process.chdir(testDir);
        
        const found = await findInstallations('local');
        const manifestResult = await readManifestWithRepair(found[0].path);
        const versionStatus = compareVersions(manifestResult.manifest.gsd_version, '3.0.0');
        
        expect(versionStatus.status).toBe('major_update');
        expect(versionStatus.majorJump).toBe('2.x ‚Üí 3.x');
        
        const formatted = formatPlatformOption('codex', versionStatus);
        expect(formatted).toContain('‚ö†Ô∏è  major');
        
        process.chdir(originalCwd);
      });
      
      it('should handle up-to-date installation', async () => {
        const installDir = path.join(testDir, '.github', 'get-shit-done');
        await fs.ensureDir(installDir);
        
        const manifest = {
          gsd_version: '2.0.0',
          platform: 'copilot',
          scope: 'local',
          installed_at: new Date().toISOString(),
          files: []
        };
        
        await fs.writeJson(path.join(installDir, '.gsd-install-manifest.json'), manifest);
        
        const originalCwd = process.cwd();
        process.chdir(testDir);
        
        const found = await findInstallations('local');
        const manifestResult = await readManifestWithRepair(found[0].path);
        const versionStatus = compareVersions(manifestResult.manifest.gsd_version, '2.0.0');
        
        expect(versionStatus.status).toBe('up_to_date');
        
        const formatted = formatPlatformOption('copilot', versionStatus);
        expect(formatted).toBe('GitHub Copilot (v2.0.0)');
        
        process.chdir(originalCwd);
      });
      
      it('should handle multiple platforms', async () => {
        // Create installations for all three platforms
        const platforms = [
          { dir: '.claude', platform: 'claude', version: '1.8.0' },
          { dir: '.github', platform: 'copilot', version: '2.0.0' },
          { dir: '.codex', platform: 'codex', version: '2.1.0' }
        ];
        
        const originalCwd = process.cwd();
        process.chdir(testDir);
        
        for (const p of platforms) {
          const installDir = path.join(testDir, p.dir, 'get-shit-done');
          await fs.ensureDir(installDir);
          
          const manifest = {
            gsd_version: p.version,
            platform: p.platform,
            scope: 'local',
            installed_at: new Date().toISOString(),
            files: []
          };
          
          await fs.writeJson(path.join(installDir, '.gsd-install-manifest.json'), manifest);
        }
        
        const found = await findInstallations('local');
        expect(found.length).toBe(3);
        
        // Check version statuses
        const statuses = await Promise.all(
          found.map(async (install) => {
            const manifestResult = await readManifestWithRepair(install.path);
            return {
              platform: install.platform,
              status: compareVersions(manifestResult.manifest.gsd_version, '2.0.0')
            };
          })
        );
        
        const claudeStatus = statuses.find(s => s.platform === 'claude');
        expect(claudeStatus.status.status).toBe('update_available');
        
        const copilotStatus = statuses.find(s => s.platform === 'copilot');
        expect(copilotStatus.status.status).toBe('up_to_date');
        
        const codexStatus = statuses.find(s => s.platform === 'codex');
        expect(codexStatus.status.status).toBe('downgrade'); // 2.1.0 > 2.0.0
        
        process.chdir(originalCwd);
      });
      
      it('should repair corrupted manifest and detect version', async () => {
        const installDir = path.join(testDir, '.claude', 'get-shit-done');
        await fs.ensureDir(installDir);
        
        // Create some files
        await fs.writeFile(path.join(installDir, 'test.txt'), 'test content');
        
        // Write corrupted manifest
        const manifestPath = path.join(installDir, '.gsd-install-manifest.json');
        await fs.writeJson(manifestPath, { partial: true });
        
        const originalCwd = process.cwd();
        process.chdir(testDir);
        
        const found = await findInstallations('local');
        const manifestResult = await readManifestWithRepair(found[0].path);
        
        // Should succeed after repair
        expect(manifestResult.success).toBe(true);
        if (manifestResult.repaired) {
          expect(manifestResult.manifest._repaired).toBe(true);
        }
        
        process.chdir(originalCwd);
      });
    });
    ```
    
    **Run integration test:**
    ```bash
    npm test -- tests/integration/update-detection.test.js
    ```
  </action>
  <verify>
    ```bash
    # Run integration test
    npm test -- tests/integration/update-detection.test.js 2>&1 | tee /tmp/integration-test.txt
    
    # Verify tests passed
    grep -q "‚úì" /tmp/integration-test.txt && echo "Integration tests passing"
    ```
  </verify>
  <done>Integration test created covering full update detection flow: outdated installations, major bumps, up-to-date, multiple platforms, manifest repair</done>
</task>

<task name="update-roadmap" type="auto">
  <files>.planning/ROADMAP.md</files>
  <action>
    Update ROADMAP.md to reflect Phase 6 completion.
    
    Find Phase 6 section and update:
    - Status: Pending ‚Üí Complete
    - Plans: 0 plans ‚Üí 2 plans
    - Add plan checkboxes:
      ```
      Plans:
      - [ ] 06-01-PLAN.md ‚Äî Core Version Detection Modules
      - [ ] 06-02-PLAN.md ‚Äî Interactive CLI Integration & Update Flow
      ```
  </action>
  <verify>
    ```bash
    grep -A 20 "Phase 6:" .planning/ROADMAP.md | grep "2 plans"
    grep -A 20 "Phase 6:" .planning/ROADMAP.md | grep "06-01-PLAN.md"
    ```
  </verify>
  <done>ROADMAP.md updated with Phase 6 plan count and plan list</done>
</task>

## Verification

**Integration tests:**
```bash
# Run all version tests
npm test -- tests/version/
npm test -- tests/integration/update-detection.test.js

# Manual end-to-end test
node bin/install.js --check-updates
node bin/install.js  # Interactive mode
```

**Visual verification:**
1. Platform selection shows inline version status
2. Outdated installations show arrow (v2.0.0 ‚Üí v2.1.0)
3. Major updates show warning emoji
4. --check-updates displays all installations without prompting
5. --verbose shows detailed discovery process

## Success Criteria

1. ‚úÖ --check-updates flag works without installation
2. ‚úÖ --verbose flag shows discovery details
3. ‚úÖ --custom-path flag accepts additional paths
4. ‚úÖ Interactive mode discovers installations before platform selection
5. ‚úÖ Platform options formatted with inline version status
6. ‚úÖ Hints updated based on update availability
7. ‚úÖ Orchestrator validates versions before installation
8. ‚úÖ Downgrade attempts blocked with helpful error
9. ‚úÖ Major version updates show warning and confirmation prompt
10. ‚úÖ Customization preservation prompt shown for updates
11. ‚úÖ Contribution link displayed when preserving customizations
12. ‚úÖ Integration tests passing (5+ tests)
13. ‚úÖ ROADMAP.md updated

## Output

**Complete update detection and versioning system:**
- Users see inline version status in platform selection
- Auto-update on platform selection (no extra prompt)
- Downgrades blocked with helpful message
- Major updates require confirmation
- Customizations can be preserved
- Three new CLI flags for version checking
