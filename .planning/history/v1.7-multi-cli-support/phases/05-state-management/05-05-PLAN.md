---
phase: 05-state-management
plan: 05
type: execute
wave: 4
depends_on: [05-01, 05-02, 05-03, 05-04]
files_modified:
  - lib-ghcc/orchestration/agent-invoker.js
  - lib-ghcc/state-integration.js
  - bin/test-state-management.js
autonomous: true

must_haves:
  truths:
    - "Agent invocations use state locking to prevent corruption"
    - "Cross-CLI agent invocation works without state issues"
    - "Two CLIs can run simultaneously without corrupting state"
    - "State management integration tested across all scenarios"
  artifacts:
    - path: "lib-ghcc/state-integration.js"
      provides: "Integration wiring for state management"
      exports: ["integrateStateManagement"]
      min_lines: 80
    - path: "bin/test-state-management.js"
      provides: "State management test suite"
      min_lines: 200
  key_links:
    - from: "lib-ghcc/orchestration/agent-invoker.js"
      to: "lib-ghcc/directory-lock.js"
      via: "wraps invocations with locks"
      pattern: "DirectoryLock.*withLock"
    - from: "bin/test-state-management.js"
      to: "all state modules"
      via: "comprehensive testing"
      pattern: "import.*state"
---

<objective>
Wire state management into agent orchestration and verify cross-CLI compatibility with comprehensive tests.

Purpose: Complete Phase 5 by integrating all state components and validating multi-CLI workflows
Output: Integrated state management with full test coverage
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-state-management/05-RESEARCH.md
@.planning/phases/04-agent-translation/04-01-SUMMARY.md
@.planning/phases/05-state-management/05-01-PLAN.md
@.planning/phases/05-state-management/05-02-PLAN.md
@.planning/phases/05-state-management/05-03-PLAN.md
@.planning/phases/05-state-management/05-04-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire state management into agent invocation</name>
  <files>lib-ghcc/state-integration.js, lib-ghcc/orchestration/agent-invoker.js</files>
  <action>
**Part A: Create state-integration.js:**

Create `lib-ghcc/state-integration.js` with integration helper:

**integrateStateManagement(stateDir = '.planning'):**
- Return object with initialized state modules:
```js
{
  stateManager: new StateManager(stateDir),
  sessionManager: new SessionManager(stateDir),
  stateValidator: new StateValidator(stateDir),
  cliFallback: new CLIFallback(stateDir),
  usageTracker: new UsageTracker(stateDir),
  lock: new DirectoryLock(path.join(stateDir, '.lock'))
}
```

- Import all state management classes
- Export single integration function
- Zero npm dependencies

**Part B: Update agent-invoker.js:**

Find existing `lib-ghcc/orchestration/agent-invoker.js` (created in Phase 4).

Add state management integration:

1. Import at top:
```js
import { integrateStateManagement } from '../state-integration.js';
```

2. Initialize state modules (module-level):
```js
const stateModules = integrateStateManagement();
```

3. Wrap invokeAgent() with locking:
```js
// Existing invokeAgent function signature
async function invokeAgent(agent, prompt, options = {}) {
  // Add locking wrapper
  return await stateModules.lock.withLock(async () => {
    // Existing invocation logic stays here
    const startTime = Date.now();
    
    // ... existing code ...
    
    // Track usage after invocation
    await stateModules.usageTracker.trackUsage({
      timestamp: Date.now(),
      cli: detectedCLI,
      command: 'invoke-agent',
      agent: agent,
      duration: Date.now() - startTime,
      tokens: { input: 0, output: 0 }, // estimate if possible
      cost: 0  // calculate if possible
    });
    
    return result;
  });
}
```

4. Add fallback support (optional enhancement):
```js
// If options.enableFallback, use CLIFallback
if (options.enableFallback) {
  return await stateModules.cliFallback.executeWithFallback(
    async (cli) => { /* existing invocation logic */ }
  );
}
```

**Why this approach:**
- Single import brings in all state management
- Lock wrapping prevents concurrent corruption
- Usage tracking happens automatically
- Minimal changes to existing agent-invoker code
  </action>
  <verify>
```bash
# Verify state-integration exports
node -e "import('./lib-ghcc/state-integration.js').then(m => console.log(Object.keys(m)))"

# Verify agent-invoker imports state modules
grep -q "state-integration" lib-ghcc/orchestration/agent-invoker.js && echo "PASS" || echo "FAIL"
```
  </verify>
  <done>
- lib-ghcc/state-integration.js exists with integrateStateManagement export
- agent-invoker.js imports and uses state modules
- invokeAgent wrapped with DirectoryLock for concurrent safety
- Usage tracking integrated into agent invocations
- Fallback support available via options.enableFallback flag
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive state management tests</name>
  <files>bin/test-state-management.js</files>
  <action>
Create `bin/test-state-management.js` with comprehensive test suite:

**Structure:**
```js
#!/usr/bin/env node
import { /* all state modules */ } from '../lib-ghcc/state-integration.js';

// Test utilities
function assert(condition, message) {
  if (!condition) throw new Error(`FAIL: ${message}`);
  console.log(`✅ ${message}`);
}

async function cleanupTest(dir) {
  await fs.promises.rm(dir, { recursive: true, force: true });
}

// Test suite
async function runTests() {
  const testDir = `/tmp/gsd-state-test-${Date.now()}`;
  
  try {
    // Test 1: Atomic write survives concurrent attempts
    await testAtomicWrites(testDir);
    
    // Test 2: Directory lock prevents concurrent corruption
    await testDirectoryLocking(testDir);
    
    // Test 3: State migration creates backup
    await testStateMigration(testDir);
    
    // Test 4: Session persistence across "CLI switches"
    await testSessionPersistence(testDir);
    
    // Test 5: State validation detects corruption
    await testStateValidation(testDir);
    
    // Test 6: CLI fallback tries multiple CLIs
    await testCLIFallback(testDir);
    
    // Test 7: Usage tracking accumulates stats
    await testUsageTracking(testDir);
    
    // Test 8: Concurrent CLI usage (simulate with child processes)
    await testConcurrentUsage(testDir);
    
    console.log('\n✅ All state management tests passed');
  } catch (err) {
    console.error('\n❌ Test failed:', err.message);
    process.exit(1);
  } finally {
    await cleanupTest(testDir);
  }
}

// Individual test implementations
async function testAtomicWrites(dir) {
  // Create multiple concurrent writes
  // Verify no corruption
}

async function testDirectoryLocking(dir) {
  // Acquire lock, verify second acquisition waits
  // Release lock, verify second acquisition succeeds
}

async function testStateMigration(dir) {
  // Create old version state
  // Run migration
  // Verify backup exists and state updated
}

async function testSessionPersistence(dir) {
  // Save session with CLI A
  // Load session as CLI B
  // Verify data preserved
}

async function testStateValidation(dir) {
  // Create invalid state (missing version, corrupt JSON)
  // Run validator
  // Verify errors detected
}

async function testCLIFallback(dir) {
  // Mock operation that fails on first CLI
  // Verify fallback tries second CLI
}

async function testUsageTracking(dir) {
  // Track multiple events
  // Verify summary stats correct
}

async function testConcurrentUsage(dir) {
  // Use child_process to spawn 2 concurrent writes
  // Verify both complete without corruption
}

runTests().catch(console.error);
```

Add chmod +x to make executable.

Use simple assertions (no test framework, per zero-dependency constraint).
Tests should run in <10 seconds total.

**Why this approach:**
- Executable test file (#!/usr/bin/env node) for direct running
- Each test isolated with clean temp directory
- Concurrent usage test uses child processes (realistic simulation)
- Simple assert function (no jest/mocha dependency)
  </action>
  <verify>
```bash
chmod +x bin/test-state-management.js
node bin/test-state-management.js
```
Should output: ✅ All state management tests passed
  </verify>
  <done>
- bin/test-state-management.js exists and is executable
- Tests cover: atomic writes, locking, migration, sessions, validation, fallback, usage, concurrency
- All tests pass showing state management works correctly
- Tests run in under 10 seconds
- Zero npm test framework dependencies
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify cross-CLI state compatibility</name>
  <files>bin/test-cross-cli-state.js</files>
  <action>
Create `bin/test-cross-cli-state.js` for integration verification:

**Cross-CLI compatibility tests:**

```js
#!/usr/bin/env node
// Simulate using state from different CLIs

import { integrateStateManagement } from '../lib-ghcc/state-integration.js';

async function runCrossCLITests() {
  const testDir = `/tmp/gsd-cross-cli-${Date.now()}`;
  const state = integrateStateManagement(testDir);
  
  console.log('Testing cross-CLI state compatibility...\n');
  
  // Test 1: Write from "Claude Code", read from "Codex CLI"
  console.log('Test 1: Cross-CLI state read/write');
  await state.sessionManager.saveSession({
    cli: 'claude-code',
    currentPhase: '05',
    context: { test: 'data' }
  });
  
  // Simulate CLI switch
  const loaded = await state.sessionManager.loadSession();
  assert(loaded.currentPhase === '05', 'Session data preserved across CLI');
  assert(loaded.context.test === 'data', 'Context preserved');
  
  // Test 2: Concurrent state access simulation
  console.log('Test 2: Concurrent state access');
  const results = await Promise.all([
    state.stateManager.updateState('test.json', s => ({ ...s, a: 1 })),
    state.stateManager.updateState('test.json', s => ({ ...s, b: 2 })),
  ]);
  // One should succeed, both should complete without corruption
  assert(results.length === 2, 'Both updates completed');
  
  // Test 3: State validation after switching
  console.log('Test 3: State validation post-switch');
  const validation = await state.stateValidator.validate();
  assert(validation.valid, 'State remains valid after operations');
  
  // Test 4: Usage tracking aggregates across CLIs
  console.log('Test 4: Usage tracking aggregation');
  await state.usageTracker.trackUsage({ cli: 'claude-code', command: 'test1', duration: 100 });
  await state.usageTracker.trackUsage({ cli: 'codex-cli', command: 'test2', duration: 200 });
  const summary = await state.usageTracker.getUsageSummary();
  assert(summary.totalCommands === 2, 'Commands from both CLIs tracked');
  assert(summary.perCLI['claude-code'], 'Claude stats tracked');
  assert(summary.perCLI['codex-cli'], 'Codex stats tracked');
  
  console.log('\n✅ All cross-CLI tests passed');
  
  // Cleanup
  await fs.promises.rm(testDir, { recursive: true, force: true });
}

function assert(condition, message) {
  if (!condition) throw new Error(`FAIL: ${message}`);
  console.log(`  ✅ ${message}`);
}

runCrossCLITests().catch(err => {
  console.error('\n❌ Cross-CLI test failed:', err.message);
  process.exit(1);
});
```

Add chmod +x to make executable.

**Why this approach:**
- Simulates realistic multi-CLI workflow
- Tests state preservation across "switches"
- Validates concurrent access safety
- Confirms usage aggregation works
  </action>
  <verify>
```bash
chmod +x bin/test-cross-cli-state.js
node bin/test-cross-cli-state.js
```
Should output: ✅ All cross-CLI tests passed
  </verify>
  <done>
- bin/test-cross-cli-state.js exists and is executable
- Tests simulate writing from one CLI and reading from another
- Concurrent state access tested with Promise.all
- Usage tracking verified to aggregate across CLIs
- All cross-CLI compatibility scenarios passing
  </done>
</task>

</tasks>

<verification>
Run complete verification:
```bash
# Run unit tests
node bin/test-state-management.js

# Run integration tests
node bin/test-cross-cli-state.js

# Verify agent-invoker integration
node -e "import('./lib-ghcc/orchestration/agent-invoker.js').then(() => console.log('Integration: PASS'))"
```

All tests should pass showing:
- Atomic operations work correctly
- Locking prevents corruption
- Cross-CLI state compatibility verified
- Agent invocation integrated with state management
</verification>

<success_criteria>
1. agent-invoker.js uses DirectoryLock to wrap invocations
2. Usage tracking automatically logs all agent invocations
3. test-state-management.js covers all 8 core scenarios
4. test-cross-cli-state.js validates multi-CLI workflows
5. All tests pass demonstrating Phase 5 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-management/05-05-SUMMARY.md`
</output>
