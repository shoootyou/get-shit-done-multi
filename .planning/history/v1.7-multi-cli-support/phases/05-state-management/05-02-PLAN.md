---
phase: 05-state-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib-ghcc/state-manager.js
  - lib-ghcc/state-migrations.js
autonomous: true

must_haves:
  truths:
    - "State files include version number for migration tracking"
    - "Reading state from one CLI works in another CLI"
    - "Upgrading GSD version doesn't lose existing state"
    - "Config changes persist across CLI switches"
  artifacts:
    - path: "lib-ghcc/state-manager.js"
      provides: "High-level state management API"
      exports: ["StateManager"]
      min_lines: 150
    - path: "lib-ghcc/state-migrations.js"
      provides: "State schema migration framework"
      exports: ["migrateState", "CURRENT_STATE_VERSION"]
      min_lines: 80
  key_links:
    - from: "lib-ghcc/state-manager.js"
      to: "lib-ghcc/state-io.js"
      via: "uses atomic operations"
      pattern: "atomicWriteJSON|atomicReadJSON"
    - from: "lib-ghcc/state-migrations.js"
      to: "fs/promises"
      via: "backup before migration"
      pattern: "fs\\.promises\\.cp"
---

<objective>
Create state management core with versioning, migration, and CLI-agnostic access to .planning/ state.

Purpose: Enable seamless state reading/writing across Claude, Copilot, and Codex CLIs
Output: StateManager class and migration framework for version upgrades
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-state-management/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StateManager class</name>
  <files>lib-ghcc/state-manager.js</files>
  <action>
Create `lib-ghcc/state-manager.js` implementing StateManager class:

**StateManager class:**

Constructor(stateDir = '.planning'):
- Store stateDir path
- No initialization in constructor (lazy loading)

async readState(filename = 'STATE.md'):
- Build path: path.join(stateDir, filename)
- Use atomicReadJSON() from state-io.js (will create import)
- Return state object with _version field
- If file doesn't exist, return initial state: { _version: 1 }

async writeState(filename = 'STATE.md', data):
- Ensure data includes _version field
- Build path: path.join(stateDir, filename)
- Use atomicWriteJSON() from state-io.js
- Return void

async updateState(filename = 'STATE.md', updateFn):
- Read current state
- Apply updateFn(state) to get updated state
- Increment _version
- Write updated state
- Return updated state

async readConfig():
- Path: .planning/config.json
- Use atomicReadJSON with default: {}
- Merge with default config:
  ```js
  {
    fallbackOrder: ['claude-code', 'github-copilot-cli', 'codex-cli'],
    maxRetries: 3,
    lockTimeout: 10000
  }
  ```

async writeConfig(config):
- Path: .planning/config.json
- Merge with existing config (preserve user customizations)
- Use atomicWriteJSON

async ensureStateDir():
- Create .planning/ if doesn't exist
- Use fs.promises.mkdir(stateDir, { recursive: true })

Import atomicWriteJSON and atomicReadJSON from './state-io.js'.
Use ES modules, zero npm dependencies.

**Why this approach:**
- Filename parameter allows managing multiple state files (state.json, usage.json, etc.)
- Lazy loading prevents file I/O during object construction
- updateState() provides read-modify-write with version increment
- Default config ensures graceful degradation when config.json missing
  </action>
  <verify>
```bash
node -e "import('./lib-ghcc/state-manager.js').then(m => console.log(Object.keys(m)))"
```
Should output: [ 'StateManager' ]
  </verify>
  <done>
- lib-ghcc/state-manager.js exists with StateManager class export
- StateManager provides readState, writeState, updateState methods
- StateManager provides readConfig, writeConfig for .planning/config.json
- All state operations include _version field for migration tracking
- StateManager uses atomicWriteJSON/atomicReadJSON from state-io.js
  </done>
</task>

<task type="auto">
  <name>Task 2: Create state migration framework</name>
  <files>lib-ghcc/state-migrations.js</files>
  <action>
Create `lib-ghcc/state-migrations.js` implementing migration framework from 05-RESEARCH.md:

**Exports:**

CURRENT_STATE_VERSION = 1 (constant):
- Current schema version
- Increment when state format changes

async migrateState(stateDir = '.planning'):
- Read .planning/.meta.json to get current version
- If file missing, assume version: 0 (pre-versioning)
- If version === CURRENT_STATE_VERSION, return (no-op)

**Migration process:**
1. Create backup:
   - backupDir = path.join(stateDir, `backup-v${currentVersion}-${Date.now()}`)
   - fs.promises.mkdir(backupDir, { recursive: true })
   - fs.promises.cp(stateDir, backupDir, { recursive: true, filter: (src) => !src.includes('backup-') })

2. Apply migrations sequentially:
   - migrations = {} (object with version keys)
   - for (let v = currentVersion; v < CURRENT_STATE_VERSION; v++)
   - await migrations[v](stateDir) if migration exists
   - (v1 migrations TBD - placeholder for future schema changes)

3. Update .meta.json:
   - atomicWriteJSON(.planning/.meta.json, { version: CURRENT_STATE_VERSION, migratedAt: Date.now() })

async validateState(stateDir = '.planning'):
- Check required structure:
  - .planning/ exists
  - .planning/.meta.json has valid version
- Check STATE.md, config.json parseable
- Return { valid: true/false, errors: [], warnings: [] }

Import atomicWriteJSON, atomicReadJSON from './state-io.js'.
Use ES modules, fs/promises, path, zero npm dependencies.

**Why this approach:**
- Backup before migration ensures rollback capability
- Sequential migration application allows incremental schema changes
- .meta.json separate from state files to avoid version conflicts
- Filter prevents recursive backup-of-backups
  </action>
  <verify>
```bash
node -e "import('./lib-ghcc/state-migrations.js').then(m => console.log(Object.keys(m)))"
```
Should output: [ 'migrateState', 'validateState', 'CURRENT_STATE_VERSION' ]
  </verify>
  <done>
- lib-ghcc/state-migrations.js exists with migrateState, validateState, CURRENT_STATE_VERSION exports
- migrateState creates backup before applying migrations
- migrateState updates .meta.json with current version
- validateState checks .planning/ structure and file integrity
- Migration framework ready for future schema changes
  </done>
</task>

</tasks>

<verification>
Run state management smoke tests:
```bash
# Test StateManager basic operations
node -e "import('./lib-ghcc/state-manager.js').then(async m => {
  const sm = new m.StateManager('/tmp/test-planning');
  await sm.ensureStateDir();
  await sm.writeState('test.json', { foo: 'bar', _version: 1 });
  const state = await sm.readState('test.json');
  console.log('StateManager:', state.foo === 'bar' ? 'PASS' : 'FAIL');
})"

# Test migration framework
node -e "import('./lib-ghcc/state-migrations.js').then(async m => {
  const result = await m.validateState('/tmp/test-planning');
  console.log('Migration:', result.valid ? 'PASS' : 'FAIL');
})"
```
</verification>

<success_criteria>
1. StateManager reads and writes state files with version tracking
2. StateManager merges user config with defaults gracefully
3. migrateState creates backup before applying migrations
4. validateState detects missing or corrupted state files
5. All operations CLI-agnostic (work same across Claude, Copilot, Codex)
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-management/05-02-SUMMARY.md`
</output>
