---
phase: 05-state-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib-ghcc/state-io.js
  - lib-ghcc/directory-lock.js
autonomous: true

must_haves:
  truths:
    - "File writes complete atomically or not at all"
    - "Process can acquire exclusive lock on .planning/ directory"
    - "Lock automatically releases on process exit or crash"
    - "Concurrent writes don't corrupt JSON files"
  artifacts:
    - path: "lib-ghcc/state-io.js"
      provides: "Atomic file operations (write-then-rename)"
      exports: ["atomicWriteJSON", "atomicReadJSON"]
      min_lines: 80
    - path: "lib-ghcc/directory-lock.js"
      provides: "Directory-based locking mechanism"
      exports: ["DirectoryLock"]
      min_lines: 100
  key_links:
    - from: "lib-ghcc/state-io.js"
      to: "fs/promises"
      via: "rename for atomicity"
      pattern: "fs\\.promises\\.rename"
    - from: "lib-ghcc/directory-lock.js"
      to: "fs/promises"
      via: "mkdir for lock acquisition"
      pattern: "fs\\.promises\\.mkdir"
---

<objective>
Create atomic file I/O operations and directory-based locking to prevent data corruption during concurrent CLI usage.

Purpose: Foundation for safe multi-CLI state management without npm dependencies
Output: Zero-dependency file operations with atomicity guarantees
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-state-management/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create atomic file I/O operations</name>
  <files>lib-ghcc/state-io.js</files>
  <action>
Create `lib-ghcc/state-io.js` implementing atomic file operations using write-then-rename pattern from 05-RESEARCH.md:

**atomicWriteJSON(filePath, data):**
- Write to `${filePath}.${process.pid}.tmp` with mode 0o600
- Use JSON.stringify(data, null, 2) for formatting
- Atomically rename temp file to target using fs.promises.rename()
- Catch EXDEV error with clear message about cross-filesystem boundary
- Clean up temp file on any error
- Return void on success, throw on failure

**atomicReadJSON(filePath, options = {}):**
- Read file with fs.promises.readFile(filePath, 'utf8')
- Parse JSON with try/catch for SyntaxError
- If options.retry (default: 3), retry on JSON parse errors with 50ms delay (may catch mid-write)
- Return parsed object or options.default if ENOENT and default provided
- Throw on parse errors after retries exhausted

Use ES modules (import/export), fs/promises API, zero npm dependencies.

**Why this approach:**
- Write-then-rename ensures atomicity (POSIX guarantee on same filesystem)
- Process PID in temp filename prevents conflicts between concurrent processes
- Retry logic handles transient read-during-write scenarios
- No fs.exists() check (TOCTOU anti-pattern per 05-RESEARCH.md)
  </action>
  <verify>
```bash
node -e "import('./lib-ghcc/state-io.js').then(m => console.log(Object.keys(m)))"
```
Should output: [ 'atomicWriteJSON', 'atomicReadJSON' ]
  </verify>
  <done>
- lib-ghcc/state-io.js exists with atomicWriteJSON and atomicReadJSON exports
- atomicWriteJSON uses write-then-rename pattern with EXDEV handling
- atomicReadJSON has retry logic for JSON parse errors
- All operations use fs/promises (async/await)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create directory-based locking mechanism</name>
  <files>lib-ghcc/directory-lock.js</files>
  <action>
Create `lib-ghcc/directory-lock.js` implementing DirectoryLock class from 05-RESEARCH.md:

**DirectoryLock class:**

Constructor(lockPath, options = {}):
- Store lockPath (e.g., `.planning/.lock`)
- maxRetries (default: 10)
- baseDelay (default: 100ms)

async acquire():
- Loop up to maxRetries attempts
- Try fs.promises.mkdir(lockPath) - atomic operation
- On EEXIST error: exponential backoff with jitter
  - delay = baseDelay * Math.pow(2, attempt)
  - jitter = Math.random() * 100
  - await setTimeout(delay + jitter)
  - Continue to next attempt
- On success: return true
- After maxRetries: throw Error with clear message
- Other errors: throw immediately

async release():
- Try fs.promises.rmdir(lockPath)
- Ignore ENOENT (already released)
- Throw on other errors

async withLock(operation):
- await this.acquire()
- try { return await operation() }
- finally { await this.release() }

Use ES modules, fs/promises API, zero npm dependencies.

**Why this approach:**
- fs.mkdir() is atomic across processes (OS kernel guarantee)
- Exponential backoff with jitter prevents thundering herd
- withLock() ensures cleanup via finally block even on errors
- No PID files (simpler, startup cleanup handles stale locks)
  </action>
  <verify>
```bash
node -e "import('./lib-ghcc/directory-lock.js').then(m => console.log(Object.keys(m)))"
```
Should output: [ 'DirectoryLock' ]
  </verify>
  <done>
- lib-ghcc/directory-lock.js exists with DirectoryLock class export
- DirectoryLock.acquire() uses fs.mkdir() with exponential backoff
- DirectoryLock.release() removes lock directory safely
- DirectoryLock.withLock() provides automatic cleanup via finally
  </done>
</task>

</tasks>

<verification>
Run basic smoke tests:
```bash
# Test atomic write
node -e "import('./lib-ghcc/state-io.js').then(async m => {
  await m.atomicWriteJSON('/tmp/test.json', {test: true});
  const data = await m.atomicReadJSON('/tmp/test.json');
  console.log('Atomic I/O:', data.test === true ? 'PASS' : 'FAIL');
})"

# Test directory lock
node -e "import('./lib-ghcc/directory-lock.js').then(async m => {
  const lock = new m.DirectoryLock('/tmp/test.lock');
  const result = await lock.withLock(async () => 'success');
  console.log('Directory Lock:', result === 'success' ? 'PASS' : 'FAIL');
})"
```
</verification>

<success_criteria>
1. atomicWriteJSON creates temp file and renames atomically with EXDEV error handling
2. atomicReadJSON retries on JSON parse errors before failing
3. DirectoryLock.acquire() succeeds when lock available, retries with backoff when held
4. DirectoryLock.withLock() automatically releases lock even on operation failure
5. All operations use Node.js built-ins (zero npm dependencies)
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-management/05-01-SUMMARY.md`
</output>
