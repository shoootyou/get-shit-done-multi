---
phase: 05-state-management
plan: 04
type: execute
wave: 3
depends_on: [05-03]
files_modified:
  - lib-ghcc/cli-fallback.js
  - lib-ghcc/usage-tracker.js
autonomous: true

must_haves:
  truths:
    - "Command fails in current CLI and automatically retries in next CLI"
    - "User sees which CLI was used for each operation"
    - "User can review API costs per CLI in usage.json"
    - "Fallback order configurable in .planning/config.json"
  artifacts:
    - path: "lib-ghcc/cli-fallback.js"
      provides: "Smart retry with CLI fallback logic"
      exports: ["CLIFallback"]
      min_lines: 120
    - path: "lib-ghcc/usage-tracker.js"
      provides: "Cost tracking per CLI"
      exports: ["UsageTracker"]
      min_lines: 100
  key_links:
    - from: "lib-ghcc/cli-fallback.js"
      to: "lib-ghcc/state-manager.js"
      via: "reads fallbackOrder config"
      pattern: "readConfig"
    - from: "lib-ghcc/usage-tracker.js"
      to: "lib-ghcc/state-io.js"
      via: "persists usage data"
      pattern: "atomicWriteJSON"
---

<objective>
Add resilience with smart CLI fallback and observability with cost tracking.

Purpose: Automatic recovery from CLI failures and visibility into multi-CLI usage costs
Output: CLIFallback for retry logic and UsageTracker for cost monitoring
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-state-management/05-RESEARCH.md
@.planning/phases/05-state-management/05-01-PLAN.md
@.planning/phases/05-state-management/05-02-PLAN.md
@.planning/phases/05-state-management/05-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLI fallback logic with smart retry</name>
  <files>lib-ghcc/cli-fallback.js</files>
  <action>
Create `lib-ghcc/cli-fallback.js` implementing CLIFallback class:

**CLIFallback class:**

Constructor(stateDir = '.planning'):
- Store stateDir
- stateManager = new StateManager(stateDir)
- Import StateManager from './state-manager.js'

async executeWithFallback(operation, options = {}):
- Load config to get fallbackOrder: ['claude-code', 'github-copilot-cli', 'codex-cli']
- options.maxRetries (default: from config or 3)
- options.currentCLI (default: detectCLI())
- options.skipCLIs (default: [])  // CLIs to skip

**Algorithm:**
1. Build CLI list: fallbackOrder filtered by skipCLIs
2. For each CLI in list (up to maxRetries):
   - Try: result = await operation(cli)
   - If success: return { success: true, cli, result, attempts }
   - If error:
     - Log error with CLI name
     - If last CLI in list: throw error
     - Continue to next CLI
3. After exhausting list: throw aggregated error with all attempts

**Return structure:**
```js
{
  success: boolean,
  cli: string,           // which CLI succeeded
  result: any,           // operation result
  attempts: number,      // how many CLIs tried
  errors: []             // errors from failed attempts
}
```

async getCurrentCLI():
- Use detectCLI() from existing detect.js
- Return current CLI name

async getFallbackOrder():
- Read .planning/config.json
- Return fallbackOrder array
- Default: ['claude-code', 'github-copilot-cli', 'codex-cli']

Use ES modules, import StateManager, detectCLI.
Zero npm dependencies.

**Why this approach:**
- Configurable fallback order gives users control
- skipCLIs allows excluding known-broken CLIs
- Aggregated errors help debugging why all CLIs failed
- Return structure includes CLI used for operation (traceability)
  </action>
  <verify>
```bash
node -e "import('./lib-ghcc/cli-fallback.js').then(m => console.log(Object.keys(m)))"
```
Should output: [ 'CLIFallback' ]
  </verify>
  <done>
- lib-ghcc/cli-fallback.js exists with CLIFallback class
- executeWithFallback tries multiple CLIs based on fallbackOrder
- Returns which CLI succeeded and how many attempts
- Aggregates errors from failed attempts for debugging
- Reads fallback order from .planning/config.json
  </done>
</task>

<task type="auto">
  <name>Task 2: Create usage tracking for cost monitoring</name>
  <files>lib-ghcc/usage-tracker.js</files>
  <action>
Create `lib-ghcc/usage-tracker.js` implementing UsageTracker class:

**UsageTracker class:**

Constructor(stateDir = '.planning'):
- Store stateDir
- usageFile = '.planning/usage.json'
- Import atomicWriteJSON, atomicReadJSON from './state-io.js'

async trackUsage(event):
- event structure:
  ```js
  {
    timestamp: Date.now(),
    cli: string,          // which CLI used
    command: string,      // command executed
    agent: string,        // agent invoked (if applicable)
    duration: number,     // milliseconds
    tokens: {
      input: number,      // estimated input tokens
      output: number      // estimated output tokens
    },
    cost: number          // estimated cost in USD (optional)
  }
  ```
- Load existing usage.json (default: { events: [], summary: {} })
- Append event to events array
- Update summary stats:
  - totalCommands
  - totalDuration
  - totalTokens
  - totalCost
  - perCLI stats (breakdown by CLI)
- Keep last 1000 events (prevent unbounded growth)
- Use atomicWriteJSON to save

async getUsageSummary():
- Read usage.json
- Return summary object:
  ```js
  {
    totalCommands: number,
    totalDuration: number,
    totalCost: number,
    perCLI: {
      'claude-code': { commands: N, duration: N, cost: N },
      'codex-cli': { commands: N, duration: N, cost: N }
    }
  }
  ```

async resetUsage():
- Clear usage.json or reset to initial state
- Backup old data to usage-backup-${timestamp}.json

async exportUsage(format = 'json'):
- Return usage data in requested format
- Formats: 'json', 'csv' (simple table)
- For CSV: timestamp,cli,command,duration,tokens,cost

Use ES modules, import atomicWriteJSON, atomicReadJSON.
Zero npm dependencies.

**Why this approach:**
- Bounded event storage (last 1000) prevents disk exhaustion
- Summary stats enable quick cost analysis without parsing all events
- Per-CLI breakdown helps users optimize CLI selection
- Export capability enables external analysis tools
  </action>
  <verify>
```bash
node -e "import('./lib-ghcc/usage-tracker.js').then(m => console.log(Object.keys(m)))"
```
Should output: [ 'UsageTracker' ]
  </verify>
  <done>
- lib-ghcc/usage-tracker.js exists with UsageTracker class
- trackUsage appends events and updates summary stats
- Events limited to last 1000 to prevent unbounded growth
- Summary includes per-CLI breakdown of commands, duration, cost
- Export to JSON or CSV format for external analysis
  </done>
</task>

</tasks>

<verification>
Run resilience and tracking smoke tests:
```bash
# Test CLI fallback
node -e "import('./lib-ghcc/cli-fallback.js').then(async m => {
  const fb = new m.CLIFallback('/tmp/test-planning');
  const order = await fb.getFallbackOrder();
  console.log('Fallback:', Array.isArray(order) ? 'PASS' : 'FAIL');
})"

# Test usage tracking
node -e "import('./lib-ghcc/usage-tracker.js').then(async m => {
  const ut = new m.UsageTracker('/tmp/test-planning');
  await ut.trackUsage({ cli: 'test', command: 'test', duration: 100 });
  const summary = await ut.getUsageSummary();
  console.log('Tracking:', summary.totalCommands === 1 ? 'PASS' : 'FAIL');
})"
```
</verification>

<success_criteria>
1. CLIFallback tries multiple CLIs in configured order on failure
2. CLIFallback returns which CLI succeeded for traceability
3. UsageTracker logs commands, duration, and estimated costs per CLI
4. Usage data persists to .planning/usage.json with atomic writes
5. Usage summary provides per-CLI breakdown for cost analysis
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-management/05-04-SUMMARY.md`
</output>
