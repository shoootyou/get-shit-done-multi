---
phase: 04-agent-translation
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - bin/lib/orchestration/result-validator.js
  - bin/lib/orchestration/result-validator.test.js
  - bin/lib/orchestration/validate-planning-dir.js
  - bin/lib/orchestration/equivalence-test.js
autonomous: true

must_haves:
  truths:
    - "Result validator checks .planning/ directory structure is CLI-compatible"
    - "Validator detects missing required files and directories"
    - "JSON files validated for parseability"
    - "Agent output format validated for cross-CLI consistency"
    - "Equivalence tests verify same inputs produce same outputs across CLIs"
  artifacts:
    - path: "bin/lib/orchestration/result-validator.js"
      provides: "ResultValidator class for .planning/ validation"
      min_lines: 100
      exports: ["ResultValidator"]
    - path: "bin/lib/orchestration/result-validator.test.js"
      provides: "Test suite for validator"
      min_lines: 50
    - path: "bin/lib/orchestration/equivalence-test.js"
      provides: "Cross-CLI equivalence testing"
      min_lines: 100
      exports: ["testEquivalence", "runEquivalenceTests"]
  key_links:
    - from: "bin/lib/orchestration/result-validator.js"
      to: ".planning/"
      via: "fs.promises stat/readdir"
      pattern: "fs.*stat|readdir"
---

<objective>
Implement result validation ensuring .planning/ directory structure is consistent across CLIs for seamless CLI switching.

Purpose: Satisfy AGENT-08 (agent results pass between CLIs), AGENT-11 (agents write to same .planning/ structure), and prevent state corruption when user switches CLIs mid-project.

Output: Validator module that checks directory structure, JSON parseability, and agent output format consistency.
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-agent-translation/04-RESEARCH.md

# Depends on 04-01 for understanding agent structure
@.planning/phases/04-agent-translation/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create result validator with structure checks</name>
  <files>bin/lib/orchestration/result-validator.js</files>
  <action>
Create `bin/lib/orchestration/result-validator.js` implementing ResultValidator class:

1. **Import Node.js built-ins:**
   ```javascript
   const fs = require('fs').promises;
   const path = require('path');
   ```

2. **ResultValidator constructor:**
   - Accept `planningDir` parameter (default: '.planning')
   - Store as `this.planningDir`
   - Define `this.requiredStructure` object:
     ```javascript
     this.requiredStructure = {
       'STATE.md': 'file',
       'ROADMAP.md': 'file',
       'REQUIREMENTS.md': 'file',
       'PROJECT.md': 'file',
       'config.json': 'file',
       'phases/': 'directory',
       'metrics/': 'directory'
     };
     ```

3. **validateStructure() async method:**
   - Iterate over this.requiredStructure entries
   - For each item, check existence with `fs.stat(path.join(planningDir, itemPath))`
   - Verify type matches (file vs directory)
   - Collect errors for missing or mismatched items
   - Return: `{ valid: true/false, errors: [] }`
   - Handle ENOENT error gracefully (item missing)

4. **validateJSON(filePath) async method:**
   - Read file with `fs.readFile(path.join(planningDir, filePath), 'utf8')`
   - Attempt to parse with `JSON.parse(content)`
   - Return: `{ valid: true/false, error: 'message' }` if parsing fails
   - Catch SyntaxError and return descriptive message

5. **validateAgentOutput(phasePath) async method:**
   - Read phase directory with `fs.readdir(path.join(planningDir, phasePath))`
   - Find all PLAN.md files (pattern: `*-PLAN.md`)
   - Find all SUMMARY.md files (pattern: `*-SUMMARY.md`)
   - Check at least one PLAN file exists
   - Return: `{ valid: true/false, errors: [], warnings: [] }`
   - Note: SUMMARY files may not exist during planning (not an error)

6. **Export class:**
   ```javascript
   module.exports = { ResultValidator };
   ```

**Follow research Pattern 3 (result-validator.js lines 307-412).**

**Important:** All validation should be async and use fs.promises to avoid blocking.
  </action>
  <verify>
```bash
node -e "const {ResultValidator} = require('./bin/lib/orchestration/result-validator.js'); const v = new ResultValidator('.planning'); v.validateStructure().then(r => { console.log('Valid:', r.valid); console.log('Errors:', r.errors.length); }).catch(e => console.error('Error:', e.message));"
```

Should output validation result showing whether .planning/ structure is valid.
  </verify>
  <done>
ResultValidator class exists with validateStructure, validateJSON, and validateAgentOutput methods that check .planning/ directory for CLI compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create result validator test suite</name>
  <files>bin/lib/orchestration/result-validator.test.js</files>
  <action>
Create `bin/lib/orchestration/result-validator.test.js` with console-based tests:

1. **Test 1: Structure validation on existing .planning/**
   - Create ResultValidator with '.planning' path
   - Call validateStructure()
   - Verify returns { valid: true/false, errors: [] }
   - Assert errors array is appropriate (empty if .planning/ exists and is correct)

2. **Test 2: Structure validation on missing directory**
   - Create ResultValidator with '/nonexistent' path
   - Call validateStructure()
   - Verify returns { valid: false, errors: [...] } with errors for missing items

3. **Test 3: JSON validation on valid file**
   - Create temp JSON file with valid content
   - Call validateJSON(tempFile)
   - Verify returns { valid: true }

4. **Test 4: JSON validation on invalid file**
   - Create temp file with malformed JSON
   - Call validateJSON(tempFile)
   - Verify returns { valid: false, error: '...' }

5. **Test 5: Agent output validation**
   - If .planning/phases/04-agent-translation/ exists:
     - Call validateAgentOutput('phases/04-agent-translation')
     - Verify returns validation result

**Use console assertions:**
```javascript
console.log('‚úÖ Test 1: Structure validation passed');
console.log('‚ùå Test 2: Expected errors but got none');
```

**Pattern from Phase 3:** See 03-03-SUMMARY.md and 04-02 for test structure.
  </action>
  <verify>
```bash
node bin/lib/orchestration/result-validator.test.js
```

Should output 5 test results (‚úÖ or ‚ùå).
  </verify>
  <done>
Test file exists with 5 tests covering structure validation, JSON validation, and agent output validation. Tests use console output for pass/fail.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration test ‚Äî validate current .planning/ directory</name>
  <files>bin/lib/orchestration/validate-planning-dir.js</files>
  <action>
Create `bin/lib/orchestration/validate-planning-dir.js` as executable script:

1. **Script purpose:** Validate current .planning/ directory structure and report results

2. **Implementation:**
   ```javascript
   #!/usr/bin/env node
   const { ResultValidator } = require('./result-validator');

   async function main() {
     console.log('Validating .planning/ directory structure...\n');
     
     const validator = new ResultValidator('.planning');
     
     // Structure check
     const structureResult = await validator.validateStructure();
     console.log('üìÅ Directory Structure:', structureResult.valid ? '‚úÖ Valid' : '‚ùå Invalid');
     if (structureResult.errors.length > 0) {
       console.log('\nErrors found:');
       structureResult.errors.forEach(e => console.log(`  - ${e}`));
     }
     
     // JSON validation
     console.log('\nüìÑ JSON Files:');
     const jsonFiles = ['config.json'];
     for (const file of jsonFiles) {
       const result = await validator.validateJSON(file);
       console.log(`  ${file}: ${result.valid ? '‚úÖ' : '‚ùå'}`);
       if (!result.valid) console.log(`    ${result.error}`);
     }
     
     // Phase validation
     console.log('\nüì¶ Phase Directories:');
     try {
       const fs = require('fs').promises;
       const phases = await fs.readdir('.planning/phases');
       for (const phase of phases) {
         if (phase.startsWith('.')) continue;
         const result = await validator.validateAgentOutput(`phases/${phase}`);
         console.log(`  ${phase}: ${result.valid ? '‚úÖ' : '‚ùå'}`);
         if (result.errors.length > 0) {
           result.errors.forEach(e => console.log(`    - ${e}`));
         }
       }
     } catch (err) {
       console.log('  No phases directory or read error');
     }
     
     console.log('\n‚úÖ Validation complete');
   }

   main().catch(err => {
     console.error('‚ùå Validation failed:', err.message);
     process.exit(1);
   });
   ```

3. **Make executable:**
   ```bash
   chmod +x bin/lib/orchestration/validate-planning-dir.js
   ```

**Purpose:** Provide user-facing tool to verify .planning/ structure is CLI-compatible before switching CLIs.
  </action>
  <verify>
```bash
node bin/lib/orchestration/validate-planning-dir.js
```

Should output validation report for current .planning/ directory.
  </verify>
  <done>
validate-planning-dir.js script exists, validates current .planning/ directory, and outputs structured report with errors/warnings.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create equivalence test for cross-CLI agent invocation</name>
  <files>bin/lib/orchestration/equivalence-test.js</files>
  <action>
Create `bin/lib/orchestration/equivalence-test.js` to verify agents produce equivalent outputs across CLIs:

1. **Test purpose:** Verify AGENT-04 requirement (same inputs ‚Üí same outputs across CLIs)

2. **Import dependencies:**
   ```javascript
   const { invokeAgent } = require('./agent-invoker');
   const { AgentRegistry } = require('./agent-registry');
   ```

3. **testEquivalence(agentName, testPrompt, clis = ['claude', 'copilot', 'codex']) async function:**
   
   **Step 1: Invoke agent on all CLIs**
   - For each CLI in clis array:
     - Mock CLI detection (temporarily override detectCLI to return specific CLI)
     - Call invokeAgent(agentName, testPrompt)
     - Store result in results[cli] object
   
   **Step 2: Compare results**
   - Extract result content from each CLI response
   - Compare outputs for equivalence:
     - Exact match: results are identical strings
     - Semantic match: results differ in whitespace/formatting but content equivalent
     - Structural match: results are both objects with same keys/structure
   
   **Step 3: Return comparison result**
   ```javascript
   return {
     equivalent: true/false,
     results: {
       claude: { success: true, result: '...', duration: 123 },
       copilot: { success: true, result: '...', duration: 120 },
       codex: { success: true, result: '...', duration: 125 }
     },
     differences: [] // Array of difference descriptions if not equivalent
   };
   ```

4. **runEquivalenceTests() async function:**
   - Test suite for common scenarios:
     - Test 1: gsd-executor with simple prompt
     - Test 2: gsd-planner with phase description
     - Test 3: gsd-verifier with verification criteria
   - For each test:
     - Call testEquivalence()
     - Log result (‚úÖ equivalent or ‚ùå differences found)
   - Return summary: `{ total: 3, passed: N, failed: M }`

5. **Export functions:**
   ```javascript
   module.exports = { testEquivalence, runEquivalenceTests };
   ```

**Important:** This test uses mock results from adapters (since actual CLI invocation commands are TODO). When CLI SDKs stabilize, this test will verify actual cross-CLI equivalence.

**Pattern:** Similar to result-validator.test.js (04-04 Task 2), use console-based assertions for pass/fail.
  </action>
  <verify>
```bash
# Test equivalence function exists
node -e "const {testEquivalence, runEquivalenceTests} = require('./bin/lib/orchestration/equivalence-test.js'); console.log('testEquivalence:', typeof testEquivalence); console.log('runEquivalenceTests:', typeof runEquivalenceTests);"

# Run equivalence test suite
node -e "const {runEquivalenceTests} = require('./bin/lib/orchestration/equivalence-test.js'); runEquivalenceTests().then(summary => { console.log('Equivalence tests:', summary); }).catch(e => console.error('Error:', e.message));"
```

Should output function types and test summary with passed/failed counts.
  </verify>
  <done>
equivalence-test.js exists with testEquivalence() and runEquivalenceTests() functions that verify agent outputs are equivalent across CLIs, satisfying AGENT-04 requirement.
  </done>
</task>

</tasks>

<verification>
After completion:

1. **Validator instantiation:**
   ```bash
   node -e "const {ResultValidator} = require('./bin/lib/orchestration/result-validator.js'); const v = new ResultValidator(); console.log('Validator:', typeof v.validateStructure);"
   ```

2. **Test suite:**
   ```bash
   node bin/lib/orchestration/result-validator.test.js
   ```

3. **Integration test:**
   ```bash
   node bin/lib/orchestration/validate-planning-dir.js
   ```

4. **Structure check on current project:**
   Should report .planning/ as valid (or list specific errors if structure incomplete).
</verification>

<success_criteria>
1. ResultValidator validates required .planning/ structure (7 items)
2. validateJSON() catches malformed JSON and returns descriptive errors
3. validateAgentOutput() checks phase directories for PLAN/SUMMARY files
4. All methods return structured results ({ valid, errors, warnings })
5. Test suite covers structure, JSON, and agent output validation
6. validate-planning-dir.js script provides user-facing validation tool
7. All code uses async fs.promises (no blocking I/O)
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-translation/04-04-SUMMARY.md`
</output>
