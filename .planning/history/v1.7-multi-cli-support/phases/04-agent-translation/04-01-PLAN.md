---
phase: 04-agent-translation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/orchestration/agent-registry.js
  - bin/lib/orchestration/agent-invoker.js
  - bin/lib/adapters/claude.js
  - bin/lib/adapters/copilot.js
  - bin/lib/adapters/codex.js
autonomous: true

must_haves:
  truths:
    - "Agent registry loads all 11 GSD agents at startup"
    - "Agent invoker abstracts CLI-specific invocation"
    - "User invokes agent and orchestration layer handles CLI differences transparently"
    - "Agent invocation fails gracefully when agent unsupported on current CLI"
  artifacts:
    - path: "bin/lib/orchestration/agent-registry.js"
      provides: "Agent registry with Map-based storage"
      min_lines: 80
      exports: ["AgentRegistry"]
    - path: "bin/lib/orchestration/agent-invoker.js"
      provides: "CLI-agnostic agent invocation"
      min_lines: 40
      exports: ["invokeAgent"]
    - path: "bin/lib/adapters/claude.js"
      provides: "Claude adapter with invokeAgent method"
      exports: ["invokeAgent"]
    - path: "bin/lib/adapters/copilot.js"
      provides: "Copilot adapter with invokeAgent method"
      exports: ["invokeAgent"]
    - path: "bin/lib/adapters/codex.js"
      provides: "Codex adapter with invokeAgent method"
      exports: ["invokeAgent"]
  key_links:
    - from: "bin/lib/orchestration/agent-invoker.js"
      to: "bin/lib/orchestration/agent-registry.js"
      via: "new AgentRegistry()"
      pattern: "AgentRegistry"
    - from: "bin/lib/orchestration/agent-invoker.js"
      to: "bin/lib/cli-detection/detect.js"
      via: "detectCLI() import"
      pattern: "detectCLI"
    - from: "bin/lib/orchestration/agent-invoker.js"
      to: "bin/lib/adapters/*"
      via: "require() based on CLI"
      pattern: "require.*adapters"
---

<objective>
Build agent orchestration core that enables transparent, CLI-agnostic agent invocation for all 11 GSD specialized agents.

Purpose: Abstract CLI differences behind unified agent invocation API, enabling user to invoke agents without knowing implementation varies between Claude Code (native), GitHub Copilot CLI (custom agents), and Codex CLI (skills).

Output: Agent registry and invoker modules that map agent names to CLI-specific implementations and handle invocation transparently.
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-agent-translation/04-RESEARCH.md

# Phase 2 established adapter pattern
@.planning/phases/02-adapter-implementation/02-01-SUMMARY.md
@.planning/phases/02-adapter-implementation/02-02-SUMMARY.md

# Phase 3 established CLI detection
@.planning/phases/03-command-system/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent registry with 11 GSD agents</name>
  <files>bin/lib/orchestration/agent-registry.js</files>
  <action>
Create `bin/lib/orchestration/agent-registry.js` implementing registry pattern from research:

1. **AgentRegistry class with Map-based storage:**
   - Constructor initializes `this.agents` Map and `this.capabilities` Map
   - Call `_loadAgents()` in constructor to populate on instantiation

2. **_loadAgents() method loads all 11 agents:**
   - Agent names: gsd-executor, gsd-planner, gsd-verifier, gsd-debugger, gsd-phase-researcher, gsd-plan-checker, gsd-codebase-mapper, gsd-project-researcher, gsd-research-synthesizer, gsd-roadmapper, gsd-integration-checker
   - For each agent, store in Map with:
     - `name`: agent name string
     - `source`: path to agent markdown file (use path.join with agents/ directory)
     - `claude`, `copilot`, `codex`: Objects with type and path for each CLI
   - Set default capability to 'full' for all agents on all CLIs using setCapability()

3. **getAgent(agentName, cli) method:**
   - Return agent metadata with CLI-specific implementation
   - Include capability level from capabilities Map
   - Return null if agent doesn't exist

4. **setCapability(agentName, cli, level) method:**
   - Store capability as `${agentName}:${cli}` key
   - Levels: 'full', 'partial', 'unsupported'

5. **getCapabilityMatrix() method:**
   - Return array of objects with agent name and capability per CLI
   - Format: `{ agent: 'name', claude: 'full', copilot: 'full', codex: 'full' }`

**Use Node.js built-ins only:** require('path'), require('fs') for potential file validation (don't use external dependencies).

**Follow research Pattern 1 (agent-registry.js example lines 67-153).**
  </action>
  <verify>
```bash
node -e "const {AgentRegistry} = require('./bin/lib/orchestration/agent-registry.js'); const r = new AgentRegistry(); console.log('Agents loaded:', r.agents.size); console.log('Executor:', r.getAgent('gsd-executor', 'claude')); console.log('Matrix:', r.getCapabilityMatrix().length);"
```

Should output:
- Agents loaded: 11
- Executor object with name, source, claude/copilot/codex implementations
- Matrix length: 11
  </verify>
  <done>
AgentRegistry class exists, loads 11 agents on instantiation, provides getAgent() and getCapabilityMatrix() methods that return expected data structures.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create agent invoker with CLI abstraction</name>
  <files>bin/lib/orchestration/agent-invoker.js</files>
  <action>
Create `bin/lib/orchestration/agent-invoker.js` implementing invokeAgent function:

1. **Import dependencies:**
   - AgentRegistry from ./agent-registry.js
   - detectCLI from ../detect.js (Phase 3)
   - Use createRequire if detect.js is CommonJS (see Phase 3 03-02-SUMMARY.md)

2. **invokeAgent(agentName, prompt, options = {}) async function:**
   - Detect current CLI using detectCLI()
   - Instantiate AgentRegistry
   - Get agent metadata for current CLI via registry.getAgent(agentName, cli)
   - Throw error if agent not found: "Agent not found: {agentName}"
   - Check agent.capability — if 'unsupported', throw error with helpful message explaining agent not supported on current CLI and suggesting capability matrix check

3. **CLI-specific adapter loading:**
   - Load adapter based on CLI: `require(\`../adapters/\${cli}\`)`
   - Expect adapter to export invokeAgent(agent, prompt, options) method
   - Call adapter.invokeAgent(agent, prompt, options) and await result
   - If adapter doesn't have invokeAgent method yet, return placeholder: `{ success: true, message: 'Agent invocation not yet implemented in adapter', agent: agentName, cli }` (will be implemented in Task 3)

4. **Return structured result:**
   - Format: `{ success: true/false, result: adapter_result, performance: { cli } }`
   - Wrap in try/catch, rethrow errors with context about which agent and CLI

**Note:** Performance tracking will be added in 04-02. For now, return basic performance object with just CLI name.

**Follow research "Agent Invocation" example (lines 549-601).**
  </action>
  <verify>
```bash
node -e "const {invokeAgent} = require('./bin/lib/orchestration/agent-invoker.js'); invokeAgent('gsd-executor', 'test prompt').then(r => console.log('Result:', r)).catch(e => console.log('Error expected (adapters not wired):', e.message));"
```

Should output result object with success, result, performance fields, or expected error if adapters not yet wired for agent invocation.
  </verify>
  <done>
invokeAgent function exists, detects CLI, loads agent from registry, attempts adapter invocation with graceful fallback, returns structured result.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement adapter.invokeAgent() methods</name>
  <files>bin/lib/adapters/claude.js, bin/lib/adapters/copilot.js, bin/lib/adapters/codex.js</files>
  <action>
Implement invokeAgent() method in all three CLI adapters to enable agent invocation:

1. **bin/lib/adapters/claude.js:**
   - Add `async invokeAgent(agent, prompt, options = {})` method
   - Claude Code supports native .agent.md format:
     - Agent files in .github/skills/get-shit-done/agents/*.md
     - Invoke via CLI: `claude-code agent invoke {agentName} --prompt "{prompt}"`
     - For now, return mock result: `{ success: true, cli: 'claude', agent: agent.name, result: 'Mock agent execution (CLI command pending)' }`
     - TODO: Add actual CLI invocation once Claude Code SDK available

2. **bin/lib/adapters/copilot.js:**
   - Add `async invokeAgent(agent, prompt, options = {})` method
   - GitHub Copilot CLI uses custom agent definitions:
     - Agent files in .github/agents/*.md
     - Invoke via CLI: `gh copilot agent run {agentName} --prompt "{prompt}"`
     - For now, return mock result: `{ success: true, cli: 'copilot', agent: agent.name, result: 'Mock agent execution (CLI command pending)' }`
     - TODO: Add actual CLI invocation once GitHub CLI agent extension available

3. **bin/lib/adapters/codex.js:**
   - Add `async invokeAgent(agent, prompt, options = {})` method
   - Codex CLI uses skill-based approach:
     - Agent files in .codex/skills/*.md
     - Invoke via CLI: `codex skill run {agentName} --prompt "{prompt}"`
     - For now, return mock result: `{ success: true, cli: 'codex', agent: agent.name, result: 'Mock agent execution (CLI command pending)' }`
     - TODO: Add actual CLI invocation once Codex CLI skill API available

**Note:** This task creates the adapter interface. Actual CLI invocation commands will be implemented when CLI SDKs stabilize. Mock results enable testing the orchestration layer (registry → invoker → adapter flow) without blocking on CLI availability.

**Expected adapter signature:**
```javascript
async invokeAgent(agent, prompt, options = {}) {
  return {
    success: true,
    cli: 'claude', // or 'copilot', 'codex'
    agent: agent.name,
    result: '...',  // Agent execution result
    duration: 123   // Optional: execution time in ms
  };
}
```
  </action>
  <verify>
```bash
# Test each adapter has invokeAgent method
node -e "const claude = require('./bin/lib/adapters/claude.js'); console.log('claude.invokeAgent:', typeof claude.invokeAgent);"
node -e "const copilot = require('./bin/lib/adapters/copilot.js'); console.log('copilot.invokeAgent:', typeof copilot.invokeAgent);"
node -e "const codex = require('./bin/lib/adapters/codex.js'); console.log('codex.invokeAgent:', typeof codex.invokeAgent);"

# Test invocation returns expected structure
node -e "const claude = require('./bin/lib/adapters/claude.js'); claude.invokeAgent({name: 'gsd-executor'}, 'test').then(r => console.log('Result:', r));"
```

Should output "function" for all three adapters and structured result object with success, cli, agent, result fields.
  </verify>
  <done>
All three adapters (claude.js, copilot.js, codex.js) export async invokeAgent() methods that return structured results, enabling agent orchestration layer to invoke agents across CLIs.
  </done>
</task>

</tasks>

<verification>
After completion:

1. **Registry verification:**
   ```bash
   node -e "const {AgentRegistry} = require('./bin/lib/orchestration/agent-registry.js'); const r = new AgentRegistry(); console.log('Loaded agents:', Array.from(r.agents.keys())); const matrix = r.getCapabilityMatrix(); console.log('Full support count:', matrix.filter(m => m.claude === 'full').length);"
   ```

2. **Invoker verification:**
   ```bash
   node -e "const {invokeAgent} = require('./bin/lib/orchestration/agent-invoker.js'); console.log('invokeAgent function:', typeof invokeAgent);"
   ```

3. **Integration check:**
   Test that agent-invoker successfully imports and uses agent-registry.
</verification>

<success_criteria>
1. AgentRegistry class loads all 11 GSD agents with CLI-specific metadata
2. getAgent() returns agent with implementation details for specified CLI
3. getCapabilityMatrix() returns array of 11 agents with capability levels
4. invokeAgent() function detects CLI, retrieves agent from registry, and attempts invocation
5. Unsupported agents throw clear error messages guiding user to capability matrix
6. All code uses Node.js built-ins only (no external dependencies)
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-translation/04-01-SUMMARY.md`
</output>
