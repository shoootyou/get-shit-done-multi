---
phase: 03-command-system
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - bin/lib/command-system/executor.js
  - bin/lib/command-system/error-handler.js
  - bin/lib/command-system/help-generator.js
  - bin/gsd-cli.js
autonomous: true

must_haves:
  truths:
    - "User can invoke /gsd:help and see all 24 commands grouped by category"
    - "User can invoke /gsd:help [command] and see detailed help for that command"
    - "Commands execute with CLI detection and adapter integration"
    - "Errors provide actionable suggestions and exit with non-zero code"
    - "Commands work across Claude Code, GitHub Copilot CLI, and Codex CLI"
  artifacts:
    - path: "bin/lib/command-system/executor.js"
      provides: "Command execution with CLI detection and error handling"
      exports: ["executeCommand"]
      min_lines: 80
    - path: "bin/lib/command-system/error-handler.js"
      provides: "CommandError class and formatting functions"
      exports: ["CommandError", "formatError", "degradeGracefully"]
      min_lines: 60
    - path: "bin/lib/command-system/help-generator.js"
      provides: "Auto-generated help text from command metadata"
      exports: ["generateHelp"]
      min_lines: 100
    - path: "bin/gsd-cli.js"
      provides: "CLI entry point that loads and executes commands"
      min_lines: 40
  key_links:
    - from: "bin/gsd-cli.js"
      to: "bin/lib/command-system/loader.js"
      via: "loadCommands() call"
      pattern: "loadCommands\\("
    - from: "bin/gsd-cli.js"
      to: "bin/lib/command-system/executor.js"
      via: "executeCommand() call"
      pattern: "executeCommand\\("
    - from: "bin/lib/command-system/executor.js"
      to: "bin/lib/cli-detector.js"
      via: "detectCLI() import from Phase 1"
      pattern: "detectCLI"
    - from: "bin/lib/command-system/help-generator.js"
      to: "bin/lib/command-system/registry.js"
      via: "registry.list() and registry.get() calls"
      pattern: "registry\\.(list|get)\\("
---

<objective>
Integrate command system with CLI detection, implement executor with error handling, create auto-generated help system, and build CLI entry point.

Purpose: Enable users to invoke GSD commands from any CLI with consistent behavior, helpful error messages, and auto-generated documentation.

Output: Fully functional command system that works across all three CLIs with help generation and graceful error handling.
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-command-system/03-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/02-adapter-implementation/02-01-SUMMARY.md
@bin/lib/cli-detector.js
@commands/gsd/help.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Complete executor and error handler with CLI integration</name>
  <files>bin/lib/command-system/executor.js, bin/lib/command-system/error-handler.js</files>
  <action>
    Update `bin/lib/command-system/executor.js` (started in 03-01) with full execution logic:
    
    Components:
    1. Import detectCLI from '../cli-detector.js' (Phase 1)
    2. Import registry from './registry.js'
    3. Import formatError, degradeGracefully, CommandError from './error-handler.js'
    
    4. executeCommand(commandName, args) - Main function
       - Call detectCLI() to identify current CLI
       - Get command from registry: registry.get(commandName)
       - If command not found: throw CommandError with suggestions
       - Check command metadata.requires for CLI-specific features
       - If features missing: log degradeGracefully() message but continue
       - Try executing command.handler(args)
       - Catch errors: log formatError() and process.exit(1)
       - On success: return { success: true, result }
    
    Complete `bin/lib/command-system/error-handler.js`:
    
    1. CommandError class extends Error
       - constructor(message, code, suggestions = [])
       - Properties: message, code, suggestions
    
    2. formatError(error, commandName)
       - If CommandError: format with ❌ emoji, error message, suggestions list
       - Otherwise: generic error format with /gsd:help suggestion
       - Return formatted string
    
    3. degradeGracefully(feature, cli)
       - Format with ⚠️ emoji
       - Explain feature not available in CLI
       - Indicate command continues with limited functionality
       - Return formatted string
    
    Reference research Pattern 4 and Pattern 5. Use Phase 1's detectCLI (returns 'claude-code', 'copilot-cli', or 'codex-cli').
  </action>
  <verify>
    ```bash
    # Test executor with mock command
    node -e "
    import('./bin/lib/command-system/loader.js').then(m => m.loadCommands('commands/gsd')).then(() => {
      import('./bin/lib/command-system/executor.js').then(exec => {
        exec.executeCommand('gsd:help', []).then(r => console.log('Success:', r.success));
      });
    });
    "
    
    # Test error formatting
    node -e "
    import('./bin/lib/command-system/error-handler.js').then(m => {
      const err = new m.CommandError('Test error', 'TEST', ['Try this']);
      console.log(m.formatError(err, 'test-command'));
    });
    "
    ```
    Should output: Success and formatted error with suggestions
  </verify>
  <done>
    - executor.js integrates detectCLI from Phase 1
    - Retrieves commands from registry
    - Handles missing commands with helpful errors
    - Checks CLI feature support and degrades gracefully
    - Catches exceptions and formats errors
    - Exits with non-zero code on failure
    - error-handler.js has CommandError class
    - formatError() produces user-friendly messages
    - degradeGracefully() explains feature unavailability
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auto-generated help system</name>
  <files>bin/lib/command-system/help-generator.js</files>
  <action>
    Create `bin/lib/command-system/help-generator.js` implementing Pattern 6 from research.
    
    Components:
    1. generateHelp(commandName = null)
       - If commandName provided: return formatCommandHelp(commandName, metadata)
       - Otherwise: return formatAllCommandsHelp()
    
    2. formatCommandHelp(name, metadata)
       - Title: /gsd:{name}
       - Description from metadata.description
       - Arguments from metadata.arguments or metadata['argument-hint']
       - Examples from metadata.examples (multi-line)
       - Format cleanly with spacing
    
    3. formatAllCommandsHelp()
       - Get all commands: registry.list()
       - Group commands by category using groupCommands()
       - Format as: # GSD Commands, ## Category, command list
       - Each command: /gsd:{name} (padded to 25 chars) {description}
       - Footer: "For detailed help: /gsd:help [command]"
    
    4. groupCommands(commands)
       - Return object with categories: Project Setup, Phase Management, Milestone Management, Utilities
       - Group by keywords: project/map → Project Setup, phase → Phase Management, milestone → Milestone Management, else → Utilities
    
    Import registry from './registry.js'. Reference research Pattern 6 for exact format.
  </action>
  <verify>
    ```bash
    # Test help generation
    node -e "
    import('./bin/lib/command-system/loader.js').then(m => m.loadCommands('commands/gsd')).then(() => {
      import('./bin/lib/command-system/help-generator.js').then(h => {
        console.log(h.generateHelp());
        console.log('---');
        console.log(h.generateHelp('gsd:help'));
      });
    });
    "
    ```
    Should output: Grouped command list and detailed help for gsd:help
  </verify>
  <done>
    - help-generator.js exists with generateHelp()
    - Generates full command list grouped by category
    - Generates detailed help for individual commands
    - Reads metadata from registry
    - Formats consistently with spacing and alignment
    - All 24 commands appear in help output
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CLI entry point and wire system together</name>
  <files>bin/gsd-cli.js</files>
  <action>
    Create `bin/gsd-cli.js` as the main entry point for command execution.
    
    Structure:
    1. Import loadCommands from './lib/command-system/loader.js'
    2. Import executeCommand from './lib/command-system/executor.js'
    3. Import parseArgs from 'node:util'
    4. Import join, fileURLToPath from 'node:path' and 'node:url'
    
    5. Main execution flow:
       - Get __dirname using fileURLToPath(import.meta.url)
       - Construct commandsDir: join(__dirname, '..', 'commands', 'gsd')
       - Load commands: await loadCommands(commandsDir)
       - Parse CLI args: parseArgs({ args: process.argv.slice(2), allowPositionals: true, strict: false })
       - Extract command name and args from positionals
       - Execute: await executeCommand(commandName, commandArgs)
    
    6. Add top-level await (ES Modules)
    7. Add shebang: #!/usr/bin/env node
    8. Handle no command provided: show error and suggest /gsd:help
    
    Keep minimal - this is glue code. Reference research "Command System Initialization" example.
  </action>
  <verify>
    ```bash
    # Make executable
    chmod +x bin/gsd-cli.js
    
    # Test help command
    node bin/gsd-cli.js gsd:help
    
    # Test non-existent command
    node bin/gsd-cli.js nonexistent || echo "Exited with error (expected)"
    ```
    Should output: Help listing for first test, error message for second test
  </verify>
  <done>
    - gsd-cli.js exists as entry point
    - Has shebang for direct execution
    - Loads commands on startup
    - Parses command-line arguments
    - Executes commands via executeCommand()
    - Handles missing command gracefully
    - Works with Node.js ES Modules
  </done>
</task>

</tasks>

<verification>
End-to-end command system test:
```bash
# Test full command execution
node bin/gsd-cli.js gsd:help
node bin/gsd-cli.js gsd:help gsd:execute-phase

# Test CLI detection integration
node -e "
import('./bin/lib/cli-detector.js').then(m => m.detectCLI()).then(cli => {
  console.log('Detected CLI:', cli);
  import('./bin/lib/command-system/executor.js').then(e => {
    return e.executeCommand('gsd:help', []);
  }).then(() => console.log('Command executed successfully'));
});
"

# Test error handling
node bin/gsd-cli.js nonexistent-command 2>&1 | grep "Command not found"

# Verify all commands loadable
node -e "
import('./bin/lib/command-system/loader.js').then(m => {
  return m.loadCommands('commands/gsd');
}).then(count => {
  console.log('Loaded commands:', count);
  if (count !== 24) throw new Error('Expected 24 commands');
});
"
```

Expected: Help displays correctly, CLI detection works, errors formatted, all 24 commands load.
</verification>

<success_criteria>
1. `/gsd:help` displays all 24 commands grouped by category (Project Setup, Phase Management, Milestone Management, Utilities)
2. `/gsd:help [command]` shows detailed help with description, arguments, and examples
3. Commands execute with CLI detection (works in Claude, Copilot, Codex)
4. Invalid commands produce helpful error messages with suggestions
5. Commands requiring unsupported features degrade gracefully with warning messages
6. CLI entry point (gsd-cli.js) loads commands and routes to executor
7. All error paths exit with non-zero code for script integration
</success_criteria>

<output>
After completion, create `.planning/phases/03-command-system/03-02-SUMMARY.md` following the template structure with:
- Frontmatter (phase, plan, subsystem, dependency graph, tech tracking)
- Summary of CLI integration and help system
- Key decisions made during implementation
- Performance metrics (duration, completion timestamp)
</output>
