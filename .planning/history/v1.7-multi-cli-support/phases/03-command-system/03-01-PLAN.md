---
phase: 03-command-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/command-system/registry.js
  - bin/lib/command-system/parser.js
  - bin/lib/command-system/loader.js
  - bin/lib/command-system/executor.js
  - bin/lib/command-system/error-handler.js
autonomous: true

must_haves:
  truths:
    - "Command registry can store and retrieve command definitions"
    - "Arguments parse correctly with util.parseArgs()"
    - "Commands load from filesystem automatically"
    - "Errors produce user-friendly messages with suggestions"
  artifacts:
    - path: "bin/lib/command-system/registry.js"
      provides: "Command registry with Map-based storage"
      exports: ["CommandRegistry", "registry"]
      min_lines: 50
    - path: "bin/lib/command-system/parser.js"
      provides: "Argument parsing with util.parseArgs()"
      exports: ["parseCommandArgs"]
      min_lines: 30
    - path: "bin/lib/command-system/loader.js"
      provides: "Dynamic command loading from .md files"
      exports: ["loadCommands", "parseCommandFile"]
      min_lines: 60
    - path: "bin/lib/command-system/executor.js"
      provides: "Command execution with error handling"
      exports: ["executeCommand"]
      min_lines: 70
    - path: "bin/lib/command-system/error-handler.js"
      provides: "Error formatting and graceful degradation"
      exports: ["CommandError", "formatError", "degradeGracefully"]
      min_lines: 50
  key_links:
    - from: "bin/lib/command-system/loader.js"
      to: "bin/lib/command-system/registry.js"
      via: "registry.register() calls"
      pattern: "registry\\.register\\("
    - from: "bin/lib/command-system/executor.js"
      to: "bin/lib/command-system/registry.js"
      via: "registry.get() calls"
      pattern: "registry\\.get\\("
    - from: "bin/lib/command-system/executor.js"
      to: "bin/lib/command-system/error-handler.js"
      via: "formatError() calls"
      pattern: "formatError\\("
---

<objective>
Create the foundational command system infrastructure using Command Registry Pattern with util.parseArgs() for argument handling.

Purpose: Provide the core components that enable dynamic command loading, execution, and error handling across all three CLIs (Claude Code, GitHub Copilot CLI, Codex CLI).

Output: Five core modules that work together to provide a unified command interface.
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-command-system/03-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/02-adapter-implementation/02-01-SUMMARY.md
@.planning/phases/02-adapter-implementation/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create command registry with Map-based storage</name>
  <files>bin/lib/command-system/registry.js</files>
  <action>
    Create `bin/lib/command-system/registry.js` implementing the Command Registry Pattern from research.
    
    Components:
    - CommandRegistry class with Map-based storage
    - register(name, metadata, handler) - Add command to registry
    - get(name) - Retrieve command by name (returns {metadata, handler} or null)
    - list() - Return array of all command names
    - has(name) - Check if command exists (returns boolean)
    - Export singleton instance as `registry`
    
    Follow ES Modules pattern (import/export), add JSDoc comments for all methods.
    
    Reference research Pattern 1 for exact API structure. Keep code minimal and focused on Map operations only.
  </action>
  <verify>
    ```bash
    node -e "import('./bin/lib/command-system/registry.js').then(m => { console.log('exports:', Object.keys(m)); console.log('has registry:', !!m.registry); })"
    ```
    Should output: exports include 'CommandRegistry' and 'registry'
  </verify>
  <done>
    - registry.js exists with CommandRegistry class
    - Exports both class and singleton instance
    - Has register(), get(), list(), has() methods
    - All methods have JSDoc documentation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create argument parser using util.parseArgs()</name>
  <files>bin/lib/command-system/parser.js</files>
  <action>
    Create `bin/lib/command-system/parser.js` wrapping Node.js util.parseArgs().
    
    Function: parseCommandArgs(args, options)
    - Import parseArgs from 'node:util'
    - Call parseArgs with { args, options, strict: false, allowPositionals: true }
    - Return { values, positionals, error: null } on success
    - Catch exceptions and return { values: {}, positionals: [], error: errorMessage }
    
    Add JSDoc with parameter types and return value documentation.
    
    Reference research Pattern 2 for exact implementation. DO NOT add custom validation logic - keep it a thin wrapper around util.parseArgs().
  </action>
  <verify>
    ```bash
    node -e "import('./bin/lib/command-system/parser.js').then(m => { const result = m.parseCommandArgs(['3', '--verbose'], { verbose: { type: 'boolean' } }); console.log('parsed:', JSON.stringify(result)); })"
    ```
    Should output: parsed values include verbose: true, positionals: ['3']
  </verify>
  <done>
    - parser.js exists with parseCommandArgs function
    - Uses util.parseArgs() from Node.js
    - Returns consistent format: { values, positionals, error }
    - Handles parsing errors gracefully
    - JSDoc documentation complete
  </done>
</task>

<task type="auto">
  <name>Task 3: Create command loader for filesystem-based command discovery</name>
  <files>bin/lib/command-system/loader.js</files>
  <action>
    Create `bin/lib/command-system/loader.js` to load commands from `commands/gsd/*.md` files.
    
    Components:
    1. loadCommands(commandsDir) - Async function
       - Use fs/promises.readdir() to list .md files
       - For each file: read content, parse frontmatter+prompt, register command
       - Return count of loaded commands
    
    2. parseCommandFile(content) - Sync function
       - Match pattern: ^---\n([\s\S]*?)\n---\n([\s\S]*)$
       - Parse frontmatter (YAML-like key: value pairs)
       - Return { metadata: {}, prompt: "" }
       - Handle files without frontmatter (return { metadata: {}, prompt: content })
    
    3. Import registry from './registry.js'
    4. Register commands with: registry.register(name, metadata, async handler)
    5. Handler returns { prompt, args, metadata } for now (execution in Task 4)
    
    Reference research Pattern 3. Use fs/promises not sync versions. Extract command name from metadata.name or filename.
  </action>
  <verify>
    ```bash
    node -e "import('./bin/lib/command-system/loader.js').then(m => m.loadCommands('commands/gsd')).then(count => console.log('loaded:', count))"
    ```
    Should output: loaded: 24 (matching 24 existing command files)
  </verify>
  <done>
    - loader.js exists with loadCommands() and parseCommandFile()
    - Loads all 24 commands from commands/gsd/
    - Parses frontmatter correctly (YAML-like format)
    - Registers commands in registry
    - Returns command count
    - Uses async/await with fs/promises
  </done>
</task>

</tasks>

<verification>
Test command system integration:
```bash
# Load commands and verify registry
node -e "
import('./bin/lib/command-system/loader.js')
  .then(m => m.loadCommands('commands/gsd'))
  .then(count => console.log('Commands loaded:', count));

import('./bin/lib/command-system/registry.js')
  .then(m => {
    console.log('Registry has help:', m.registry.has('gsd:help'));
    console.log('Registry has execute-phase:', m.registry.has('gsd:execute-phase'));
  });
"

# Test argument parsing
node -e "
import('./bin/lib/command-system/parser.js')
  .then(m => {
    const result = m.parseCommandArgs(
      ['3', '--verbose', '--skip-verification'],
      { verbose: { type: 'boolean' }, 'skip-verification': { type: 'boolean' } }
    );
    console.log('Parse result:', JSON.stringify(result, null, 2));
  });
"
```

Expected: All commands load, registry operations work, argument parsing succeeds.
</verification>

<success_criteria>
1. Command registry stores and retrieves commands correctly using Map-based storage
2. Argument parser handles flags (--verbose), positionals (phase numbers), and returns consistent format
3. Loader discovers all 24 commands from commands/gsd/ directory
4. Error handler formats errors with user-friendly messages and suggestions
5. All modules use ES Modules (import/export) and have JSDoc documentation
6. Zero npm dependencies added (Node.js built-ins only)
</success_criteria>

<output>
After completion, create `.planning/phases/03-command-system/03-01-SUMMARY.md` following the template structure with:
- Frontmatter (phase, plan, subsystem, dependency graph, tech tracking)
- Summary of command system infrastructure created
- Key decisions made during implementation
- Performance metrics (duration, completion timestamp)
</output>
