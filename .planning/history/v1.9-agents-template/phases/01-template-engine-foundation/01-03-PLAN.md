---
phase: 01-template-engine-foundation
plan: 03
type: execute
wave: 3
depends_on: [01-01, 01-02]
files_modified:
  - bin/lib/template-system/generator.js
  - bin/lib/template-system/index.js
autonomous: true

must_haves:
  truths:
    - "Generator orchestrates spec → context → render → validate pipeline"
    - "End-to-end test generates agent from spec successfully"
    - "Invalid specs caught at appropriate pipeline stage"
    - "All modules work together seamlessly"
  artifacts:
    - path: "bin/lib/template-system/generator.js"
      provides: "Pipeline orchestration"
      exports: ["generateAgent", "generateFromSpec"]
      min_lines: 80
    - path: "bin/lib/template-system/index.js"
      provides: "Public API surface"
      exports: ["generateAgent", "parseSpec", "buildContext", "render", "validate"]
  key_links:
    - from: "bin/lib/template-system/generator.js"
      to: "spec-parser, context-builder, engine"
      via: "require and function composition"
      pattern: "require\\('\\.\\/spec-parser'\\)"
---

<objective>
Create generator orchestrator that wires together spec-parser, context-builder, and engine modules into a complete template generation pipeline.

Purpose: Final integration that enables spec → agent transformation. This completes Phase 1's template infrastructure foundation.

Output: Working generator with comprehensive integration tests proving end-to-end functionality.
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md

# Completed work
@.planning/phases/01-template-engine-foundation/01-01-SUMMARY.md
@.planning/phases/01-template-engine-foundation/01-02-SUMMARY.md

# Existing modules (from Plan 01 & 02)
@bin/lib/template-system/spec-parser.js
@bin/lib/template-system/context-builder.js
@bin/lib/template-system/engine.js

# Existing codebase
@bin/install.js
@bin/lib/adapters/claude.js
@bin/lib/adapters/copilot.js
</context>

<tasks>

<task type="auto">
  <name>Create generator orchestrator module</name>
  <files>bin/lib/template-system/generator.js</files>
  <action>
Implement generator.js that orchestrates the complete template generation pipeline:

**Module purpose:**
Coordinate spec-parser, context-builder, and engine to transform spec files into platform-specific agent files.

**Key functionality:**

1. **generateAgent(specPath, platform, options)** - Main export
   - Parameters:
     - `specPath`: Path to spec file
     - `platform`: 'claude' | 'copilot' | 'codex'
     - `options`: { outputPath, validateOnly, dryRun, ...contextOptions }
   - Returns: { success: boolean, output: string, errors: [] }
   - Pipeline: Parse → Build Context → Render → Validate → Return

2. **generateFromSpec(specObject, platform, options)** - Alternative API
   - For testing or when spec already parsed
   - Parameters:
     - `specObject`: {frontmatter, body} from parseSpec
     - `platform`: 'claude' | 'copilot' | 'codex'
     - `options`: Same as generateAgent
   - Returns: Same as generateAgent

3. **Pipeline implementation:**
```javascript
const {parseSpec} = require('./spec-parser');
const {buildContext} = require('./context-builder');
const {render, validate} = require('./engine');

function generateAgent(specPath, platform, options = {}) {
  try {
    // Step 1: Parse spec
    const spec = parseSpec(specPath);
    
    // Step 2: Build context
    const context = buildContext(platform, {
      workDir: options.workDir || process.cwd(),
      paths: options.paths || {},
      ...options.contextVars
    });
    
    // Step 3: Render frontmatter template
    const frontmatterStr = yaml.dump(spec.frontmatter);
    const renderedFrontmatter = render(frontmatterStr, context);
    
    // Step 4: Render body template
    const renderedBody = render(spec.body, context);
    
    // Step 5: Combine and validate
    const output = `---\n${renderedFrontmatter}---\n\n${renderedBody}`;
    const validation = validate(renderedFrontmatter);
    
    if (!validation.valid) {
      return {
        success: false,
        output: null,
        errors: validation.errors
      };
    }
    
    return {
      success: true,
      output: output,
      errors: []
    };
  } catch (err) {
    return {
      success: false,
      output: null,
      errors: [{ message: err.message, stack: err.stack }]
    };
  }
}
```

4. **Error handling strategy:**
- Catch errors at each pipeline stage
- Provide stage-specific error context (parsing, rendering, validation)
- Aggregate errors into consistent format
- Never throw - always return {success, output, errors}

5. **Options support:**
- `validateOnly`: Skip rendering, only validate spec structure
- `dryRun`: Perform full pipeline but don't write files
- `verbose`: Include debug info in errors array

**Do NOT:**
- Write files directly (that's Phase 4 - installer integration)
- Handle adapter logic (adapters are Phase 2 concern)
- Add CLI argument parsing (generator is a library)
- Include Mustache conditionals yet (template literals only, per STACK.md)

**Dependencies:**
Requires all modules from Plan 01 and 02, plus js-yaml for frontmatter serialization.
  </action>
  <verify>
```bash
node -e "
const {generateAgent} = require('./bin/lib/template-system/generator');

// Create test spec
const fs = require('fs');
const testSpec = \`---
name: test-agent
description: Test agent for {{platform}}
tools: ['Bash', 'Read']
---

# Test Agent for {{platform}}

Working directory: {{workDir}}
\`;

fs.writeFileSync('/tmp/test-spec.md', testSpec);

// Generate for Claude
const result = generateAgent('/tmp/test-spec.md', 'claude', {
  workDir: '/workspace'
});

console.log('Success:', result.success);
console.log('Output preview:', result.output.substring(0, 200));
console.log('Errors:', result.errors.length);
"
```
Should output success=true with rendered agent content.
  </verify>
  <done>
generator.js exists with generateAgent and generateFromSpec exports. Module successfully orchestrates spec-parser → context-builder → engine pipeline. Returns structured {success, output, errors} objects.
  </done>
</task>

<task type="auto">
  <name>Create public API index file</name>
  <files>bin/lib/template-system/index.js</files>
  <action>
Create index.js that exports the public API surface for the template system:

**Module purpose:**
Provide clean import interface for template system. Future consumers (Phase 4 install.js integration) can `require('./lib/template-system')` and access all functionality.

**Implementation:**
```javascript
// bin/lib/template-system/index.js

const {parseSpec, parseSpecString} = require('./spec-parser');
const {buildContext} = require('./context-builder');
const {render, validate} = require('./engine');
const {generateAgent, generateFromSpec} = require('./generator');

module.exports = {
  // High-level API (most common usage)
  generateAgent,
  generateFromSpec,
  
  // Low-level API (for advanced use or testing)
  parseSpec,
  parseSpecString,
  buildContext,
  render,
  validate
};
```

**Why this structure:**
- High-level: `generateAgent` is one-call solution for 90% of use cases
- Low-level: Individual functions exposed for testing, debugging, advanced workflows
- Future-proof: Can add exports without breaking existing consumers
- Clear: One import gives access to entire template system

**Do NOT:**
- Re-implement functions (this is just re-exports)
- Add new functionality here (keep it as public API surface only)
- Export internal helper functions (only public API)
  </action>
  <verify>
```bash
node -e "
const templateSystem = require('./bin/lib/template-system');
console.log('Exports:', Object.keys(templateSystem));
console.log('Has generateAgent:', typeof templateSystem.generateAgent === 'function');
console.log('Has parseSpec:', typeof templateSystem.parseSpec === 'function');
"
```
Should list all exported functions.
  </verify>
  <done>
index.js exists and exports: generateAgent, generateFromSpec, parseSpec, parseSpecString, buildContext, render, validate. Provides clean public API for template system.
  </done>
</task>

<task type="auto">
  <name>Create comprehensive integration tests</name>
  <files>bin/lib/template-system/integration.test.js</files>
  <action>
Create integration tests that verify end-to-end functionality:

**Test cases:**

1. **Happy path - Complete generation:**
   - Create spec with frontmatter and body templates
   - Generate for Claude platform
   - Verify output has correct frontmatter structure
   - Verify variables substituted correctly
   - Verify YAML is valid

2. **Platform switching:**
   - Same spec generates different output for Claude vs Copilot
   - Platform-specific context values appear in output
   - Capabilities reflected correctly (supportsModel, etc.)

3. **Error handling - Invalid spec:**
   - Malformed YAML frontmatter
   - Missing required fields
   - File not found
   - Verify errors array populated with helpful messages

4. **Error handling - Undefined variables:**
   - Template references {{nonexistent}} variable
   - Verify error identifies the variable name

5. **Validation catches invalid output:**
   - Spec renders to invalid YAML (unclosed bracket)
   - Generator returns success=false with validation errors
   - Line number included in error

6. **Complex template:**
   - Multiple variable substitutions
   - Variables in frontmatter and body
   - Nested objects in frontmatter
   - All render correctly

**Test structure:**
```javascript
const assert = require('assert');
const fs = require('fs');
const path = require('path');
const os = require('os');
const {generateAgent} = require('./generator');

// Create temp directory
const testDir = path.join(os.tmpdir(), 'template-system-tests');
fs.mkdirSync(testDir, { recursive: true });

// Test 1: Happy path
function testHappyPath() {
  const specContent = `---
name: test-agent
description: Agent for {{platform}}
---

# Agent

Platform: {{platform}}
`;
  const specPath = path.join(testDir, 'test-spec.md');
  fs.writeFileSync(specPath, specContent);
  
  const result = generateAgent(specPath, 'claude', { workDir: '/workspace' });
  assert.strictEqual(result.success, true, 'Generation should succeed');
  assert.ok(result.output.includes('Platform: claude'), 'Variable should be substituted');
  console.log('✓ Happy path test passed');
}

// ... more tests

// Run all tests
testHappyPath();
// ... call other tests

console.log('\n✓ All integration tests passed');
```

**Run tests:**
```bash
node bin/lib/template-system/integration.test.js
```
  </action>
  <verify>
```bash
node bin/lib/template-system/integration.test.js
```
Should complete with "All integration tests passed" and no assertion errors.
  </verify>
  <done>
integration.test.js exists with 6+ end-to-end test cases. Tests verify: successful generation, platform switching, error handling for invalid specs, undefined variables, YAML validation, and complex templates. All tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Module structure:**
   ```bash
   ls -la bin/lib/template-system/
   ```
   Should show: spec-parser.js, context-builder.js, engine.js, generator.js, index.js, and test files

2. **Public API works:**
   ```bash
   node -e "
   const ts = require('./bin/lib/template-system');
   console.log('Template system loaded');
   console.log('Exports:', Object.keys(ts).join(', '));
   "
   ```

3. **End-to-end generation test:**
   ```bash
   node -e "
   const {generateAgent} = require('./bin/lib/template-system');
   const fs = require('fs');
   
   // Use existing agent as template
   const result = generateAgent('./agents/gsd-planner.md', 'claude', {
     workDir: '/workspace'
   });
   
   if (result.success) {
     console.log('✓ Generated agent successfully');
     console.log('Output length:', result.output.length);
   } else {
     console.error('✗ Generation failed:', result.errors);
     process.exit(1);
   }
   "
   ```

4. **All tests pass:**
   ```bash
   for test in bin/lib/template-system/*.test.js; do
     echo "Running $(basename $test)..."
     node "$test" || exit 1
   done
   echo "\n✓ All template system tests passed"
   ```

5. **Phase 1 success criteria met:**
   - [ ] Template system parses YAML frontmatter ✓
   - [ ] Variable substitution works ✓
   - [ ] YAML validation catches invalid output ✓
   - [ ] Error messages identify line/field ✓
   - [ ] Unit tests verify all variable types ✓
</verification>

<success_criteria>
1. ✅ generator.js orchestrates spec-parser → context-builder → engine pipeline
2. ✅ generateAgent function accepts spec path, platform, options and returns {success, output, errors}
3. ✅ index.js provides clean public API with both high-level and low-level functions
4. ✅ Integration tests verify end-to-end spec → agent generation
5. ✅ Error handling covers: invalid specs, undefined variables, validation failures
6. ✅ All Phase 1 requirements validated (TMPL-01, TMPL-03, TMPL-05, TMPL-07, TMPL-09)
7. ✅ Template system ready for Phase 2 (Platform Abstraction Layer) integration
</success_criteria>

<output>
After completion, create `.planning/phases/01-template-engine-foundation/01-03-SUMMARY.md` documenting:
- Generator implementation (pipeline orchestration)
- Public API design (index.js exports)
- Integration test results
- Phase 1 completion status
- Handoff notes for Phase 2:
  - Template system location: `bin/lib/template-system/`
  - Main entry point: `const ts = require('./bin/lib/template-system')`
  - Usage: `ts.generateAgent(specPath, platform, options)`
  - Next phase needs: Platform abstraction for tool names, capabilities, field transformations
</output>
