# Phase 7.2: Codebase Cleanup and Publishing Fixes - Research

**Researched:** 2025-01-29
**Domain:** npm package publishing, Node.js version migration, codebase cleanup
**Confidence:** HIGH (npm publishing), HIGH (Node 20 migration), MEDIUM (dead code detection tools)

## Summary

Phase 7.2 focuses on fixing npm publishing configuration, removing obsolete development artifacts, updating to Node 20, and improving error handling. The research identifies that the current package.json has critical issues: templates/ is missing from the "files" array (causing templates to not be published), and prepublishOnly references a non-existent script. The codebase has 5MB+ of audit files that should not be published, and development tooling (hooks/, scripts/, coverage/) should be excluded from the published package.

Key findings:
- **npm publishing**: Use "files" array with explicit whitelist (templates/, bin/), rely on npm auto-includes for standard files
- **Node 18‚Üí20 migration**: No breaking changes for this codebase (already using stable APIs), just update engines field
- **Code cleanup**: Use grep-based analysis for safe deletion, no sophisticated tools needed for this project size
- **Error handling**: Already following best practices (specific error codes for ENOENT/EACCES), only one empty catch block to fix
- **Environment variables**: Only ALLOW_SYMLINKS found - should be removed as decided

**Primary recommendation:** Fix package.json "files" array immediately (add templates/, remove unused entries), delete large audit files, validate with npm pack ‚Üí extract ‚Üí test workflow.

## npm Publishing Best Practices

### package.json "files" Field Configuration

**How it works:**
- Whitelist approach - only specified files/directories are included
- npm auto-includes: package.json, README*, LICENSE*, CHANGELOG*, files specified in "main" and "bin"
- Directories listed are included recursively
- "files" field overrides .npmignore (if both exist, "files" wins)

**For this project:**
```json
{
  "files": [
    "bin",
    "templates"
  ]
}
```

**Current state analysis:**
- ‚ùå templates/ missing (CRITICAL BUG - templates won't be published)
- ‚úì bin/ present (correct)
- ‚ùå commands/, get-shit-done/, agents/, hooks/, lib-ghcc/, docs/, github/ currently listed but need review
- ‚ùå prepublishOnly script references non-existent "scripts/build-templates.js"

**What to include:**
| Directory | Include? | Reason |
|-----------|----------|--------|
| bin/ | YES | Executable entry point |
| templates/ | YES | Core functionality - copied to user platforms |
| get-shit-done/ | NO | Development tooling (.github output) |
| hooks/ | NO | Development tooling (git hooks) |
| scripts/ | NO | Development tooling (audit scripts) |
| coverage/ | NO | Generated test artifacts |
| tests/ | NO | Not needed in published package |
| .github/ | NO | CI/CD configuration |

**Confidence:** HIGH - Standard npm behavior, verified in official documentation and current package state.

### Validation Tools

**npm pack --dry-run:**
```bash
npm pack --dry-run
```
Lists files that would be included without creating tarball.

**npm-packlist:**
```bash
npx npm-packlist
```
More accurate than --dry-run, shows exact file list with sizes.

**Recommended validation workflow:**
```bash
# 1. Check what would be included
npx npm-packlist

# 2. Create actual tarball
npm pack

# 3. Inspect tarball contents
tar -tzf get-shit-done-multi-*.tgz | less

# 4. Check tarball size
ls -lh get-shit-done-multi-*.tgz
```

**Target size:** Should be <500KB (templates ~1.2MB, bin ~328KB, minus node_modules)

**Confidence:** HIGH - Standard npm tooling, widely used in ecosystem.

### bin/ Executable Configuration

**Requirements:**
- Shebang line: `#!/usr/bin/env node` (‚úì already present in bin/install.js)
- package.json bin field maps command name to file path
- npm automatically makes bin files executable (chmod +x not needed)
- File must be JavaScript or have proper shebang for interpreter

**Current configuration:**
```json
{
  "bin": {
    "get-shit-done-multi": "bin/install.js"
  }
}
```

**How npx works:**
1. Downloads package tarball to npm cache (~/.npm/_npx/)
2. Extracts to temporary directory
3. Runs `npm install --production` (dependencies only)
4. Adds bin/ to PATH
5. Executes the command
6. Cleans up temporary files (unless cached)

**Confidence:** HIGH - Verified bin/install.js has proper shebang, standard npm bin configuration.

## Package Testing and Validation Workflow

### Step-by-Step Testing Process

**1. Pack and extract:**
```bash
# Create tarball
npm pack

# Extract to isolated directory
mkdir -p /tmp/package-test
tar -xzf get-shit-done-multi-*.tgz -C /tmp/package-test
cd /tmp/package-test/package
```

**2. Verify contents:**
```bash
# Check directory structure
ls -la

# Verify templates/ exists
test -d templates && echo "‚úì templates/ present" || echo "‚úó templates/ missing"

# Verify bin/ exists
test -d bin && echo "‚úì bin/ present" || echo "‚úó bin/ missing"

# Check for unwanted files
test -d .github && echo "‚úó .github/ present (should not be)" || echo "‚úì .github/ not present"
test -d hooks && echo "‚úó hooks/ present (should not be)" || echo "‚úì hooks/ not present"
test -d coverage && echo "‚úó coverage/ present (should not be)" || echo "‚úì coverage/ not present"
test -f audit-functions.json && echo "‚úó audit files present (should not be)" || echo "‚úì audit files not present"
```

**3. Install dependencies:**
```bash
# Production dependencies only
npm install --omit=dev

# Verify critical dependencies
node -e "import('commander').then(() => console.log('‚úì commander'))"
node -e "import('@clack/prompts').then(() => console.log('‚úì @clack/prompts'))"
node -e "import('fs-extra').then(() => console.log('‚úì fs-extra'))"
```

**4. Test bin execution:**
```bash
# Test help (should not require prompts)
node bin/install.js --help

# Test non-interactive mode
node bin/install.js --platform claude --scope global --yes

# Test interactive mode (in TTY)
node bin/install.js
```

**5. Simulate npx:**
```bash
# Add bin to PATH and execute directly
export PATH="/tmp/package-test/package/bin:$PATH"
get-shit-done-multi --help
```

**6. Cleanup:**
```bash
cd ~
rm -rf /tmp/package-test
rm get-shit-done-multi-*.tgz
```

### Pre-Publish Checklist

Before `npm publish`:
- [ ] npm pack creates tarball successfully
- [ ] Tarball size is reasonable (<1MB target)
- [ ] Extract and verify templates/ directory present
- [ ] Extract and verify bin/ directory present
- [ ] No .github/, hooks/, scripts/, coverage/ in tarball
- [ ] No audit-functions.* files in tarball
- [ ] No node_modules/ in tarball (should never be)
- [ ] bin/install.js has shebang line
- [ ] bin/install.js --help works
- [ ] bin/install.js interactive mode works
- [ ] bin/install.js --yes mode works
- [ ] All production dependencies resolve
- [ ] No broken prepublishOnly script

**Confidence:** HIGH - Standard npm testing workflow, verified against current project structure.

## Node.js 20 Migration Checklist

### Breaking Changes from Node 18 to Node 20

**Good news: No breaking changes for this codebase.**

Node 20 is backward compatible for stable APIs. Breaking changes affect primarily:
- Experimental features (Fetch API stabilized, no impact if using stable APIs)
- V8 engine updates (internal, no code changes needed)
- Deprecated API removals (none used in this project)

**Key differences (non-breaking):**
| Feature | Node 18 | Node 20 | Impact |
|---------|---------|---------|--------|
| fs.promises | Stable | Stable | None - already using |
| ESM support | Stable | Stable | None - already using |
| fetch API | Experimental | Stable | None - not using |
| import assertions | JSON only | JSON + others | None - not using |

**APIs used in this project (all stable in both versions):**
- fs/promises: readFile, writeFile, mkdir, readdir, stat, symlink, rm
- path: resolve, join, dirname, basename
- os: platform, homedir
- child_process: exec (promisified)
- url: fileURLToPath
- All stable since Node 16

### Migration Steps

**1. Update package.json:**
```json
{
  "engines": {
    "node": ">=20.0.0"
  }
}
```

Current: `"node": ">=16.7.0"`
Target: `"node": ">=20.0.0"`

**2. Update documentation:**
- README.md: Change "Node.js 16+" to "Node.js 20+"
- Any installation instructions referencing Node version
- CI/CD configuration (if testing multiple versions)

**3. No code changes needed:**
- All APIs already compatible
- ESM imports already working
- No deprecated API usage found

**4. Testing:**
```bash
# Verify current Node version
node --version  # Should be 20.x or higher

# Run full test suite
npm test

# Test package installation
npm pack && tar -xzf *.tgz && cd package && npm install --omit=dev
```

### Version Support Strategy

**Recommendation:** Require Node 20+
- Node 18: LTS until April 2025 (EOL soon)
- Node 20: Active LTS until October 2026 (current stable)
- Node 22: Current (not yet LTS)

**Why Node 20:**
- Long-term support through 2026
- Stable, production-ready
- Most users on 18 can easily upgrade
- No need to maintain backward compatibility with 16

**engines field behavior:**
- npm checks on install (warns but doesn't fail by default)
- Use `--engine-strict` flag to enforce strictly
- Used by package managers (pnpm enforces by default)

**Confidence:** HIGH - Node 20 is backward compatible, verified API usage is all stable, no code changes needed.

## Code Cleanup and Dead Code Detection

### Analysis Tools

**For this project size (small, focused codebase): grep-based analysis is sufficient.**

**No specialized tools needed because:**
- Single purpose CLI tool (not a large library)
- Clear dependency graph
- Small number of files (~50 JS files)
- Can manually verify references quickly

### Safe Deletion Workflow

**Before deleting any code:**

**1. Find all imports/requires:**
```bash
# For a specific file
grep -r "from.*filename" . --include="*.js" | grep -v node_modules

# For a specific function
grep -r "functionName" . --include="*.js" | grep -v node_modules | grep -v ".test.js"
```

**2. Check test references:**
```bash
grep -r "filename" tests/ --include="*.test.js"
```

**3. Check git history:**
```bash
# When was this last modified?
git log -1 --format="%ai %an" -- path/to/file

# Recent changes
git log --oneline --since="3 months ago" -- path/to/file

# Full history
git log --all --full-history --oneline -- path/to/file
```

**4. Verify not referenced in package.json:**
```bash
grep "filename" package.json
```

**After deletion:**

**1. Run tests:**
```bash
npm test
```

**2. Verify no broken imports:**
```bash
# Try to pack (will fail if imports broken)
npm pack --dry-run
```

**3. Check for runtime errors:**
```bash
node bin/install.js --help
```

### Specific Deletions for Phase 7.2

**Files to delete (from CONTEXT.md decisions):**

| File/Directory | Size | Reason | References Found |
|----------------|------|--------|------------------|
| audit-functions.json | 5MB | Development artifact | scripts/audit-functions.js |
| audit-functions.md | 35KB | Development artifact | scripts/audit-functions.js |
| scripts/audit-functions.js | 14KB | Generates above files | package.json (NONE - safe) |
| hooks/ | 12KB | Git hooks (dev tooling) | package.json "files" array |
| scripts/ | 16KB | Dev scripts | package.json prepublishOnly |
| coverage/ | 304KB | Generated test artifacts | .gitignore, vitest config |
| Dockerfile | 2.5KB | Docker dev setup | docker-compose.yml |
| docker-compose.yml | 1.6KB | Docker dev setup | None |

**Deletion order (separate commits):**
1. audit-functions.* files (with scripts/audit-functions.js)
2. coverage/ directory (generated, can be recreated)
3. hooks/ directory (git hooks)
4. scripts/ directory (after removing prepublishOnly)
5. Docker files (Dockerfile, docker-compose.yml, Makefile docker targets)

**Safe because:**
- None are imported by bin/ code
- None are referenced in runtime code
- Git history preserves everything
- Can be recovered if needed

### TODO Comment Resolution

**Found:** 1 TODO in bin/lib/platforms/detector.js:
```javascript
// TODO: Read version from manifest (Phase 6 - VERSION-02)
```

**Location:** Line 22 of bin/lib/platforms/detector.js

**Context:** Comment says "Phase 6" but we're past that phase. Need to update to explain current implementation.

**Resolution format (from CONTEXT.md):**
```javascript
// Previously TODO: Read version from manifest (Phase 6 - VERSION-02)
// Current implementation: Version detection not yet implemented.
// Detection only checks for manifest file presence (pathExists).
// Version reading deferred to future phase when needed.
```

**Confidence:** HIGH - Only one TODO found, context is clear, resolution format specified in CONTEXT.md.

## Error Handling Patterns for CLI Tools

### Node.js File System Error Codes

**Standard error codes (already used in this project):**

| Code | Meaning | When to Handle | User Message |
|------|---------|----------------|--------------|
| ENOENT | File/directory not found | Always | "File not found: {path}" |
| EACCES | Permission denied | Always | "Permission denied: {path}" |
| EPERM | Operation not permitted | Always | "Permission denied: {path}" |
| EEXIST | File/directory already exists | When relevant | "File already exists: {path}" |
| EISDIR | Expected file, got directory | Rarely | "Expected file, got directory: {path}" |
| ENOTDIR | Expected directory, got file | Rarely | "Expected directory, got file: {path}" |
| ENOTEMPTY | Directory not empty | When deleting | "Directory not empty: {path}" |

**Current implementation analysis:**
‚úì bin/lib/io/file-operations.js already handles EACCES, EPERM
‚úì Error messages include path context
‚úì Specific error types thrown (permissionDenied, invalidPath)
‚úó One empty catch block in bin/lib/platforms/binary-detector.js (line 21)

### Empty Catch Block Fix

**Location:** bin/lib/platforms/binary-detector.js:21-23

**Current code:**
```javascript
try {
  await execAsync(checkCmd, { timeout: 2000 });
  return true;
} catch {
  return false;
}
```

**Issue:** Silent failure - no way to know WHY command doesn't exist (ENOENT, timeout, etc.)

**Fix options:**

**Option 1: Check specific error (RECOMMENDED):**
```javascript
try {
  await execAsync(checkCmd, { timeout: 2000 });
  return true;
} catch (error) {
  // Command not found (ENOENT) or timeout is expected - return false
  if (error.code === 'ENOENT' || error.killed) {
    return false;
  }
  // Unexpected errors should bubble up
  throw error;
}
```

**Option 2: Always return false (ACCEPTABLE for binary detection):**
```javascript
try {
  await execAsync(checkCmd, { timeout: 2000 });
  return true;
} catch (error) {
  // Any error means binary not available
  // Common: ENOENT (not found), timeout (killed), EACCES (no permission)
  return false;
}
```

**Recommendation:** Option 2 - This is binary detection (checking if command exists), not critical path. Any error = "not available" is acceptable behavior. But add comment explaining why catch-all is OK here.

### CLI Exit Codes

**Standard conventions (POSIX):**
| Code | Meaning | When to Use |
|------|---------|-------------|
| 0 | Success | Operation completed successfully |
| 1 | General error | Catch-all for errors |
| 2 | Misuse of command | Invalid arguments, flags |
| 126 | Command cannot execute | Permission issue |
| 127 | Command not found | Binary not in PATH |
| 130 | Terminated by Ctrl+C | SIGINT received |

**Current implementation:**
‚úì bin/lib/errors/install-error.js defines EXIT_CODES
‚úì Uses exit code 1 for errors
‚úì Uses exit code 2 for invalid arguments (INVALID_ARGS)
‚úì Process exits with appropriate codes

**No changes needed** - already follows conventions.

### Error Message Formatting

**Best practices (already followed):**
- Include operation: "Permission denied: {path}"
- Include context: file path, platform name
- Be specific: "File not found" not "Error reading file"
- Avoid technical jargon: "Permission denied" not "EACCES"
- Suggest fix when possible: "Run with sudo" for permission errors

**Current examples:**
```javascript
throw permissionDenied(`Permission denied: ${dest}`, { path: dest, error });
throw invalidPath('Security validation failed at write time', { path, error });
```

‚úì Already following best practices.

**Confidence:** HIGH - Error handling already well-implemented, only one empty catch block to address, standard POSIX exit codes used.

## Environment Variable Hygiene

### Current Usage Analysis

**Found:** 1 environment variable usage in codebase:
```javascript
// bin/lib/installer/orchestrator.js
const allowSymlinks = skipPrompts || process.env.ALLOW_SYMLINKS === 'true';
```

**Decision from CONTEXT.md:** Remove ALLOW_SYMLINKS entirely.

### Standard Environment Variables

**Always acceptable (keep if found):**
| Variable | Purpose | Usage |
|----------|---------|-------|
| NODE_ENV | Environment (production, development, test) | Standard |
| DEBUG | Debug output control | Used by debug module |
| NO_COLOR | Disable colored output | Cross-tool standard |
| CI | Detect CI environment | Standard |

**npm/Node.js specific (automatic):**
| Variable | Purpose | Set by |
|----------|---------|--------|
| npm_package_* | package.json values | npm |
| npm_config_* | npm configuration | npm |
| NODE_OPTIONS | Node.js CLI options | User |
| PATH | Executable search | System |

**Project-specific (found): NONE after ALLOW_SYMLINKS removed**

### Security Implications

**Why avoid environment variables:**
- Visible in `ps aux` (process listings)
- Inherited by child processes (leak to subprocesses)
- Vary between environments (dev/staging/prod)
- Hard to discover (not in --help or docs)
- Can't be validated at runtime (string values only)

**Alternatives:**
| Instead of | Use |
|------------|-----|
| Feature flags | CLI flags (--flag) |
| User preferences | Config file (~/.config/app/config.json) |
| Runtime config | Command-line arguments |

### Removal Strategy

**For ALLOW_SYMLINKS:**

**1. Find all usages:**
```bash
grep -r "ALLOW_SYMLINKS" . --include="*.js" | grep -v node_modules
```

**2. Analysis:**
- Only 1 usage: bin/lib/installer/orchestrator.js
- Used for: Skipping symlink safety prompts
- Context: `skipPrompts` already handles non-interactive mode

**3. Remove:**
```javascript
// OLD:
const allowSymlinks = skipPrompts || process.env.ALLOW_SYMLINKS === 'true';

// NEW:
const allowSymlinks = skipPrompts; // Non-interactive mode skips prompts
```

**4. No migration needed:**
- Not a public API (internal implementation)
- No documentation mentions it
- No user-facing impact

**5. Update any tests:**
```bash
grep -r "ALLOW_SYMLINKS" tests/ --include="*.test.js"
```

If tests set this env var, remove those lines.

**Confidence:** HIGH - Only one env var found, clear removal path, no public API impact.

## Common Pitfalls

### npm Publishing Pitfalls

**1. Missing templates/ directory in published package**
- **Symptom:** npx install succeeds but "templates directory not found" error
- **Cause:** templates/ not in "files" array
- **Detection:** Extract tarball and check `ls package/templates`
- **Prevention:** Verify with `tar -tzf *.tgz | grep templates`
- **Fix:** Add "templates" to package.json "files" array

**2. Including large development files**
- **Symptom:** Slow npx install, large package size
- **Cause:** audit-functions.json (5MB) included in package
- **Detection:** `npm pack && ls -lh *.tgz` (should be <1MB)
- **Prevention:** Use npm-packlist to verify exclusions
- **Fix:** Remove audit files before publishing

**3. prepublishOnly script fails**
- **Symptom:** `npm publish` fails with "script not found"
- **Cause:** scripts/build-templates.js doesn't exist
- **Detection:** Run `npm publish --dry-run`
- **Prevention:** Remove unused scripts from package.json
- **Fix:** Delete prepublishOnly line or create script

**4. bin/ not executable**
- **Symptom:** "Permission denied" when running npx command
- **Cause:** Missing shebang line in bin file
- **Detection:** `head -1 bin/install.js` (should be #!/usr/bin/env node)
- **Prevention:** Always include shebang
- **Fix:** Already present, no action needed

### Code Cleanup Pitfalls

**1. Deleting files still imported**
- **Symptom:** Runtime error "Cannot find module"
- **Cause:** Removed file but not references to it
- **Detection:** npm test fails, grep for imports
- **Prevention:** `grep -r "from.*filename" . --include="*.js"` before deleting
- **Fix:** Remove imports first, then file

**2. Breaking prepublishOnly script**
- **Symptom:** npm publish fails
- **Cause:** Deleted script but package.json still references it
- **Detection:** `npm publish --dry-run`
- **Prevention:** Update package.json before deleting scripts
- **Fix:** Remove prepublishOnly line from package.json

**3. Removing files tracked in git**
- **Symptom:** Git shows deleted files as staged
- **Cause:** Used `rm` without `git rm`
- **Detection:** `git status` shows deletions
- **Prevention:** Use `git rm` for tracked files
- **Fix:** `git add -u` stages deletions

### Error Handling Pitfalls

**1. Empty catch blocks hiding real errors**
- **Symptom:** Silent failures, hard to debug
- **Cause:** Catch block with no error handling
- **Detection:** `grep -r "} catch {" . --include="*.js"`
- **Prevention:** Always log error or handle specifically
- **Fix:** Check error.code and handle expected errors only

**2. Generic error messages**
- **Symptom:** User gets unhelpful error
- **Cause:** Error message doesn't include context
- **Detection:** Manual testing
- **Prevention:** Always include path, operation in error messages
- **Fix:** Add context: `Permission denied: ${path}`

### Node.js Version Migration Pitfalls

**1. Assuming no breaking changes**
- **Symptom:** Works locally, fails on different Node version
- **Cause:** Using deprecated API
- **Detection:** Test on minimum supported version
- **Prevention:** Check Node.js changelog for deprecations
- **Fix:** Verify all APIs are stable in target version

**2. Not updating engines field**
- **Symptom:** Users install on old Node, get runtime errors
- **Cause:** package.json still says ">=16.7.0"
- **Detection:** Manual review of package.json
- **Prevention:** Update engines field in same commit as code changes
- **Fix:** Set `"engines": { "node": ">=20.0.0" }`

**3. Not testing after migration**
- **Symptom:** Publish broken package
- **Cause:** Assumed compatibility without testing
- **Detection:** npm test before publish
- **Prevention:** Always run full test suite
- **Fix:** Test with `npm pack ‚Üí extract ‚Üí test`

## Don't Hand-Roll

### Problems with Existing Solutions

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Package content validation | Custom ls/find script | `npm-packlist` | Matches npm's exact logic, handles .npmignore and files field |
| Tarball extraction | Custom tar wrapper | `tar -xzf package.tgz` | Standard tool, handles compression, works everywhere |
| Binary detection | Custom PATH search | `which` (Unix) / `where` (Windows) | Handles PATH properly, respects OS conventions |
| File operations | Custom fs wrappers | `fs-extra` (already installed) | Handles edge cases, mkdirp, copy recursive |
| Dead code detection | Custom AST parser | grep + manual review | For small projects, grep is faster and sufficient |

### When Simple Solutions Work

**This project is small enough that:**
- grep is sufficient for finding references
- Manual review catches unused code
- npm pack ‚Üí extract ‚Üí test is enough validation
- No need for sophisticated dead code tools

**Don't overcomplicate:**
- No need for `depcheck` (package only has 8 dependencies, all used)
- No need for `unimported` (50 files, clear structure)
- No need for custom testing framework (npm pack works)
- No need for automated version migration (no breaking changes)

### Validation Anti-Patterns

**Don't:**
- Run npm publish without testing locally first
- Test only in development (must test from tarball)
- Assume files field works (verify with npm-packlist)
- Manually list files in .npmignore (use files field instead)
- Use both .npmignore and files field (files field wins, confusing)

**Do:**
- Test from extracted tarball in /tmp
- Verify templates/ included (critical for this tool)
- Check package size (should be <1MB)
- Test both interactive and non-interactive modes
- Simulate npx execution flow

**Confidence:** HIGH - Based on standard npm tooling and project size analysis.

## Code Examples

### package.json "files" Field (Corrected)

```json
{
  "name": "get-shit-done-multi",
  "version": "2.0.0",
  "type": "module",
  "main": "index.js",
  "bin": {
    "get-shit-done-multi": "bin/install.js"
  },
  "files": [
    "bin",
    "templates"
  ],
  "engines": {
    "node": ">=20.0.0"
  },
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest watch",
    "test:coverage": "vitest run --coverage"
  }
}
```

**Changes from current:**
- Added "templates" to files array (CRITICAL)
- Removed "commands", "get-shit-done", "agents", "hooks", "lib-ghcc", "docs", "github" (unused)
- Removed prepublishOnly script (references non-existent file)
- Updated engines to Node 20

### Empty Catch Block Fix

**File:** bin/lib/platforms/binary-detector.js

**Before:**
```javascript
try {
  await execAsync(checkCmd, { timeout: 2000 });
  return true;
} catch {
  return false;
}
```

**After:**
```javascript
try {
  await execAsync(checkCmd, { timeout: 2000 });
  return true;
} catch (error) {
  // Binary detection: any error means command not available
  // Common: ENOENT (not found), timeout (killed), EACCES (no permission)
  // All cases should return false (binary not available)
  return false;
}
```

**Rationale:** This is binary detection - any error means "not available." Catch-all is acceptable here, but add comment explaining why.

### TODO Comment Update

**File:** bin/lib/platforms/detector.js

**Before:**
```javascript
// TODO: Read version from manifest (Phase 6 - VERSION-02)
// For now, just detect presence
```

**After:**
```javascript
// Previously TODO: Read version from manifest (Phase 6 - VERSION-02)
// Current implementation: Version detection not yet implemented.
// detectInstallations() only checks for manifest file presence via pathExists().
// Version reading deferred to future phase when version comparison is needed.
// The version field in results object is set to null.
```

### ALLOW_SYMLINKS Removal

**File:** bin/lib/installer/orchestrator.js

**Before:**
```javascript
const allowSymlinks = skipPrompts || process.env.ALLOW_SYMLINKS === 'true';
```

**After:**
```javascript
// Non-interactive mode (skipPrompts) skips all safety prompts including symlinks
const allowSymlinks = skipPrompts;
```

### Package Testing Script

**File:** tests/integration/package-validation.test.js (NEW - optional)

```javascript
#!/usr/bin/env node
/**
 * Package validation test - verifies npm pack output
 * Run with: node tests/integration/package-validation.test.js
 */

import { execSync } from 'child_process';
import { mkdtempSync, rmSync } from 'fs';
import { tmpdir } from 'os';
import { join } from 'path';

const tmpDir = mkdtempSync(join(tmpdir(), 'package-test-'));

try {
  console.log('üì¶ Creating package...');
  execSync('npm pack', { stdio: 'inherit' });
  
  console.log('üìÇ Extracting to /tmp...');
  execSync(`tar -xzf get-shit-done-multi-*.tgz -C ${tmpDir}`);
  
  const packageDir = join(tmpDir, 'package');
  
  console.log('‚úì Verifying package contents...');
  
  // Required directories
  execSync(`test -d ${packageDir}/bin`, { stdio: 'ignore' });
  console.log('  ‚úì bin/ present');
  
  execSync(`test -d ${packageDir}/templates`, { stdio: 'ignore' });
  console.log('  ‚úì templates/ present');
  
  // Forbidden directories
  try {
    execSync(`test ! -d ${packageDir}/.github`, { stdio: 'ignore' });
    console.log('  ‚úì .github/ not present');
  } catch {
    throw new Error('.github/ should not be in package');
  }
  
  try {
    execSync(`test ! -d ${packageDir}/hooks`, { stdio: 'ignore' });
    console.log('  ‚úì hooks/ not present');
  } catch {
    throw new Error('hooks/ should not be in package');
  }
  
  try {
    execSync(`test ! -f ${packageDir}/audit-functions.json`, { stdio: 'ignore' });
    console.log('  ‚úì audit-functions.json not present');
  } catch {
    throw new Error('audit-functions.json should not be in package');
  }
  
  console.log('\n‚úÖ Package validation passed!');
  
} catch (error) {
  console.error('\n‚ùå Package validation failed:', error.message);
  process.exit(1);
} finally {
  // Cleanup
  rmSync(tmpDir, { recursive: true, force: true });
  execSync('rm -f get-shit-done-multi-*.tgz');
}
```

**Usage:**
```bash
node tests/integration/package-validation.test.js
```

## Sources

### Primary (HIGH confidence)

**Official npm documentation:**
- npm "files" field: https://docs.npmjs.com/cli/v10/configuring-npm/package-json#files
- npm pack: https://docs.npmjs.com/cli/v10/commands/npm-pack
- npm bin field: https://docs.npmjs.com/cli/v10/configuring-npm/package-json#bin
- npx behavior: https://docs.npmjs.com/cli/v10/commands/npx

**Official Node.js documentation:**
- Node 20 release notes: https://nodejs.org/en/blog/release/v20.0.0
- Node.js error codes: https://nodejs.org/api/errors.html#nodejs-error-codes
- Node.js fs.promises: https://nodejs.org/api/fs.html#promises-api
- process.env: https://nodejs.org/api/process.html#processenv

**Project analysis (verified):**
- Current package.json: Verified file structure, dependencies, scripts
- Directory sizes: du -sh (coverage/ 304KB, templates/ 1.2MB, bin/ 328KB)
- Shebang verification: head -1 bin/install.js (‚úì present)
- Environment variable audit: grep process.env (found ALLOW_SYMLINKS only)
- TODO audit: grep TODO (found 1 in detector.js)
- Empty catch blocks: grep "catch {" (found 1 in binary-detector.js)

### Secondary (MEDIUM confidence)

**Ecosystem tools:**
- npm-packlist: Standard npm package listing tool
- depcheck: Unused dependency detection (mentioned but not needed for this project)
- unimported: Unused file detection (mentioned but not needed for this project)

**Best practices:**
- CLI exit codes: POSIX standard conventions (0=success, 1=error, 2=invalid args)
- Environment variable hygiene: Node.js community patterns
- Package testing workflow: Standard npm ecosystem practice

### Tertiary (LOW confidence)

None - all findings verified against official sources or project analysis.

## Metadata

**Confidence breakdown:**
- npm publishing: HIGH - Verified current package.json, extracted official npm behavior, tested workflow
- Node 20 migration: HIGH - Verified API usage, confirmed no breaking changes, LTS status verified
- Code cleanup: HIGH - Analyzed file sizes, found references with grep, verified safe deletion
- Error handling: HIGH - Audited current code, found 1 empty catch block, verified exit codes
- Environment variables: HIGH - Complete grep audit found only ALLOW_SYMLINKS
- Package testing: HIGH - Standard npm workflow, verified against current project structure

**Research date:** 2025-01-29
**Valid until:** 60 days (stable domain - npm and Node.js change slowly)

**Key risks identified:**
1. **CRITICAL:** templates/ missing from "files" array - package won't work when published
2. **HIGH:** prepublishOnly references non-existent script - publish will fail
3. **MEDIUM:** Large audit files will be included - package size >5MB
4. **LOW:** Empty catch block in binary detection - acceptable but should document

**Immediate actions required:**
1. Add "templates" to package.json "files" array
2. Remove prepublishOnly script or create the file
3. Delete audit-functions.* files
4. Test with npm pack ‚Üí extract ‚Üí bin/install.js

**No blockers found** - all issues have clear solutions, no external dependencies or breaking changes.
