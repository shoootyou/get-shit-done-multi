---
phase: 09-platform-instructions-installer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/installer/install-platform-instructions.js
  - bin/lib/platforms/instruction-paths.js
autonomous: true
must_haves:
  truths:
    - File doesn't exist → creates new file with template content
    - File exists, no start marker → appends with blank line separator
    - File exists, start marker found, content matches → skips (no duplicate)
    - File exists, start marker found, content differs → replaces block
    - File exists, markdown title interrupts block → inserts before title
    - CRLF line endings handled correctly (normalized to LF)
    - Variable replacement happens before marker extraction
  artifacts:
    - bin/lib/installer/install-platform-instructions.js exists with installPlatformInstructions() function
    - bin/lib/platforms/instruction-paths.js exists with instructionFiles constant and getInstructionPath() function
  wiring:
    - installPlatformInstructions() uses getInstructionPath() for path resolution
    - Function uses replaceVariables() from template-renderer
    - Function signature matches pattern: (templatesDir, targetDir, variables, multiBar, isVerbose, adapter)
  key_links:
    - getInstructionPath() returns absolute paths (joins with os.homedir() or process.cwd())
    - Dynamic marker extraction uses first/last lines of processed template
---

# Plan 09-01: Implement Platform Instructions Installer Core

## Objective

Create the core file merge logic for installing platform-specific instruction files (AGENTS.md/CLAUDE.md/copilot-instructions.md) with smart merge that handles three scenarios: create new, append without marker, or replace existing block with dynamic marker detection.

## Context

**What exists:**
- `templates/AGENTS.md` template with {{PLATFORM_ROOT}} and {{COMMAND_PREFIX}} variables
- `bin/lib/rendering/template-renderer.js` with replaceVariables() function
- `bin/lib/platforms/platform-paths.js` pattern for path resolution
- `bin/lib/installer/install-shared.js` as reference implementation

**What's needed:**
- New function installPlatformInstructions() with smart merge logic
- Path resolution utility for instruction file paths (scope-aware)
- Three merge scenarios: create, append, replace
- Dynamic block detection using first/last line as markers

**Key constraints:**
- Line ending normalization (CRLF → LF) before comparison
- Variable replacement BEFORE marker extraction (markers vary by platform)
- Exact line-by-line comparison (no fuzzy matching)
- Atomic write pattern (temp + rename)
- Follow existing project patterns (fs-extra, no new dependencies)

## Tasks

<task name="create-instruction-paths-utility" type="auto">
  <files>bin/lib/platforms/instruction-paths.js</files>
  <action>
Create new path resolution utility following platform-paths.js pattern.

1. **Define instructionFiles constant** (scope-aware paths):
```javascript
const instructionFiles = {
  claude: {
    global: '.claude/CLAUDE.md',      // Inside platform dir
    local: 'CLAUDE.md'                 // Project root
  },
  copilot: {
    global: '.copilot/copilot-instructions.md',  // Inside platform dir
    local: '.github/copilot-instructions.md'     // Inside .github/
  },
  codex: {
    global: '.codex/AGENTS.md',       // Inside platform dir
    local: 'AGENTS.md'                 // Project root
  }
};
```

2. **Implement getInstructionPath() function**:
- Parameters: (platform, isGlobal)
- Returns: Absolute path to instruction file
- Global: join os.homedir() with relative path
- Local: join process.cwd() with relative path
- Throw error for unknown platform

3. **Add JSDoc comments** matching platform-paths.js style

4. **Export function** for use by adapters and installer
  </action>
  <verify>
```bash
# Function exists and exports correctly
node -e "import('./bin/lib/platforms/instruction-paths.js').then(m => console.log(typeof m.getInstructionPath))"
# Should print: function

# Paths are correct for each platform
node -e "import('./bin/lib/platforms/instruction-paths.js').then(m => {
  console.log('Claude global:', m.getInstructionPath('claude', true));
  console.log('Claude local:', m.getInstructionPath('claude', false));
  console.log('Copilot local:', m.getInstructionPath('copilot', false));
  console.log('Codex local:', m.getInstructionPath('codex', false));
})"
# Should show absolute paths
```
  </verify>
  <done>instruction-paths.js created with instructionFiles constant and getInstructionPath() function returning absolute paths</done>
</task>

<task name="implement-merge-logic" type="auto">
  <files>bin/lib/installer/install-platform-instructions.js</files>
  <action>
Create installPlatformInstructions() function with smart merge logic.

**Function signature:**
```javascript
export async function installPlatformInstructions(
  templatesDir,
  targetDir, 
  variables,
  multiBar,
  isVerbose,
  adapter
) {
  // Returns: 1 (always installs exactly 1 file)
}
```

**Implementation steps:**

1. **Setup paths:**
```javascript
import { readFile, writeFile, rename, unlink } from 'fs/promises';
import { pathExists } from 'fs-extra';
import { join } from 'path';
import { replaceVariables } from '../rendering/template-renderer.js';
import { logVerboseComplete } from '../io/logger.js';

const templatePath = join(templatesDir, 'AGENTS.md');
const destPath = adapter.getInstructionsPath(isGlobal);
```

2. **Read and process template:**
```javascript
// Read template
const templateContent = await readFile(templatePath, 'utf8');

// Replace variables FIRST (markers vary by platform)
const processedContent = replaceVariables(templateContent, variables);

// Normalize line endings before split
const normalized = processedContent.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
const templateLines = normalized.split('\n');

// Extract dynamic markers (first/last line)
const startMarker = templateLines[0];
const endMarker = templateLines[templateLines.length - 1];
const blockLength = templateLines.length;
```

3. **Check if destination exists:**
```javascript
const exists = await pathExists(destPath);

if (!exists) {
  // SCENARIO 1: Create new file
  await writeFileAtomic(destPath, templateLines.join('\n'));
  logVerboseComplete(`Created ${adapter.platform} instructions`, isVerbose);
  return 1;
}
```

4. **Read existing file and normalize:**
```javascript
const existingContent = await readFile(destPath, 'utf8');
const existingNormalized = existingContent.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
const existingLines = existingNormalized.split('\n');
```

5. **Search for start marker:**
```javascript
const startIdx = existingLines.findIndex(line => line === startMarker);

if (startIdx === -1) {
  // SCENARIO 2: Append (marker not found)
  const merged = [...existingLines, '', ...templateLines];
  await writeFileAtomic(destPath, merged.join('\n'));
  logVerboseComplete(`Updated ${adapter.platform} instructions (appended)`, isVerbose);
  return 1;
}
```

6. **Find existing block and check for interruption:**
```javascript
// SCENARIO 3: Replace or skip
const expectedEndIdx = startIdx + blockLength - 1;

// Check if block is interrupted by markdown title
if (expectedEndIdx < existingLines.length) {
  // Look for markdown headers between start and expected end
  for (let i = startIdx + 1; i < Math.min(expectedEndIdx + 1, existingLines.length); i++) {
    if (/^#+\s/.test(existingLines[i])) {
      // Interrupted by user's section - insert full block before it
      const merged = [
        ...existingLines.slice(0, startIdx),
        ...templateLines,
        ...existingLines.slice(i)
      ];
      await writeFileAtomic(destPath, merged.join('\n'));
      logVerboseComplete(`Updated ${adapter.platform} instructions (replaced-interrupted)`, isVerbose);
      return 1;
    }
  }
}

// Extract existing block for comparison
const existingBlock = existingLines.slice(startIdx, expectedEndIdx + 1);

// Check if content matches exactly
const isIdentical = existingBlock.length === templateLines.length &&
  existingBlock.every((line, i) => line === templateLines[i]);

if (isIdentical) {
  // Skip - already up to date
  logVerboseComplete(`${adapter.platform} instructions already up to date`, isVerbose);
  return 1;
}

// Replace block
const merged = [
  ...existingLines.slice(0, startIdx),
  ...templateLines,
  ...existingLines.slice(expectedEndIdx + 1)
];
await writeFileAtomic(destPath, merged.join('\n'));
logVerboseComplete(`Updated ${adapter.platform} instructions (replaced)`, isVerbose);
return 1;
```

7. **Implement atomic write helper:**
```javascript
async function writeFileAtomic(filePath, content) {
  const tempPath = `${filePath}.tmp`;
  try {
    await writeFile(tempPath, content, 'utf8');
    await rename(tempPath, filePath);
  } catch (error) {
    // Cleanup temp file if rename failed
    try {
      await unlink(tempPath);
    } catch {
      // Ignore cleanup errors
    }
    throw error;
  }
}
```

**Critical points:**
- Line ending normalization BEFORE any split or comparison
- Variable replacement BEFORE marker extraction
- Exact line-by-line comparison (===)
- Atomic writes (temp + rename)
- Preserve user content when replacing block
  </action>
  <verify>
```bash
# Function exists and exports correctly
node -e "import('./bin/lib/installer/install-platform-instructions.js').then(m => console.log(typeof m.installPlatformInstructions))"
# Should print: function

# Check function signature (accepts 6 parameters)
node -e "import('./bin/lib/installer/install-platform-instructions.js').then(m => console.log(m.installPlatformInstructions.length))"
# Should print: 6
```
  </verify>
  <done>installPlatformInstructions() function created with all three merge scenarios, dynamic marker detection, line ending normalization, and atomic writes</done>
</task>

## Verification

After completing both tasks:

```bash
# Both modules exist and export correctly
ls -la bin/lib/platforms/instruction-paths.js
ls -la bin/lib/installer/install-platform-instructions.js

# Check exports
node -e "
import('./bin/lib/platforms/instruction-paths.js').then(m => {
  console.log('getInstructionPath:', typeof m.getInstructionPath);
});
import('./bin/lib/installer/install-platform-instructions.js').then(m => {
  console.log('installPlatformInstructions:', typeof m.installPlatformInstructions);
});
"
# Both should be 'function'

# Verify paths are scope-aware
node -e "
import('./bin/lib/platforms/instruction-paths.js').then(m => {
  const claudeGlobal = m.getInstructionPath('claude', true);
  const claudeLocal = m.getInstructionPath('claude', false);
  console.log('Claude global includes homedir:', claudeGlobal.includes(require('os').homedir()));
  console.log('Claude local is relative:', !claudeLocal.startsWith('/'));
  console.log('Copilot local includes .github:', m.getInstructionPath('copilot', false).includes('.github'));
});
"
```

## Success Criteria

- [ ] `instruction-paths.js` created with instructionFiles constant
- [ ] `getInstructionPath(platform, isGlobal)` returns correct absolute paths
- [ ] Local paths: Claude=root, Copilot=.github/, Codex=root
- [ ] Global paths: All inside platform directory (.claude/, .copilot/, .codex/)
- [ ] `installPlatformInstructions()` function created with correct signature
- [ ] Three merge scenarios implemented: create, append, replace
- [ ] Dynamic marker extraction from first/last lines (after variable replacement)
- [ ] Line ending normalization before split and comparison
- [ ] Exact line-by-line comparison for duplicate detection
- [ ] Markdown title interruption detection and handling
- [ ] Atomic write pattern (temp + rename)
- [ ] Verbose logging for all actions
- [ ] Function returns 1 (file count)

## Output

Two new files ready for adapter integration:
- `bin/lib/platforms/instruction-paths.js` - Path resolution utility
- `bin/lib/installer/install-platform-instructions.js` - Smart merge installer
