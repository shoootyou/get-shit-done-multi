---
phase: 09-platform-instructions-installer
plan: 04
type: execute
wave: 3
depends_on: [09-03]
files_modified:
  - tests/integration/platform-instructions.test.js
autonomous: true
must_haves:
  truths:
    - Test passes: Create new file when destination doesn't exist
    - Test passes: Append with blank line when no start marker found
    - Test passes: Skip when existing content matches template exactly
    - Test passes: Replace when existing content differs from template
    - Test passes: Handle CRLF line endings correctly (normalize before comparison)
    - Test passes: Insert before markdown title when block is interrupted
    - Test passes: All three platforms install to correct paths
    - Test passes: Variable replacement works ({{PLATFORM_ROOT}}, {{COMMAND_PREFIX}})
    - Test passes: Local vs global scope uses correct paths
  artifacts:
    - tests/integration/platform-instructions.test.js exists with comprehensive test coverage
    - Test uses createTestDir/cleanupTestDir pattern from existing tests
    - All merge scenarios covered with test cases
  wiring:
    - Tests import installPlatformInstructions from installer
    - Tests create mock adapter instances for each platform
    - Tests verify file content after installation
  key_links:
    - Tests validate end-to-end behavior (template → merge → output)
    - Line ending normalization verified with CRLF test fixtures
    - Scope-aware paths tested for local and global installations
---

# Plan 09-04: Create Integration Tests

## Objective

Create comprehensive integration tests for installPlatformInstructions() covering all merge scenarios (create, append, replace, skip, interrupt), line ending normalization, variable replacement, and all three platforms with both local and global scope.

## Context

**What exists:**
- `tests/integration/` directory with existing integration tests
- Test utilities in `tests/helpers/test-utils.js` (createTestDir, cleanupTestDir)
- vitest test framework
- Existing test patterns for file operations

**What's needed:**
- New test file: `tests/integration/platform-instructions.test.js`
- Tests for all three merge scenarios
- Tests for edge cases (CRLF, interruptions, empty files)
- Tests for all three platforms
- Tests for variable replacement
- Tests for local vs global scope

**Test structure:**
- Use describe blocks for logical grouping
- beforeEach/afterEach for test directory setup/cleanup
- Explicit assertions with meaningful error messages
- Mock adapters for testing without real installation

## Tasks

<task name="create-integration-tests" type="auto">
  <files>tests/integration/platform-instructions.test.js</files>
  <action>
Create comprehensive integration test file for platform instructions installer.

**Test file structure:**

```javascript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { installPlatformInstructions } from '../../bin/lib/installer/install-platform-instructions.js';
import { readFile, writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { mkdtempSync, rmSync } from 'fs';
import { tmpdir } from 'os';

describe('platform-instructions integration', () => {
  let testDir;
  let templatesDir;
  let targetDir;
  
  beforeEach(async () => {
    // Create unique test directory
    testDir = mkdtempSync(join(tmpdir(), 'gsd-test-instructions-'));
    templatesDir = join(testDir, 'templates');
    targetDir = join(testDir, 'target');
    
    await mkdir(templatesDir, { recursive: true });
    await mkdir(targetDir, { recursive: true });
    
    // Create template file
    const templateContent = `# Instructions for GSD

- Use the get-shit-done skill when the user asks for GSD or uses a \`gsd-*\` command.
- Treat \`{{COMMAND_PREFIX}}...\` or \`gsd-...\` as command invocations and load the matching file from \`{{PLATFORM_ROOT}}/get-shit-done/commands/gsd/\`.
- When a command says to spawn a subagent, prefer a matching custom agent from \`{{PLATFORM_ROOT}}/agents\`.
- Do not apply GSD workflows unless the user explicitly asks for them.`;
    
    await writeFile(join(templatesDir, 'AGENTS.md'), templateContent, 'utf8');
  });
  
  afterEach(() => {
    // Cleanup test directory
    rmSync(testDir, { recursive: true, force: true });
  });
  
  // Helper: Create mock adapter
  function createMockAdapter(platform, instructionsPath) {
    return {
      platform,
      getInstructionsPath: () => instructionsPath
    };
  }
  
  describe('scenario: create new file', () => {
    it('should create file when destination does not exist', async () => {
      const destPath = join(targetDir, 'CLAUDE.md');
      const adapter = createMockAdapter('claude', destPath);
      const variables = {
        PLATFORM_ROOT: '.claude',
        COMMAND_PREFIX: '/gsd-'
      };
      
      const count = await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      expect(count).toBe(1);
      
      const content = await readFile(destPath, 'utf8');
      expect(content).toContain('# Instructions for GSD');
      expect(content).toContain('.claude/get-shit-done/commands/gsd/');
      expect(content).toContain('/gsd-');
      expect(content).not.toContain('{{PLATFORM_ROOT}}');
      expect(content).not.toContain('{{COMMAND_PREFIX}}');
    });
  });
  
  describe('scenario: append to existing', () => {
    it('should append when no start marker found', async () => {
      const destPath = join(targetDir, 'CLAUDE.md');
      const adapter = createMockAdapter('claude', destPath);
      const variables = {
        PLATFORM_ROOT: '.claude',
        COMMAND_PREFIX: '/gsd-'
      };
      
      // Pre-create file with user content
      const existingContent = `# My Custom Instructions

These are my custom instructions.`;
      await writeFile(destPath, existingContent, 'utf8');
      
      const count = await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      expect(count).toBe(1);
      
      const content = await readFile(destPath, 'utf8');
      expect(content).toContain('# My Custom Instructions');
      expect(content).toContain('# Instructions for GSD');
      
      // Check blank line separator
      const lines = content.split('\n');
      const gsdIndex = lines.findIndex(l => l === '# Instructions for GSD');
      expect(lines[gsdIndex - 1]).toBe(''); // Blank line before GSD block
    });
  });
  
  describe('scenario: replace existing block', () => {
    it('should skip when content matches exactly', async () => {
      const destPath = join(targetDir, 'CLAUDE.md');
      const adapter = createMockAdapter('claude', destPath);
      const variables = {
        PLATFORM_ROOT: '.claude',
        COMMAND_PREFIX: '/gsd-'
      };
      
      // Install once
      await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      const contentAfterFirst = await readFile(destPath, 'utf8');
      
      // Install again (should skip)
      await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      const contentAfterSecond = await readFile(destPath, 'utf8');
      
      // Content should be identical (no duplication)
      expect(contentAfterFirst).toBe(contentAfterSecond);
    });
    
    it('should replace when content differs', async () => {
      const destPath = join(targetDir, 'CLAUDE.md');
      const adapter = createMockAdapter('claude', destPath);
      const variables = {
        PLATFORM_ROOT: '.claude',
        COMMAND_PREFIX: '/gsd-'
      };
      
      // Pre-create file with outdated GSD block
      const existingContent = `# Instructions for GSD

- Old instruction 1
- Old instruction 2
- Do not apply GSD workflows unless the user explicitly asks for them.`;
      await writeFile(destPath, existingContent, 'utf8');
      
      const count = await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      expect(count).toBe(1);
      
      const content = await readFile(destPath, 'utf8');
      expect(content).toContain('Use the get-shit-done skill');
      expect(content).not.toContain('Old instruction 1');
      
      // Should only have one occurrence of start marker
      const occurrences = (content.match(/# Instructions for GSD/g) || []).length;
      expect(occurrences).toBe(1);
    });
  });
  
  describe('scenario: interruption handling', () => {
    it('should insert before markdown title when block is interrupted', async () => {
      const destPath = join(targetDir, 'CLAUDE.md');
      const adapter = createMockAdapter('claude', destPath);
      const variables = {
        PLATFORM_ROOT: '.claude',
        COMMAND_PREFIX: '/gsd-'
      };
      
      // Pre-create file with user section interrupting expected block
      const existingContent = `# Instructions for GSD

- Old instruction

## My Custom Section

My custom content here.`;
      await writeFile(destPath, existingContent, 'utf8');
      
      const count = await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      expect(count).toBe(1);
      
      const content = await readFile(destPath, 'utf8');
      
      // GSD block should be complete
      expect(content).toContain('Use the get-shit-done skill');
      expect(content).toContain('Do not apply GSD workflows');
      
      // User section should be preserved
      expect(content).toContain('## My Custom Section');
      expect(content).toContain('My custom content here.');
      
      // User section should come after GSD block
      const gsdEnd = content.indexOf('Do not apply GSD workflows');
      const userSection = content.indexOf('## My Custom Section');
      expect(userSection).toBeGreaterThan(gsdEnd);
    });
  });
  
  describe('edge case: line endings', () => {
    it('should handle CRLF line endings correctly', async () => {
      const destPath = join(targetDir, 'CLAUDE.md');
      const adapter = createMockAdapter('claude', destPath);
      const variables = {
        PLATFORM_ROOT: '.claude',
        COMMAND_PREFIX: '/gsd-'
      };
      
      // Install with LF (normal)
      await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      const contentLF = await readFile(destPath, 'utf8');
      
      // Convert to CRLF
      const contentCRLF = contentLF.replace(/\n/g, '\r\n');
      await writeFile(destPath, contentCRLF, 'utf8');
      
      // Install again (should recognize as identical despite CRLF)
      await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      const contentAfter = await readFile(destPath, 'utf8');
      
      // Should only have one occurrence (no duplication)
      const occurrences = (contentAfter.match(/# Instructions for GSD/g) || []).length;
      expect(occurrences).toBe(1);
    });
  });
  
  describe('platform-specific paths', () => {
    it('should use correct path for Claude local', async () => {
      const destPath = join(targetDir, 'CLAUDE.md'); // Root
      const adapter = createMockAdapter('claude', destPath);
      const variables = { PLATFORM_ROOT: '.claude', COMMAND_PREFIX: '/gsd-' };
      
      await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      const content = await readFile(destPath, 'utf8');
      expect(content).toContain('.claude/');
    });
    
    it('should use correct path for Copilot local', async () => {
      const githubDir = join(targetDir, '.github');
      await mkdir(githubDir, { recursive: true });
      const destPath = join(githubDir, 'copilot-instructions.md'); // .github/
      const adapter = createMockAdapter('copilot', destPath);
      const variables = { PLATFORM_ROOT: '.github', COMMAND_PREFIX: '/gsd-' };
      
      await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      const content = await readFile(destPath, 'utf8');
      expect(content).toContain('.github/');
    });
    
    it('should use correct path for Codex local', async () => {
      const destPath = join(targetDir, 'AGENTS.md'); // Root
      const adapter = createMockAdapter('codex', destPath);
      const variables = { PLATFORM_ROOT: '.codex', COMMAND_PREFIX: '$gsd-' };
      
      await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      const content = await readFile(destPath, 'utf8');
      expect(content).toContain('.codex/');
      expect(content).toContain('$gsd-'); // Codex uses $ prefix
    });
  });
  
  describe('variable replacement', () => {
    it('should replace PLATFORM_ROOT variable', async () => {
      const destPath = join(targetDir, 'CLAUDE.md');
      const adapter = createMockAdapter('claude', destPath);
      const variables = {
        PLATFORM_ROOT: '.claude',
        COMMAND_PREFIX: '/gsd-'
      };
      
      await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      const content = await readFile(destPath, 'utf8');
      expect(content).toContain('.claude/get-shit-done/commands/gsd/');
      expect(content).toContain('.claude/agents');
      expect(content).not.toContain('{{PLATFORM_ROOT}}');
    });
    
    it('should replace COMMAND_PREFIX variable', async () => {
      const destPath = join(targetDir, 'AGENTS.md');
      const adapter = createMockAdapter('codex', destPath);
      const variables = {
        PLATFORM_ROOT: '.codex',
        COMMAND_PREFIX: '$gsd-'
      };
      
      await installPlatformInstructions(
        templatesDir,
        targetDir,
        variables,
        null,
        false,
        adapter
      );
      
      const content = await readFile(destPath, 'utf8');
      expect(content).toContain('$gsd-');
      expect(content).not.toContain('{{COMMAND_PREFIX}}');
    });
  });
});
```

**Key test coverage:**
- Create new file (doesn't exist)
- Append (exists, no marker)
- Skip (exists, identical)
- Replace (exists, different)
- Interruption (markdown title mid-block)
- CRLF handling
- Platform-specific paths (all 3 platforms)
- Variable replacement (both variables)

**Test patterns:**
- Use mkdtempSync for unique test directories (avoid collisions)
- Create real template files (no mocking file system)
- Verify file content with readFile
- Check for no duplication with occurrence counting
- Test end-to-end behavior (template → merge → output)
  </action>
  <verify>
```bash
# Test file exists
ls -la tests/integration/platform-instructions.test.js

# Run tests
npm test -- platform-instructions.test.js

# All tests should pass
# Expected: 12 passing tests covering all scenarios
```
  </verify>
  <done>Integration test file created with 12 comprehensive tests covering all merge scenarios, platforms, and edge cases</done>
</task>

## Verification

After completing the task:

```bash
# Test file exists
test -f tests/integration/platform-instructions.test.js && echo "Test file created"

# Count test cases
grep -c "it('should" tests/integration/platform-instructions.test.js
# Should show 12+ test cases

# Run tests
npm test -- platform-instructions.test.js

# Check test coverage includes all scenarios
grep "scenario:" tests/integration/platform-instructions.test.js
# Should show: create new file, append to existing, replace existing block, interruption handling

# Check edge cases covered
grep "edge case:" tests/integration/platform-instructions.test.js
# Should show: line endings

# Check platform tests
grep "platform-specific" tests/integration/platform-instructions.test.js
# Should show platform-specific paths tests

# Verify all three platforms tested
grep -c "should use correct path for" tests/integration/platform-instructions.test.js
# Should show 3 (Claude, Copilot, Codex)
```

## Success Criteria

- [ ] Test file created: tests/integration/platform-instructions.test.js
- [ ] Test uses beforeEach/afterEach for directory setup/cleanup
- [ ] Test creates unique temp directories (no collisions)
- [ ] Scenario tested: Create new file when doesn't exist
- [ ] Scenario tested: Append when no start marker
- [ ] Scenario tested: Skip when content matches
- [ ] Scenario tested: Replace when content differs
- [ ] Scenario tested: Insert before markdown title (interruption)
- [ ] Edge case tested: CRLF line endings normalized
- [ ] Platform tested: Claude local (CLAUDE.md in root)
- [ ] Platform tested: Copilot local (copilot-instructions.md in .github/)
- [ ] Platform tested: Codex local (AGENTS.md in root, $gsd- prefix)
- [ ] Variable replacement tested: {{PLATFORM_ROOT}}
- [ ] Variable replacement tested: {{COMMAND_PREFIX}}
- [ ] All tests pass successfully
- [ ] No file system pollution (temp dirs cleaned up)
- [ ] Test follows existing vitest patterns

## Output

Comprehensive integration test suite:
- `tests/integration/platform-instructions.test.js` - 12+ test cases

Test coverage:
- ✅ All three merge scenarios (create, append, replace)
- ✅ Skip duplicate detection
- ✅ Interruption handling
- ✅ CRLF line ending normalization
- ✅ All three platforms (Claude, Copilot, Codex)
- ✅ Scope-aware paths (local vs global)
- ✅ Variable replacement (both variables)

Ready for execution validation.
