---
phase: 04-platform-paths
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - bin/lib/conflict-resolver.js (new)
  - bin/lib/conflict-resolver.test.js (new)
  - bin/install.js
  - bin/lib/adapters/claude.js
  - bin/lib/adapters/copilot.js
  - bin/lib/adapters/codex.js
autonomous: false
checkpoint: verify-installation-paths
must_haves:
  - truth: "Installing Claude globally creates files in `~/.claude/` directory (not old path)"
    artifact: bin/install.js
    wiring: Integration with updated paths.js
  - truth: "Re-installing over existing GSD installation automatically removes old commands/agents/skills directories without prompting"
    artifact: bin/lib/conflict-resolver.js
    wiring: GSD content detection and auto-cleanup
  - truth: "Installing when user files exist in target directory prompts for per-file confirmation with conflict path shown"
    artifact: bin/lib/conflict-resolver.js
    wiring: Non-GSD content detection and confirmation prompts
  - truth: "Installing Claude globally when old path exists shows warning message with old and new paths"
    artifact: bin/lib/conflict-resolver.js
    wiring: Old Claude path migration detection
  - truth: "Running `node bin/install.js --claude --local --config-dir /tmp/test` creates files in `/tmp/test/.claude/` directory"
    artifact: bin/install.js
    wiring: Config-dir flag integration with path resolution
---

# Phase 4, Plan 2: Conflict Resolution & Installation Integration

## Objective

Implement conflict detection/resolution for re-installations, integrate updated path utilities into install.js and platform adapters, handle old Claude path migration warning, and support `--config-dir` flag.

## Context

**Depends on Plan 01:** Updated `paths.js` with `getConfigPaths(platform, scope, configDir)` and `path-validator.js` with validation logic.

**From CONTEXT.md conflict resolution rules:**
1. **GSD content** (commands/, agents/, skills/, get-shit-done/ directories): Auto-cleanup, no prompting
2. **Non-GSD content** (user files): Per-file confirmation with path shown
3. **Permission errors**: Fail with suggestion to use `--local`
4. **Old Claude path**: Detect `~/Library/Application Support/Claude`, show warning (no auto-removal)

**Integration points:**
- `bin/install.js` - main installation entry point
- `bin/lib/adapters/*.js` - platform-specific installers (call getConfigPaths)
- Flag parser output: `{platforms: [...], scope: 'global'|'local', configDir: '...'}`

## Tasks

<task name="create-conflict-resolver" type="auto">
  <files>bin/lib/conflict-resolver.js (new)</files>
  <action>
Create `bin/lib/conflict-resolver.js` module with conflict detection and resolution logic.

**Exports:**
```javascript
module.exports = {
  analyzeInstallationConflicts,
  cleanupGSDContent,
  detectOldClaudePath,
  isGSDContent
};
```

**Constants:**
```javascript
const GSD_DIRECTORIES = ['commands', 'agents', 'skills', 'get-shit-done'];
```

**isGSDContent(filePath, installRoot):**
```javascript
function isGSDContent(filePath, installRoot) {
  const relativePath = path.relative(installRoot, filePath);
  const parts = relativePath.split(path.sep);
  return GSD_DIRECTORIES.includes(parts[0]);
}
```

**analyzeInstallationConflicts(targetPath):**
Returns:
```javascript
{
  hasConflicts: boolean,
  gsdFiles: string[],      // Paths to GSD-managed files
  userFiles: string[],     // Paths to non-GSD files
  canAutoClean: boolean    // True if only GSD files exist
}
```

Logic:
1. Check if targetPath exists (return no conflicts if not)
2. Read directory contents with `fs-extra.readdir(targetPath, {withFileTypes: true})`
3. For each entry:
   - If directory name in GSD_DIRECTORIES: Mark all contents as GSD files
   - Otherwise: Mark as user files
4. Return analysis

**cleanupGSDContent(gsdFiles):**
```javascript
async function cleanupGSDContent(gsdFiles) {
  const uniqueDirs = new Set();
  
  // Extract unique GSD directories
  for (const file of gsdFiles) {
    for (const gsdDir of GSD_DIRECTORIES) {
      if (file.includes(path.sep + gsdDir + path.sep) || file.endsWith(path.sep + gsdDir)) {
        uniqueDirs.add(path.dirname(file.split(gsdDir)[0]) + path.sep + gsdDir);
      }
    }
  }
  
  // Remove directories
  for (const dir of uniqueDirs) {
    await fse.remove(dir);
  }
  
  return { removed: uniqueDirs.size };
}
```

**detectOldClaudePath():**
```javascript
async function detectOldClaudePath() {
  const oldPath = path.join(os.homedir(), 'Library', 'Application Support', 'Claude');
  
  if (await fse.pathExists(oldPath)) {
    return {
      exists: true,
      path: oldPath,
      warning: `⚠️  Old installation detected at ${oldPath}
   Manual cleanup recommended to avoid conflicts.
   New installation will use: ~/.claude/`
    };
  }
  
  return { exists: false };
}
```

Use patterns from RESEARCH.md section "Pattern 4: GSD Content Identification".
  </action>
  <verify>
```bash
# Test conflict detection (requires temp directory setup)
node -e "
const fse = require('fs-extra');
const path = require('path');
const {analyzeInstallationConflicts, isGSDContent} = require('./bin/lib/conflict-resolver');

(async () => {
  const testDir = '/tmp/gsd-test-conflicts';
  await fse.ensureDir(testDir);
  await fse.ensureDir(path.join(testDir, 'commands'));
  await fse.ensureDir(path.join(testDir, 'agents'));
  await fse.writeFile(path.join(testDir, 'user-file.txt'), 'test');
  
  const analysis = await analyzeInstallationConflicts(testDir);
  console.log('Has conflicts:', analysis.hasConflicts);
  console.log('GSD files found:', analysis.gsdFiles.length > 0);
  console.log('User files found:', analysis.userFiles.length > 0);
  console.log('Can auto clean:', analysis.canAutoClean === false);
  
  await fse.remove(testDir);
})();
"

# Test old path detection
node -e "
const {detectOldClaudePath} = require('./bin/lib/conflict-resolver');
(async () => {
  const result = await detectOldClaudePath();
  console.log('Old path check completed:', result.exists !== undefined);
})();
"
```
  </verify>
  <done>
Conflict resolver detects GSD vs user content, old Claude path detection works, cleanup logic ready
  </done>
</task>

<task name="integrate-paths-into-adapters" type="auto">
  <files>
    bin/lib/adapters/claude.js
    bin/lib/adapters/copilot.js
    bin/lib/adapters/codex.js
  </files>
  <action>
Update platform adapters to use new `getConfigPaths(platform, scope, configDir)` signature.

**For each adapter (claude.js, copilot.js, codex.js):**

Find existing `getConfigPaths()` call:
```javascript
// OLD (Phase 3 and earlier):
const { global, local } = getConfigPaths('claude');
```

Replace with:
```javascript
// NEW (Phase 4):
const targetPath = getConfigPaths('claude', scope, configDir);
```

**Changes needed:**
1. Adapters should receive `scope` and `configDir` as parameters (from install.js)
2. Update function signatures if needed (check current adapter exports)
3. Remove destructuring of `{global, local}` - now single path returned
4. Use `targetPath` directly for installation

**Current adapter pattern (from grep results):**
- Adapters already call `getConfigPaths('platform')` 
- They determine scope internally based on context
- Need to receive scope from caller instead

**Check adapter function signatures:**
Verify what parameters adapters currently accept and add scope/configDir if missing.
  </action>
  <verify>
```bash
# Check adapter signatures
grep -n "^function\|^async function\|^module.exports" bin/lib/adapters/claude.js bin/lib/adapters/copilot.js bin/lib/adapters/codex.js

# Verify getConfigPaths usage updated
grep -A2 "getConfigPaths" bin/lib/adapters/claude.js bin/lib/adapters/copilot.js bin/lib/adapters/codex.js

# Expected: All calls use (platform, scope, configDir) signature
```
  </verify>
  <done>
Adapters updated to call getConfigPaths with scope parameter, receive scope/configDir from install.js
  </done>
</task>

<task name="integrate-into-install-flow" type="auto">
  <files>bin/install.js</files>
  <action>
Integrate path resolution, validation, and conflict resolution into install.js main flow.

**Integration points (find and update):**

1. **After flag parsing (Phase 2/3 output):**
```javascript
// Flag parser returns: {platforms: [...], scope: 'global'|'local', configDir: '...'}
const {platforms, scope, configDir} = /* ...from parser or menu... */;
```

2. **Before installation loop:**
```javascript
// Validate --config-dir with --global conflict
if (configDir && scope === 'global') {
  console.error('Error: Cannot use --config-dir with --global');
  process.exit(1);
}

// Detect old Claude path (only if installing Claude globally)
if (platforms.includes('claude') && scope === 'global') {
  const {detectOldClaudePath} = require('./lib/conflict-resolver');
  const oldPathCheck = await detectOldClaudePath();
  if (oldPathCheck.exists) {
    console.warn(oldPathCheck.warning);
  }
}
```

3. **For each platform installation:**
```javascript
const {getConfigPaths} = require('./lib/paths');
const {validatePath} = require('./lib/path-validator');
const {analyzeInstallationConflicts, cleanupGSDContent} = require('./lib/conflict-resolver');
const {ensureInstallDir} = require('./lib/paths');

// Get target path
const targetPath = getConfigPaths(platform, scope, configDir);

// Validate path
const validation = validatePath(targetPath);
if (!validation.valid) {
  console.error(`Invalid path for ${platform}: ${validation.errors.join(', ')}`);
  process.exit(1);
}

// Analyze conflicts
const conflicts = await analyzeInstallationConflicts(targetPath);

// Auto-cleanup GSD content
if (conflicts.gsdFiles.length > 0 && conflicts.canAutoClean) {
  const {removed} = await cleanupGSDContent(conflicts.gsdFiles);
  console.log(`Cleaned up ${removed} directories from previous installation.`);
}

// Handle user file conflicts (if any)
if (conflicts.hasConflicts && !conflicts.canAutoClean) {
  // TODO: Implement per-file confirmation (deferred - show error for now)
  console.error(`Conflict: User files exist in ${targetPath}`);
  console.error(`User files: ${conflicts.userFiles.join(', ')}`);
  console.error('Manual cleanup required before installation.');
  process.exit(1);
}

// Create directory with permission checking
const dirResult = await ensureInstallDir(targetPath, scope);
if (!dirResult.success) {
  console.error(`Error: ${dirResult.error}`);
  console.error(`Suggestion: ${dirResult.suggestion}`);
  process.exit(1);
}

// Pass targetPath to adapter
await installPlatform(platform, targetPath);
```

4. **Update adapter calls:**
Pass `targetPath` to platform adapters (they no longer compute paths themselves).

**Notes:**
- Per-file conflict prompts deferred (CONTEXT.md allows simple error for now)
- Focus on auto-cleanup of GSD content (re-installation use case)
- Permission errors provide helpful suggestions
  </action>
  <verify>
```bash
# Verify integration (syntax check)
node -c bin/install.js

# Check for required imports
grep "conflict-resolver\|path-validator\|paths" bin/install.js

# Verify --config-dir validation exists
grep -A3 "configDir.*global" bin/install.js

# Verify old path detection for Claude
grep -A5 "detectOldClaudePath" bin/install.js
```
  </verify>
  <done>
install.js integrates path resolution, validation, conflict detection, old path warning, and permission checking
  </done>
</task>

<task name="test-conflict-resolver" type="auto">
  <files>bin/lib/conflict-resolver.test.js (new)</files>
  <action>
Create comprehensive test suite for conflict-resolver.js (Jest).

**Test coverage:**

1. **isGSDContent():**
   - Returns true for files in commands/ directory
   - Returns true for files in agents/ directory
   - Returns true for files in skills/ directory
   - Returns true for files in get-shit-done/ directory
   - Returns false for files in other directories
   - Handles nested paths correctly

2. **analyzeInstallationConflicts():**
   - Returns no conflicts when directory doesn't exist
   - Detects GSD directories (commands, agents, skills)
   - Detects user files (non-GSD content)
   - Sets canAutoClean=true when only GSD files
   - Sets canAutoClean=false when user files exist
   - Handles empty directories

3. **cleanupGSDContent():**
   - Removes GSD directories
   - Returns count of removed directories
   - Handles nested GSD content
   - Doesn't touch user files

4. **detectOldClaudePath():**
   - Returns exists=true when old path exists (mock fs-extra.pathExists)
   - Returns exists=false when old path doesn't exist
   - Warning message includes old and new paths
   - Only checks ~/Library/Application Support/Claude

**Mocking:**
- Mock `fs-extra.pathExists`, `fs-extra.readdir`, `fs-extra.remove`, `fs-extra.stat`
- Mock `os.homedir()` for predictable home path
- Use temp directories for integration-style tests if needed

Target: >80% coverage.
  </action>
  <verify>
```bash
# Run tests
npm test -- bin/lib/conflict-resolver.test.js

# Check coverage
npm test -- --coverage --collectCoverageFrom='bin/lib/conflict-resolver.js'

# Verify >80% coverage
```
  </verify>
  <done>
conflict-resolver.test.js passes with >80% coverage, all edge cases tested
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Updated path resolution system with cross-platform validation, conflict resolution, and integration into install.js. Breaking change from old Claude path to `~/.claude/` is now active.
  </what-built>
  <how-to-verify>
**Test 1: Claude Local Installation**
```bash
cd /tmp
mkdir gsd-test-local && cd gsd-test-local
node /workspace/bin/install.js --claude --local
# Expected: Creates .claude/ directory in current folder
ls -la .claude/
```

**Test 2: Copilot Global Installation (requires permissions)**
```bash
node /workspace/bin/install.js --copilot --global
# Expected: Creates ~/.copilot/ directory
ls -la ~/.copilot/
```

**Test 3: Custom Config Directory**
```bash
mkdir -p /tmp/custom-config
node /workspace/bin/install.js --claude --local --config-dir /tmp/custom-config
# Expected: Creates /tmp/custom-config/.claude/
ls -la /tmp/custom-config/.claude/
```

**Test 4: Re-installation (Conflict Cleanup)**
```bash
# Install twice to same location
cd /tmp/gsd-test-local
node /workspace/bin/install.js --claude --local
node /workspace/bin/install.js --claude --local
# Expected: Second install auto-cleans GSD content, no errors
```

**Test 5: Old Claude Path Warning**
```bash
# Create old path to trigger warning
mkdir -p ~/Library/Application\ Support/Claude
node /workspace/bin/install.js --claude --global
# Expected: Shows warning about old path, installs to ~/.claude/
```

**Test 6: Codex Global Error**
```bash
node /workspace/bin/install.js --codex --global
# Expected: Error message "Global installation not supported for codex"
```

**Test 7: Config-dir + Global Conflict**
```bash
node /workspace/bin/install.js --claude --global --config-dir /tmp/test
# Expected: Error "Cannot use --config-dir with --global"
```

**Pass criteria:**
- [ ] Claude local creates `.claude/` in current directory
- [ ] Copilot global creates `~/.copilot/` (not old path)
- [ ] Custom config directory works with `--config-dir`
- [ ] Re-installation auto-cleans GSD content without prompting
- [ ] Old Claude path shows warning (if exists)
- [ ] Codex global shows clear error
- [ ] Config-dir + global conflict shows error
- [ ] All unit tests pass (npm test)
  </how-to-verify>
  <resume-signal>
Type "approved" if all tests pass, or describe issues found
  </resume-signal>
</task>

## Success Criteria

- [ ] Conflict resolver detects GSD vs user content
- [ ] Re-installation auto-cleans GSD directories (commands, agents, skills, get-shit-done)
- [ ] Non-GSD content shows error with file paths (per-file prompts deferred)
- [ ] Old Claude path detection shows warning when `~/Library/Application Support/Claude` exists
- [ ] install.js integrates path validation before directory creation
- [ ] install.js calls ensureInstallDir with permission checking
- [ ] Adapters receive targetPath from install.js (don't compute paths)
- [ ] `--config-dir` creates platform subdirectories in custom location
- [ ] `--config-dir` with `--global` shows error and exits
- [ ] Permission errors suggest using `--local` instead
- [ ] Test coverage >80% for conflict-resolver.js
- [ ] Manual verification checkpoint approved

## Output

Complete path resolution system integrated into installation flow:
- ✅ Claude: `[repo]/.claude/` (local), `~/.claude/` (global)
- ✅ Copilot: `[repo]/.github/` (local), `~/.copilot/` (global)
- ✅ Codex: `[repo]/.codex/` (local only)
- ✅ Cross-platform validation (Windows/macOS/Linux/WSL)
- ✅ Conflict resolution (GSD auto-cleanup)
- ✅ Old path migration warning
- ✅ Custom config directory support

**Ready for Phase 5:** Message optimization can now reference specific installation paths and provide clean, context-aware output.
