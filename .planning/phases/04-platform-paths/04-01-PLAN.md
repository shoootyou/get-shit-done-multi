---
phase: 04-platform-paths
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/paths.js
  - bin/lib/path-validator.js (new)
  - bin/lib/paths.test.js (new)
  - bin/lib/path-validator.test.js (new)
autonomous: true
must_haves:
  - truth: "Running `node -e \"const {getConfigPaths} = require('./bin/lib/paths'); console.log(getConfigPaths('claude', 'global'))\"` outputs path ending in `.claude/` (not `Library/Application Support/Claude`)"
    artifact: bin/lib/paths.js
    wiring: getConfigPaths returns updated path structure
  - truth: "Running `node -e \"const {getConfigPaths} = require('./bin/lib/paths'); console.log(getConfigPaths('copilot', 'global', '/custom'))\"` outputs `/custom/.copilot/`"
    artifact: bin/lib/paths.js
    wiring: --config-dir support in path resolution
  - truth: "Calling validatePath() with Windows path containing `<>:` characters returns validation error"
    artifact: bin/lib/path-validator.js
    wiring: Platform-specific validation rules
  - truth: "Calling validatePath() with 300-char path on Windows returns path length error"
    artifact: bin/lib/path-validator.js
    wiring: Path length limit checking
  - truth: "Calling ensureInstallDir() with unwritable directory path returns error with helpful suggestion to use --local"
    artifact: bin/lib/paths.js
    wiring: Permission-aware directory creation with actionable errors
---

# Phase 4, Plan 1: Path Resolution & Validation

## Objective

Update path resolution utilities to new specification with cross-platform validation, breaking change from old Claude path (`~/Library/Application Support/Claude` → `~/.claude/`), and support for custom config directories.

## Context

**From Phase 2/3:** Flag parser and interactive menu both output `{platforms: [...], scope: 'global'|'local'}`. Phase 4 consumes this to determine installation paths.

**Breaking change:** Claude global path changes from `~/Library/Application Support/Claude` to `~/.claude/` per PATH-01. This is a clean break - no migration automation, just warning if old path exists (handled in Plan 02).

**Current state:** `bin/lib/paths.js` has `getConfigPaths(cli, projectDir)` but:
- Hardcoded old Claude path (line 22)
- No scope parameter (assumes both global+local returned)
- No config-dir support
- No validation logic

**Research findings:** Use Node.js built-ins (`path`, `os`) + `fs-extra` (already in deps). Create separate validation module for platform-specific rules.

## Tasks

<task name="update-paths-module" type="auto">
  <files>bin/lib/paths.js</files>
  <action>
Update `getConfigPaths()` function signature and implementation:

**New signature:**
```javascript
function getConfigPaths(platform, scope, configDir = null)
```

**Changes:**
1. Add `scope` parameter ('global' or 'local')
2. Add `configDir` parameter for --config-dir support
3. Update Claude global path: `~/Library/Application Support/Claude` → `~/.claude/`
4. Update Codex global path: `~/.codex/` → `null` (not supported)
5. Return single path string (not object with global+local)

**Logic:**
- If `configDir` provided: `path.join(path.resolve(configDir), platformSubdir)`
  - platformSubdir: `.claude` for claude, `.github` for copilot, `.codex` for codex
- If `scope === 'global'`:
  - claude: `~/.claude/`
  - copilot: `~/.copilot/`
  - codex: `null` (throw error: "Global installation not supported for codex")
- If `scope === 'local'`:
  - claude: `[cwd]/.claude/`
  - copilot: `[cwd]/.github/`
  - codex: `[cwd]/.codex/`

**Add new function:**
```javascript
async function ensureInstallDir(targetPath, scope)
```
Uses `fs-extra.ensureDir()` with permission checking. Returns:
- `{success: true}` on success
- `{success: false, error: string, suggestion: string}` on EACCES/EPERM

**Preserve existing:**
- `expandTilde()` function (used elsewhere in codebase)

**Update module.exports:**
Add `ensureInstallDir` to exports.
  </action>
  <verify>
```bash
# Test updated function signature
node -e "const {getConfigPaths} = require('./bin/lib/paths'); 
  console.log('Claude global:', getConfigPaths('claude', 'global'));
  console.log('Claude local:', getConfigPaths('claude', 'local'));
  console.log('Copilot global:', getConfigPaths('copilot', 'global'));
  console.log('Copilot local:', getConfigPaths('copilot', 'local'));
  console.log('Codex local:', getConfigPaths('codex', 'local'));
  console.log('Custom config:', getConfigPaths('claude', 'local', '/tmp/custom'));
"

# Verify paths match specification
# Expected:
# Claude global: /Users/[user]/.claude
# Claude local: [cwd]/.claude
# Copilot global: /Users/[user]/.copilot
# Copilot local: [cwd]/.github
# Codex local: [cwd]/.codex
# Custom config: /tmp/custom/.claude

# Test Codex global rejection
node -e "const {getConfigPaths} = require('./bin/lib/paths'); 
  try { 
    getConfigPaths('codex', 'global'); 
  } catch(e) { 
    console.log('Codex global error:', e.message); 
  }
" | grep "not supported"
```
  </verify>
  <done>
getConfigPaths() returns single path based on scope, Claude uses `~/.claude/` for global, configDir parameter works, Codex global throws error
  </done>
</task>

<task name="create-path-validator" type="auto">
  <files>bin/lib/path-validator.js (new)</files>
  <action>
Create new module `bin/lib/path-validator.js` with platform-specific validation:

**Exports:**
```javascript
module.exports = { 
  validatePath,
  getEffectivePlatform,
  isWSL
};
```

**validatePath(targetPath):**
Returns `{valid: boolean, errors: string[]}`

Validation rules:
1. **Windows (`process.platform === 'win32'`):**
   - Invalid characters: `<>:"|?*` and control chars (0x00-0x1f)
   - Reserved names: `CON, PRN, AUX, NUL, COM[1-9], LPT[1-9]` (case-insensitive basename check)
   - Path length: MAX_PATH = 260 characters

2. **Unix (macOS/Linux):**
   - Path length: 1024 chars (macOS), 4096 chars (Linux) - use conservative 1024 for macOS, 4096 for Linux
   - Platform detection: `process.platform === 'darwin'` → 1024, else 4096

**isWSL():**
Detect Windows Subsystem for Linux:
```javascript
function isWSL() {
  if (process.platform !== 'linux') return false;
  
  try {
    const procVersion = fs.readFileSync('/proc/version', 'utf8').toLowerCase();
    if (procVersion.includes('microsoft') || procVersion.includes('wsl')) {
      return true;
    }
  } catch (e) {}
  
  try {
    fs.statSync('/mnt/c');
    return true;
  } catch (e) {}
  
  return false;
}
```

**getEffectivePlatform():**
```javascript
function getEffectivePlatform() {
  if (isWSL()) return 'linux';
  return process.platform;
}
```

Use patterns from RESEARCH.md section "Pattern 2: Platform-Specific Path Validation".
  </action>
  <verify>
```bash
# Test Windows validation (simulate)
node -e "const {validatePath} = require('./bin/lib/path-validator');
  const result1 = validatePath('C:\\\\Users\\\\test<file>.txt');
  console.log('Invalid chars:', result1.valid === false && result1.errors.some(e => e.includes('invalid')));
  
  const result2 = validatePath('C:\\\\CON\\\\test');
  console.log('Reserved name:', result2.valid === false);
  
  const longPath = 'C:\\\\' + 'a'.repeat(300);
  const result3 = validatePath(longPath);
  console.log('Long path:', result3.valid === false && result3.errors.some(e => e.includes('260')));
"

# Test Unix validation
node -e "const {validatePath} = require('./bin/lib/path-validator');
  const validPath = '/Users/test/.claude';
  const result1 = validatePath(validPath);
  console.log('Valid Unix path:', result1.valid);
  
  const tooLong = '/Users/' + 'a'.repeat(5000);
  const result2 = validatePath(tooLong);
  console.log('Too long Unix path:', result2.valid === false);
"

# Test WSL detection (note: won't detect on macOS, just verify no crash)
node -e "const {isWSL, getEffectivePlatform} = require('./bin/lib/path-validator');
  console.log('WSL detected:', isWSL());
  console.log('Effective platform:', getEffectivePlatform());
"
```
  </verify>
  <done>
validatePath() returns platform-specific validation errors, WSL detection works, getEffectivePlatform() treats WSL as Linux
  </done>
</task>

<task name="test-path-utilities" type="auto">
  <files>
    bin/lib/paths.test.js (new)
    bin/lib/path-validator.test.js (new)
  </files>
  <action>
Create comprehensive test suites following Phase 2/3 patterns (Jest).

**bin/lib/paths.test.js:**
Test coverage:
- getConfigPaths() with all platforms (claude, copilot, codex)
- getConfigPaths() with scope variations (global, local)
- getConfigPaths() with configDir parameter
- Codex global throws error
- Claude global uses `~/.claude/` (not old path)
- expandTilde() function (preserve existing behavior)
- ensureInstallDir() success case (mock fs-extra.ensureDir)
- ensureInstallDir() permission error (EACCES/EPERM) returns helpful message
- Unknown platform throws error

**bin/lib/path-validator.test.js:**
Test coverage:
- validatePath() on Windows with invalid characters
- validatePath() on Windows with reserved names (CON, PRN, etc)
- validatePath() on Windows with path > 260 chars
- validatePath() on Unix (macOS) with path > 1024 chars
- validatePath() on Unix (Linux) with path > 4096 chars
- validatePath() with valid paths returns {valid: true, errors: []}
- isWSL() detection (mock fs.readFileSync, fs.statSync)
- getEffectivePlatform() returns 'linux' for WSL, platform otherwise

**Mocking patterns:**
Use Jest spies/mocks:
- Mock `process.platform` for Windows/Linux/Darwin tests
- Mock `fs.readFileSync` for WSL /proc/version check
- Mock `fs.statSync` for WSL /mnt/c check
- Mock `fs-extra.ensureDir` for directory creation tests
- Mock `os.homedir()` for predictable home paths

Target: >80% coverage (following Phase 2 decision).
  </action>
  <verify>
```bash
# Run tests
npm test -- bin/lib/paths.test.js bin/lib/path-validator.test.js

# Check coverage
npm test -- --coverage --collectCoverageFrom='bin/lib/paths.js' --collectCoverageFrom='bin/lib/path-validator.js'

# Verify at least 80% coverage for both modules
# Expected: >80% lines, >80% branches
```
  </verify>
  <done>
Test suites pass with >80% coverage for paths.js and path-validator.js, all edge cases covered
  </done>
</task>

## Success Criteria

- [ ] `getConfigPaths()` function signature updated to `(platform, scope, configDir)`
- [ ] Claude global path is `~/.claude/` (breaking change from old path)
- [ ] Copilot global path is `~/.copilot/`
- [ ] Codex local path is `[cwd]/.codex/`
- [ ] Codex global throws clear error "not supported"
- [ ] `--config-dir` parameter creates platform subdirectories in custom location
- [ ] `path-validator.js` validates Windows invalid chars, reserved names, path length
- [ ] `path-validator.js` validates Unix path length limits (1024 macOS, 4096 Linux)
- [ ] WSL detected and treated as Linux (not Windows)
- [ ] `ensureInstallDir()` catches permission errors and suggests `--local` for global failures
- [ ] Test coverage >80% for both modules
- [ ] All verification commands pass

## Output

Updated path resolution utilities ready for Phase 4 Plan 2 (conflict resolution) and Phase 5 (message optimization).

**Next:** Plan 02 will handle conflict detection, old path migration warning, and integration with install.js.
