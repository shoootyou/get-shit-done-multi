---
phase: 06.1-old-version-detection-migration
plan: 02
type: execute
wave: 2
depends_on: [06.1-01]
files_modified: []
files_created:
  - bin/lib/migration/migration-manager.js
  - bin/lib/migration/backup-manager.js
  - tests/unit/migration-manager.test.js
autonomous: true
must_haves:
  observables:
    - backup_created: Automatic backup to [install-dir]/.gsd-backup/YYYY-MM-DD-HHMM/ structure
    - disk_check: Pre-flight disk space validation (10% buffer) prevents backup start
    - atomic_backup: All files backed up or none (partial failures keep partial backup)
    - retry_logic: Failed file copies retry 3 times before failing
    - user_confirm: @clack/prompts confirmation before migration starts
  artifacts:
    - migration-manager.js with user-facing migration flow
    - backup-manager.js with atomic backup operations
    - Unit tests for backup logic
  wiring:
    - Migration manager calls backup manager for operations
    - Reuses validation/pre-install-checks for disk space
    - Reuses io/file-operations for copy/move operations
  key_links:
    - Migration flow integrates with orchestrator pre-checks
    - Backup location consistent with CONTEXT Decision D2.1
---

# Phase 06.1 Plan 02: Migration Manager & Backup Operations

## Objective

Create migration manager that handles user prompts, backup creation, and error recovery for v1.x to v2.0.0 migration. Implements atomic backup with retry logic, disk space pre-checks, and user-friendly messaging.

## Context

**From CONTEXT.md:**
- D1.2: Simple Yes/No confirmation
- D1.3: Show detailed steps before confirmation
- D1.4: Flow timing - Banner → Old version check → Migration → Regular installation
- D2.1: Backup location `[current-folder]/.gsd-backup/YYYY-MM-DD-HHMM/`
- D2.3: Check disk space before backup, abort if insufficient
- D2.4: Completion message - simple confirmation with backup path
- D3.1: Backup fails → abort everything, no changes made
- D3.2: Partial backup → retry 3x, keep partial backup, cancel installation
- D3.3: Migration module INDEPENDENT - separate directory, reuse functions

**From RESEARCH.md:**
- Pattern 2: Atomic Backup with Retry
- Pattern 3: Disk Space Pre-Check (reuse validation/pre-install-checks)
- Pattern 4: Migration Prompts with @clack/prompts
- Reuse existing: fs-extra, @clack/prompts, statfs, logger

**Existing modules to reuse:**
- `bin/lib/validation/pre-install-checks.js` - calculateDirectorySize, checkDiskSpace
- `bin/lib/io/file-operations.js` - copyDirectory, pathExists
- `bin/lib/cli/logger.js` - warn, info, listItem, warnSubtitle
- `bin/lib/errors/install-error.js` - InstallError base

## Tasks

<task id="2.1" type="create">
  <files>bin/lib/migration/backup-manager.js</files>
  <action>
Create backup manager module with atomic backup operations:

**1. createBackupDirectory(oldVersion, targetDir)**
Returns: backup directory path

Format: `${targetDir}/.gsd-backup/YYYY-MM-DD-HHMM/`
- Use current timestamp for folder name
- Create directory recursively with fs-extra ensureDir
- If directory exists (rare edge case), append seconds: `YYYY-MM-DD-HHMM-SS`

**2. validateBackupSpace(sourcePaths, backupDir)**
Returns: void (throws if insufficient)

Reuse existing validation patterns:
```javascript
import { calculateDirectorySize, checkDiskSpace } from '../validation/pre-install-checks.js';

// Calculate total size of all source paths
let totalSize = 0;
for (const path of sourcePaths) {
  if (await pathExists(path)) {
    totalSize += await calculateDirectorySize(path);
  }
}

// Check disk space with 10% buffer
const checkPath = await pathExists(backupDir) 
  ? backupDir 
  : resolve(backupDir, '..');

const warning = await checkDiskSpace(checkPath, totalSize);
if (warning) {
  throw new InstallError(
    'INSUFFICIENT_DISK_SPACE',
    `Backup requires ${(totalSize / 1024 / 1024).toFixed(2)}MB (with 10% buffer), Available: ${(warning.available / 1024 / 1024).toFixed(2)}MB`,
    { recoverable: true }
  );
}
```

**3. copyWithRetry(sourcePath, destPath, options = {})**
Returns: `{ success: boolean, error?: string }`

Implements retry logic per CONTEXT D3.2:
```javascript
const { maxRetries = 3, retryDelay = 1000 } = options;

for (let attempt = 1; attempt <= maxRetries; attempt++) {
  try {
    await copyDirectory(sourcePath, destPath, {
      overwrite: false,
      preserveTimestamps: true,
      errorOnExist: false
    });
    return { success: true };
  } catch (error) {
    if (attempt === maxRetries) {
      return { 
        success: false, 
        error: error.message 
      };
    }
    await new Promise(resolve => setTimeout(resolve, retryDelay));
  }
}
```

**4. createBackup(platform, oldVersion, sourcePaths, targetDir)**
Returns: `{ success: boolean, backupPath: string, failed?: string[] }`

Main backup orchestration:
1. Create backup directory
2. Validate disk space (throw if insufficient)
3. For each source path:
   - If path exists, copy with retry
   - Track failures
4. If any failures after retries:
   - Keep partial backup (don't delete)
   - Return success: false with failed paths
5. If all succeed:
   - Return success: true with backupPath

**Error handling:**
- Wrap in try-catch at top level
- Disk space errors throw (abort before any copies)
- Copy errors return { success: false } (keep partial backup)
- Permission errors throw with clear message

**Imports:**
```javascript
import { ensureDir } from 'fs-extra';
import { copyDirectory, pathExists } from '../io/file-operations.js';
import { calculateDirectorySize, checkDiskSpace } from '../validation/pre-install-checks.js';
import { InstallError } from '../errors/install-error.js';
import { resolve, join, basename } from 'path';
```
  </action>
  <verify>
```bash
# Check file created
ls -lh bin/lib/migration/backup-manager.js

# Check exports
grep "export async function" bin/lib/migration/backup-manager.js
```
  </verify>
  <done>
File bin/lib/migration/backup-manager.js created with createBackupDirectory, validateBackupSpace, copyWithRetry, createBackup functions
  </done>
</task>

<task id="2.2" type="create">
  <files>bin/lib/migration/migration-manager.js</files>
  <action>
Create migration manager with user-facing migration flow:

**1. promptMigration(platform, oldVersion, backupPath, options = {})**
Returns: boolean (user confirmed)

User prompt flow per CONTEXT D1.2, D1.3, D1.4:
```javascript
import * as p from '@clack/prompts';
import * as logger from '../cli/logger.js';

// Show warning banner
console.log();
logger.warnSubtitle('Old Version Detected', 0, 80, true);
logger.warn(`Version ${oldVersion} is incompatible with v2.0.0`, 2);
console.log();

// Show detailed steps (D1.3)
logger.info('What will happen:', 2);
logger.listItem(`Backup v${oldVersion} to ${backupPath}`, 4);
logger.listItem('Remove old files', 4);
logger.listItem('Install v2.0.0', 4);
console.log();

// Simple Yes/No confirmation (D1.2)
const confirmed = await p.confirm({
  message: 'Create backup and upgrade?',
  initialValue: false
});

if (p.isCancel(confirmed)) {
  p.cancel('Installation cancelled.');
  return false;
}

return confirmed;
```

**2. showBackupSuccess(backupPath)**
Returns: void

Completion message per CONTEXT D2.4:
```javascript
console.log();
logger.success(`✓ Backup created: ${backupPath}`);
logger.info('You can delete this manually after verifying the installation.', 2);
console.log();
```

**3. showBackupFailure(error, partialBackupPath = null)**
Returns: void

Error messages per CONTEXT D3.1, D3.2:
```javascript
console.log();
if (partialBackupPath) {
  // Partial backup scenario (D3.2)
  logger.error('⚠ Backup incomplete');
  logger.warn(`Partial backup saved to: ${partialBackupPath}`, 2);
  logger.warn('Installation cancelled. Your old version is unchanged.', 2);
} else {
  // Full failure scenario (D3.1)
  logger.error(`✗ Backup failed: ${error.message}`);
  logger.warn('Your old installation is unchanged.', 2);
  logger.info('Please fix the issue and try again.', 2);
}
console.log();
```

**4. performMigration(platform, oldVersion, targetDir, options = {})**
Returns: `{ success: boolean, backupPath?: string, error?: string }`

Main migration orchestration:
```javascript
// 1. Get old installation paths
const { paths } = await detectOldVersion(platform, targetDir);
if (!paths || paths.length === 0) {
  return { success: false, error: 'No old files found' };
}

// 2. Create backup directory
const backupDir = await createBackupDirectory(oldVersion, targetDir);

// 3. Prompt user (unless skipPrompts)
if (!options.skipPrompts) {
  const confirmed = await promptMigration(platform, oldVersion, backupDir, options);
  if (!confirmed) {
    return { success: false, error: 'User declined' };
  }
}

// 4. Create backup (with disk space check)
const result = await createBackup(platform, oldVersion, paths, targetDir);

// 5. Show result
if (result.success) {
  showBackupSuccess(result.backupPath);
  
  // Remove old files after successful backup
  for (const path of paths) {
    await remove(path);
  }
  
  return { success: true, backupPath: result.backupPath };
} else {
  showBackupFailure(new Error('Copy failed'), result.backupPath);
  return { success: false, error: 'Backup failed', backupPath: result.backupPath };
}
```

**Error handling:**
- Catch disk space errors, show clear message, exit
- Catch permission errors, show actionable guidance
- On Ctrl+C (p.isCancel), exit gracefully with exit code 0

**Imports:**
```javascript
import * as p from '@clack/prompts';
import * as logger from '../cli/logger.js';
import { detectOldVersion } from '../version/old-version-detector.js';
import { createBackupDirectory, validateBackupSpace, createBackup } from './backup-manager.js';
import { remove } from 'fs-extra';
```
  </action>
  <verify>
```bash
# Check file created
ls -lh bin/lib/migration/migration-manager.js

# Check exports
grep "export async function" bin/lib/migration/migration-manager.js

# Verify imports
grep "from" bin/lib/migration/migration-manager.js
```
  </verify>
  <done>
File bin/lib/migration/migration-manager.js created with promptMigration, showBackupSuccess, showBackupFailure, performMigration functions
  </done>
</task>

<task id="2.3" type="test">
  <files>tests/unit/migration-manager.test.js</files>
  <action>
Create unit tests for migration manager:

**Test suites:**

1. **Backup Directory Creation**
   - ✓ Creates .gsd-backup/YYYY-MM-DD-HHMM/ format
   - ✓ Appends seconds if directory exists
   - ✓ Uses targetDir as base (not home directory)

2. **Disk Space Validation**
   - ✓ Throws when insufficient space
   - ✓ Passes when sufficient space (with 10% buffer)
   - ✓ Error message shows required vs available MB

3. **Copy with Retry**
   - ✓ Succeeds on first attempt when copy works
   - ✓ Retries up to 3 times on transient failures
   - ✓ Returns failure after 3 failed attempts
   - ✓ Keeps partial copy on final failure

4. **Create Backup**
   - ✓ Copies all source paths to backup directory
   - ✓ Preserves directory structure
   - ✓ Returns success: true when all files copied
   - ✓ Returns success: false with failed paths on partial failure
   - ✓ Validates disk space before copying

5. **Migration Flow**
   - ✓ Prompts user with detailed steps
   - ✓ Creates backup on user confirmation
   - ✓ Removes old files after successful backup
   - ✓ Keeps old files on backup failure
   - ✓ Exits gracefully on user decline
   - ✓ Skips prompts when skipPrompts: true

6. **Error Messages**
   - ✓ Shows backup success message with path
   - ✓ Shows backup failure with clear guidance
   - ✓ Shows partial backup warning with path
   - ✓ Shows disk space error with MB values

**Test fixtures:**
Create v1.x structures in /tmp for testing:
```javascript
// /tmp/gsd-test-{timestamp}/
//   .claude/get-shit-done/VERSION
//   .claude/commands/gsd/test.md
```

Mock @clack/prompts for confirmation testing

**Assertions:**
- Verify backup directory created with correct name format
- Verify all files present in backup after copy
- Verify old files removed after successful migration
- Verify error messages contain actionable guidance
  </action>
  <verify>
```bash
# Run tests
npm test -- migration-manager.test.js

# Check coverage
npm test -- --coverage migration-manager.test.js
```
  </verify>
  <done>
Tests pass, migration flow validated, error scenarios covered, disk space checks working
  </done>
</task>

## Verification Criteria

- [ ] Backup manager created in `bin/lib/migration/backup-manager.js`
- [ ] Migration manager created in `bin/lib/migration/migration-manager.js`
- [ ] Backup directory format: `.gsd-backup/YYYY-MM-DD-HHMM/`
- [ ] Disk space pre-check prevents backup start if insufficient
- [ ] Retry logic: 3 attempts per file with 1s delay
- [ ] Partial backups kept (not deleted) on failure
- [ ] User prompts use @clack/prompts with clear messaging
- [ ] Old files removed only after successful backup
- [ ] Unit tests pass with >90% coverage

## Success Criteria

**Observable:**
1. Running performMigration shows warning, prompts user, creates backup, removes old files
2. Insufficient disk space shows clear error before backup starts
3. Partial backup failure keeps partial files, shows paths of failed files
4. User declining migration exits gracefully with exit code 0

**Technical:**
1. Reuses existing validation/pre-install-checks for disk space
2. Reuses existing io/file-operations for copy operations
3. Reuses existing cli/logger for user messages
4. No new dependencies added

## Output

- `bin/lib/migration/backup-manager.js` - Atomic backup operations
- `bin/lib/migration/migration-manager.js` - User-facing migration flow
- `tests/unit/migration-manager.test.js` - Comprehensive unit tests
- Migration logic ready for integration in Wave 2
