# Phase 6.1: Old Version Detection & Migration - Research

**Researched:** 2026-01-28  
**Domain:** File migration, backup operations, version detection  
**Confidence:** HIGH

## Summary

This research covers the implementation approach for detecting and migrating incompatible v1.x installations to v2.0.0. The standard stack uses existing dependencies (fs-extra, @clack/prompts, Node.js statfs), with an independent migration module that reuses but doesn't modify existing functions.

**Primary recommendation:** Use existing file-operations patterns, implement atomic backup with retry logic, leverage statfs for disk space checks (Node 19+), and create user-friendly migration prompts with @clack/prompts.

## Investigation Summary

Analyzed `/tmp/gsd-test-200/` which contains version 1.8.0 installations across all three platforms.

## Old Version Structure (v1.8.0)

### Platform-Specific Structures

#### CLAUDE (.claude/)
- **Commands:** `.claude/commands/gsd/*.md` (30+ command files)
- **Agents:** `.claude/agents/gsd-*.md` (11 agent files, NO .agent.md suffix)
- **Hooks:** `.claude/hooks/` (3 files: gsd-check-update.js, pre-commit-docs, statusline.js)
- **Settings:** `.claude/settings.json` (hooks configuration)
- **Shared:** `.claude/get-shit-done/` (VERSION, references/, templates/, workflows/)
- **Key marker:** `.claude/get-shit-done/VERSION` contains "1.8.0"

#### COPILOT (.github/)
- **Skills:** `.github/skills/get-shit-done/` (monolithic skill structure)
- **Agents:** `.github/agents/gsd-*.agent.md` (11 agent files, WITH .agent.md suffix)
- **Issue Templates:** `.github/ISSUE_TEMPLATE/gsd-new-project.yml`
- **Instructions:** `.github/copilot-instructions.md`
- **Commands:** `.github/skills/get-shit-done/commands/gsd/*.md`
- **Shared:** `.github/skills/get-shit-done/` (VERSION, references/, templates/, workflows/)
- **Key marker:** `.github/skills/get-shit-done/VERSION` contains "1.8.0"

#### CODEX (.codex/)
- **Skills:** `.codex/skills/get-shit-done/` (monolithic skill structure)
- **Commands:** `.codex/skills/get-shit-done/commands/gsd/*.md`
- **Shared:** `.codex/skills/get-shit-done/` (VERSION, references/, templates/, workflows/)
- **Key marker:** `.codex/skills/get-shit-done/VERSION` contains "1.8.0"

## New Version Structure (v2.0.0)

### Platform-Agnostic Templates
- **Skills:** `templates/skills/gsd-*/` (individual skill directories)
- **Agents:** `templates/agents/gsd-*.agent.md` (13 agent files)
- **Shared:** `templates/get-shit-done/` (references/, templates/)
- **Versioning:** Each skill has `version.json`, agents have `versions.json`

### Key Differences

| Aspect | Old (v1.x) | New (v2.x) |
|--------|-----------|------------|
| **Skill Structure** | Monolithic `get-shit-done/` with all commands | Individual `gsd-*` skill directories |
| **VERSION Location** | Single `VERSION` file in root | `version.json` per skill + `versions.json` for agents |
| **Agent Naming** | Claude: `gsd-*.md`, Others: `gsd-*.agent.md` | All: `gsd-*.agent.md` |
| **Claude Hooks** | 3 hooks in `.claude/hooks/` | No hooks (removed) |
| **Commands Location** | Inside monolithic skill | Each command is a separate skill |
| **Issue Templates** | `.github/ISSUE_TEMPLATE/gsd-*.yml` | None (removed?) |

## Detection Strategy for Old Versions

### Detection Points

1. **Monolithic Skill Check:**
   - Copilot: `.github/skills/get-shit-done/SKILL.md` exists
   - Codex: `.codex/skills/get-shit-done/SKILL.md` exists
   - Claude: `.claude/commands/gsd/` directory exists

2. **Single VERSION File:**
   - Copilot: `.github/skills/get-shit-done/VERSION` exists
   - Codex: `.codex/skills/get-shit-done/VERSION` exists
   - Claude: `.claude/get-shit-done/VERSION` exists

3. **Claude-Specific Hooks:**
   - `.claude/hooks/gsd-check-update.js` exists
   - `.claude/hooks/statusline.js` exists
   - `.claude/settings.json` references these hooks

4. **Old Agent Naming (Claude only):**
   - Files like `.claude/agents/gsd-planner.md` (without .agent.md suffix)

### Detection Logic

```javascript
// Pseudo-code for detection
async function isOldVersion(platform, targetDir) {
  const checks = {
    claude: [
      exists(`${targetDir}/.claude/get-shit-done/VERSION`),
      exists(`${targetDir}/.claude/commands/gsd/`),
      exists(`${targetDir}/.claude/hooks/gsd-check-update.js`)
    ],
    copilot: [
      exists(`${targetDir}/.github/skills/get-shit-done/SKILL.md`),
      exists(`${targetDir}/.github/skills/get-shit-done/VERSION`)
    ],
    codex: [
      exists(`${targetDir}/.codex/skills/get-shit-done/SKILL.md`),
      exists(`${targetDir}/.codex/skills/get-shit-done/VERSION`)
    ]
  };
  
  // If ANY check is true, it's an old version
  return checks[platform].some(check => check === true);
}
```

## Impact & Scope

### Why This Matters

1. **Breaking Changes:** Structure completely different, can't merge
2. **Update Flow:** Must detect and warn user before attempting update
3. **Migration Required:** Old installations need full reinstall or migration
4. **User Experience:** Silent failure or corruption if not detected

### Affected Components

- `bin/lib/version/installation-finder.js` - Must detect old structure
- `bin/lib/updater/check-update.js` - Must warn about incompatibility
- `bin/lib/updater/update-messages.js` - Need special message for old versions

---

## Standard Stack

The migration module uses existing dependencies from the codebase:

### Core Libraries
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| fs-extra | ^11.3.3 | File operations (copy, move, remove) | Already used throughout codebase, provides atomic operations and error handling |
| @clack/prompts | ^0.11.0 | Interactive prompts | Already used for interactive mode, provides beautiful CLI UX |
| Node.js statfs | Built-in (Node 19+) | Disk space checking | Native API, no external dependencies, precise space calculation |
| semver | ^7.7.3 | Version parsing/comparison | Already used for version checks |

### Supporting Utilities
| Module | Purpose | When to Use |
|--------|---------|-------------|
| `bin/lib/io/file-operations.js` | Reusable file ops with error handling | All file copy/move/remove operations |
| `bin/lib/cli/logger.js` | Consistent message formatting | All user-facing messages |
| `bin/lib/errors/install-error.js` | Typed errors with exit codes | Permission denied, insufficient space errors |
| `bin/lib/validation/pre-install-checks.js` | Disk space validation patterns | Reuse `calculateDirectorySize()` and `checkDiskSpace()` |

### Installation
No new packages required - all dependencies already in package.json:
```bash
# Already installed:
npm list fs-extra @clack/prompts semver
```

**Critical constraint:** Migration module MUST NOT modify existing modules. Can import and call their functions, but cannot change their behavior.

---

## Architecture Patterns

### Recommended Project Structure
```
bin/lib/migration/
├── old-version-detector.js   # Detection logic for v1.x structures
├── backup-manager.js          # Atomic backup operations
└── migration-prompts.js       # User-facing migration UX

bin/lib/version/
└── old-version-detector.js    # (Alternative: could live here with other version tools)
```

**Decision D3.3 from CONTEXT:** Migration module is INDEPENDENT
- Separate directory: `bin/lib/migration/`
- Can REUSE existing functions via import
- Cannot MODIFY existing modules
- Must not interfere with regular installation behavior

### Pattern 1: Independent Migration Module

**What:** Migration logic isolated from core installation, integrated via orchestrator pre-checks

**When to use:** Any optional pre-installation flow that shouldn't affect core installation behavior

**Structure:**
```javascript
// bin/lib/migration/backup-manager.js
import { copyDirectory, pathExists } from '../io/file-operations.js';
import { calculateDirectorySize, checkDiskSpace } from '../validation/pre-install-checks.js';

// Reuses existing functions, doesn't modify them
export async function createBackup(sourcePaths, backupDir, options = {}) {
  // 1. Calculate total size (reuse existing)
  const totalSize = await calculateDirectorySize(sourcePaths[0]);
  
  // 2. Check disk space (reuse existing)
  const spaceWarning = await checkDiskSpace(backupDir, totalSize);
  if (spaceWarning) throw insufficientSpace(spaceWarning);
  
  // 3. Create backup directory
  await ensureDirectory(backupDir);
  
  // 4. Copy files atomically with retry
  for (const sourcePath of sourcePaths) {
    await copyWithRetry(sourcePath, backupDir, options);
  }
}
```

**Integration point:**
```javascript
// bin/lib/installer/orchestrator.js
export async function install(appVersion, options) {
  // === NEW: Old version migration check ===
  const oldVersionDetected = await detectOldVersion(platform, targetDir);
  if (oldVersionDetected.isOld) {
    const migrated = await promptAndMigrate(oldVersionDetected, options);
    if (!migrated) {
      // User declined, exit cleanly
      process.exit(0);
    }
  }
  
  // === EXISTING: Version validation gate ===
  await validateVersionBeforeInstall(platform, targetDir, appVersion, { skipPrompts });
  
  // ... rest of installation continues
}
```

### Pattern 2: Atomic Backup with Retry

**What:** Copy files with retry logic, keep partial backup on failure instead of deleting

**When to use:** Migration operations where partial state is safer than no state

**Implementation:**
```javascript
// Source: Derived from existing copyDirectory pattern in file-operations.js

async function copyWithRetry(src, dest, options = {}) {
  const { maxRetries = 3, retryDelay = 1000 } = options;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // Use existing copyDirectory function
      await copyDirectory(src, dest, {
        overwrite: false, // Don't overwrite in backup
        preserveTimestamps: true,
        errorOnExist: false
      });
      return { success: true };
    } catch (error) {
      if (attempt === maxRetries) {
        // Final failure - keep partial backup
        return { 
          success: false, 
          error: error.message,
          partialBackup: dest 
        };
      }
      
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, retryDelay));
    }
  }
}
```

### Pattern 3: Disk Space Pre-Check

**What:** Validate sufficient disk space BEFORE starting backup operation

**When to use:** Any operation that copies large amounts of data

**Implementation:**
```javascript
// Reuse existing validation/pre-install-checks.js patterns

import { statfs } from 'fs';
import { promisify } from 'util';
const statfsPromise = promisify(statfs);

async function validateBackupSpace(sourcePaths, backupDir) {
  // 1. Calculate total size of source files
  let totalSize = 0;
  for (const path of sourcePaths) {
    totalSize += await calculateDirectorySize(path);
  }
  
  // 2. Check available space with 10% buffer (matches existing pattern)
  const checkPath = await pathExists(backupDir) 
    ? backupDir 
    : resolve(backupDir, '..');
  
  const stats = await statfsPromise(checkPath);
  const availableBytes = stats.bavail * stats.bsize;
  const requiredWithBuffer = Math.ceil(totalSize * 1.1);
  
  if (availableBytes < requiredWithBuffer) {
    throw insufficientSpace(
      'Insufficient disk space for backup',
      {
        required: requiredWithBuffer,
        available: availableBytes,
        requiredMB: (requiredWithBuffer / 1024 / 1024).toFixed(2),
        availableMB: (availableBytes / 1024 / 1024).toFixed(2)
      }
    );
  }
}
```

**Key insight:** Use `statfs` (Node 19+) for accurate space checking. Fallback gracefully for older Node versions (show warning but allow operation).

### Pattern 4: Migration Prompts with @clack/prompts

**What:** User-friendly migration confirmation using existing prompt library

**When to use:** Any destructive operation requiring user confirmation

**Implementation:**
```javascript
// bin/lib/migration/migration-prompts.js
import * as p from '@clack/prompts';
import * as logger from '../cli/logger.js';

export async function promptMigration(platform, oldVersion, backupPath) {
  // Show intro with clear warning
  console.log();
  logger.warnSubtitle('Old Version Detected', 0, 80, true);
  logger.warn(`Version ${oldVersion} is incompatible with v2.0.0`, 2);
  console.log();
  
  // Show what will happen (Decision D1.3)
  logger.info('What will happen:', 2);
  logger.listItem(`Backup v${oldVersion} to ${backupPath}`, 4);
  logger.listItem('Remove old files', 4);
  logger.listItem('Install v2.0.0', 4);
  console.log();
  
  // Simple Yes/No confirmation (Decision D1.2)
  const confirmed = await p.confirm({
    message: 'Create backup and upgrade?',
    initialValue: false
  });
  
  if (p.isCancel(confirmed)) {
    p.cancel('Installation cancelled.');
    return false;
  }
  
  return confirmed;
}
```

**UX pattern:** Always show WHAT will happen before asking for confirmation. Use logger functions for consistency with existing CLI output.

### Anti-Patterns to Avoid

- **Don't modify existing modules:** Migration module imports from `file-operations.js` but doesn't change its behavior
- **Don't silently delete on failure:** Keep partial backups, let user decide (Decision D3.2)
- **Don't mix async patterns:** Use async/await throughout, avoid Promise.then chains
- **Don't hardcode paths:** Use path resolution functions from existing modules

---

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| File operations with error handling | Custom fs.copyFile wrappers | `bin/lib/io/file-operations.js` | Already handles EACCES, EPERM, ENOSPC with proper error types |
| Disk space checking | Manual stat() or df parsing | Node.js `statfs()` via `validation/pre-install-checks.js` | Native API, accurate, handles Node version fallback |
| Directory size calculation | fs.readdir + fs.stat loops | `calculateDirectorySize()` from validation module | Already implemented, handles recursive traversal |
| Interactive prompts | console.log + readline | `@clack/prompts` | Beautiful UX, handles Ctrl+C, consistent with existing flows |
| Version comparison | String splitting and parsing | `semver` library | Handles all edge cases, already in dependencies |
| Error types with exit codes | Throwing generic Error | `bin/lib/errors/install-error.js` | Typed errors, proper exit codes, consistent error handling |
| Logger formatting | Chalk directly | `bin/lib/cli/logger.js` | Consistent styling, proper indentation, icon handling |

**Key insight:** The codebase already has robust patterns for file operations, validation, and UX. Reuse these instead of creating migration-specific versions.

---

## Common Pitfalls

### Pitfall 1: Assuming Backup Always Succeeds
**What goes wrong:** Partial file copy fails, backup incomplete, then source files deleted
**Why it happens:** Not checking individual file operation results
**How to avoid:** 
- Check disk space BEFORE starting (Pattern 3)
- Use try/catch on each file operation
- Keep failed/partial backups (Decision D3.2)
- Never delete source until backup fully verified

**Warning signs:**
```javascript
// BAD: Assumes copy succeeds
await copyDirectory(src, backup);
await fs.remove(src); // DANGER: What if copy failed?

// GOOD: Verify then delete
const result = await copyWithRetry(src, backup);
if (result.success) {
  await fs.remove(src);
} else {
  throw new Error(`Backup incomplete: ${result.error}`);
}
```

### Pitfall 2: Insufficient Disk Space Detection Too Late
**What goes wrong:** Start copying files, run out of space mid-operation, leave corrupt backup
**Why it happens:** Not checking available space before starting operation
**How to avoid:**
- Use `statfs()` to get precise available space (Node 19+)
- Calculate total source size first
- Add 10% buffer for filesystem overhead
- Fail fast with clear error message

**Warning signs:**
- ENOSPC errors during copy operations
- Partial backups with no warning
- User confusion about why backup failed

**Implementation:**
```javascript
// Check space FIRST
await validateBackupSpace(sourcePaths, backupDir);

// THEN start copying
await createBackup(sourcePaths, backupDir);
```

### Pitfall 3: Modifying Existing Modules
**What goes wrong:** Migration changes break regular installation behavior
**Why it happens:** Adding parameters or logic to shared functions for migration use case
**How to avoid:** (Decision D3.3)
- Keep migration module completely separate
- Import functions from existing modules but don't modify them
- If shared function needs changes, discuss with team first
- Use wrapper functions in migration module instead

**Warning signs:**
- Adding `isMigration` parameters to existing functions
- Changing error handling behavior based on caller
- Modifying file-operations.js for migration-specific needs

### Pitfall 4: Not Handling Ctrl+C Gracefully
**What goes wrong:** User presses Ctrl+C, leaves corrupted state
**Why it happens:** No cleanup handlers for interruption
**How to avoid:** (Decision D3.5)
- Accept that Ctrl+C causes immediate exit
- Design operations to be resumable or safe to abandon
- Don't try to cleanup on SIGINT - accept partial state
- Document that partial backups are kept (user deletes manually)

**Implementation:**
```javascript
// @clack/prompts handles Ctrl+C automatically
const confirmed = await p.confirm({ message: 'Continue?' });
if (p.isCancel(confirmed)) {
  p.cancel('Installation cancelled.');
  process.exit(0); // Clean exit
}
```

### Pitfall 5: Timestamp Collision in Backup Paths
**What goes wrong:** Multiple migrations in same minute overwrite each other
**Why it happens:** Using only date/time without seconds or milliseconds
**How to avoid:**
- Use format: `YYYY-MM-DD-HHMMss` (include seconds)
- Check if directory exists, append counter if collision
- Document timestamp format clearly

**Implementation:**
```javascript
function generateBackupPath(baseDir, version) {
  const timestamp = new Date()
    .toISOString()
    .replace(/[:.]/g, '-')
    .slice(0, 19); // YYYY-MM-DDTHH-MM-SS
  
  const backupName = `v${version}-${timestamp}`;
  return join(baseDir, '.gsd-backup', backupName);
}
```

### Pitfall 6: Not Preserving File Permissions
**What goes wrong:** Backup succeeds but restored files lose execute bits or ownership
**Why it happens:** Default fs.copy() doesn't preserve permissions
**How to avoid:**
- Use fs-extra's `preserveTimestamps: true` option
- Verify backup preserves executable scripts
- Test restore on different OS (Windows vs Unix permissions differ)

**Implementation:**
```javascript
// Use existing pattern from file-operations.js
await fs.copy(src, dest, {
  overwrite: false,
  errorOnExist: false,
  preserveTimestamps: true, // KEY: Preserve permissions
});
```

---

## Code Examples

Verified patterns from existing codebase and proposed migration implementations:

### Example 1: Old Version Detection
```javascript
// bin/lib/migration/old-version-detector.js
import { join } from 'path';
import { pathExists, readFile } from '../io/file-operations.js';

/**
 * Detect if target directory contains old v1.x installation
 * @param {string} platform - Platform name (claude/copilot/codex)
 * @param {string} targetDir - Installation target directory
 * @returns {Promise<{isOld: boolean, version: string|null, paths: string[]}>}
 */
export async function detectOldVersion(platform, targetDir) {
  const markers = getDetectionMarkers(platform, targetDir);
  
  // Check primary marker (VERSION file)
  if (await pathExists(markers.versionFile)) {
    const version = await readOldVersion(markers.versionFile);
    const paths = await getOldInstallationPaths(platform, targetDir);
    
    return {
      isOld: true,
      version,
      paths
    };
  }
  
  // Check secondary markers (structure indicators)
  for (const marker of markers.secondary) {
    if (await pathExists(marker)) {
      return {
        isOld: true,
        version: 'unknown',
        paths: await getOldInstallationPaths(platform, targetDir)
      };
    }
  }
  
  return { isOld: false, version: null, paths: [] };
}

/**
 * Get detection markers for each platform
 */
function getDetectionMarkers(platform, targetDir) {
  const markers = {
    claude: {
      versionFile: join(targetDir, '.claude/get-shit-done/VERSION'),
      secondary: [
        join(targetDir, '.claude/commands/gsd/'),
        join(targetDir, '.claude/hooks/gsd-check-update.js')
      ]
    },
    copilot: {
      versionFile: join(targetDir, '.github/skills/get-shit-done/VERSION'),
      secondary: [
        join(targetDir, '.github/skills/get-shit-done/SKILL.md')
      ]
    },
    codex: {
      versionFile: join(targetDir, '.codex/skills/get-shit-done/VERSION'),
      secondary: [
        join(targetDir, '.codex/skills/get-shit-done/SKILL.md')
      ]
    }
  };
  
  return markers[platform];
}

/**
 * Read version from old VERSION file
 */
async function readOldVersion(versionFilePath) {
  try {
    const content = await readFile(versionFilePath);
    return content.trim();
  } catch (error) {
    return 'unknown';
  }
}
```

### Example 2: Atomic Backup with Retry
```javascript
// bin/lib/migration/backup-manager.js
import { join, dirname } from 'path';
import { copyDirectory, ensureDirectory, pathExists } from '../io/file-operations.js';
import { calculateDirectorySize, checkDiskSpace } from '../validation/pre-install-checks.js';
import { insufficientSpace } from '../errors/install-error.js';
import * as logger from '../cli/logger.js';

/**
 * Create atomic backup with retry logic
 * Decision D2.1: Backup location in same directory as installation
 * Decision D3.2: Keep partial backups on failure
 */
export async function createBackup(sourcePaths, version, targetDir, options = {}) {
  const { maxRetries = 3, retryDelay = 1000 } = options;
  
  // 1. Generate backup path with timestamp
  const backupDir = generateBackupPath(targetDir, version);
  
  // 2. Calculate total size needed (reuse existing function)
  logger.verbose('Calculating backup size...', 2, options.isVerbose);
  let totalSize = 0;
  for (const sourcePath of sourcePaths) {
    if (await pathExists(sourcePath)) {
      totalSize += await calculateDirectorySize(sourcePath);
    }
  }
  
  // 3. Check disk space (reuse existing function)
  logger.verbose(`Backup requires ${(totalSize / 1024 / 1024).toFixed(2)}MB`, 2, options.isVerbose);
  const parentDir = dirname(backupDir);
  const spaceWarning = await checkDiskSpace(parentDir, totalSize);
  if (spaceWarning) {
    throw insufficientSpace(`Cannot create backup: ${spaceWarning}`);
  }
  
  // 4. Create backup directory
  await ensureDirectory(backupDir);
  logger.success(`Backup directory created: ${backupDir}`, 2);
  
  // 5. Copy files with retry logic
  const results = [];
  for (const sourcePath of sourcePaths) {
    if (!await pathExists(sourcePath)) continue;
    
    const destPath = join(backupDir, sourcePath);
    const result = await copyWithRetry(sourcePath, destPath, maxRetries, retryDelay);
    results.push({ source: sourcePath, ...result });
    
    if (result.success) {
      logger.verbose(`✓ Backed up: ${sourcePath}`, 2, options.isVerbose);
    } else {
      logger.warn(`✗ Failed to backup: ${sourcePath} - ${result.error}`, 2);
    }
  }
  
  // 6. Check if all files backed up successfully
  const failedFiles = results.filter(r => !r.success);
  if (failedFiles.length > 0) {
    // Decision D3.2: Keep partial backup
    logger.warn(`Backup incomplete: ${results.length - failedFiles.length}/${results.length} files backed up`, 2);
    logger.warn(`Partial backup saved to: ${backupDir}`, 2);
    throw new Error(`Backup incomplete (${failedFiles.length} files failed)`);
  }
  
  logger.success(`All files backed up successfully`, 2);
  return backupDir;
}

/**
 * Copy file/directory with retry logic
 */
async function copyWithRetry(src, dest, maxRetries, retryDelay) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // Use existing copyDirectory function with correct options
      await copyDirectory(src, dest, {
        overwrite: false,
        errorOnExist: false,
        preserveTimestamps: true
      });
      
      return { success: true, attempts: attempt };
    } catch (error) {
      if (attempt === maxRetries) {
        return {
          success: false,
          error: error.message,
          attempts: attempt
        };
      }
      
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, retryDelay));
    }
  }
}

/**
 * Generate backup path with timestamp
 * Decision D2.1: [current-folder]/.gsd-backup/YYYY-MM-DD-HHMM/
 */
function generateBackupPath(targetDir, version) {
  const now = new Date();
  const timestamp = now.toISOString()
    .slice(0, 16) // YYYY-MM-DDTHH:MM
    .replace('T', '-')
    .replace(':', ''); // YYYY-MM-DD-HHMM
  
  const backupName = `${timestamp}`;
  return join(targetDir, '.gsd-backup', backupName);
}
```

### Example 3: Migration Prompt Flow
```javascript
// bin/lib/migration/migration-prompts.js
import * as p from '@clack/prompts';
import * as logger from '../cli/logger.js';
import { basename } from 'path';

/**
 * Show migration warning and get user confirmation
 * Decisions D1.1, D1.2, D1.3: User-friendly, simple Yes/No, show detailed steps
 */
export async function promptMigration(platform, oldVersion, backupPath, options = {}) {
  // Decision D1.4: Migration prompt happens early in flow
  console.log();
  logger.warnSubtitle('Old Version Detected', 0, 80, true);
  
  // Decision D1.1: User-friendly tone (not technical)
  logger.warn(`Version ${oldVersion} detected (incompatible with v2.0.0)`, 2);
  logger.info('Your installation needs to be upgraded', 2);
  console.log();
  
  // Decision D1.3: Show detailed steps
  logger.info('What will happen:', 2);
  logger.listItem(`Backup v${oldVersion} to ${basename(backupPath)}`, 4);
  logger.listItem('Remove old files', 4);
  logger.listItem('Install v2.0.0', 4);
  console.log();
  
  // Decision D2.4: Simple completion message
  logger.info('After installation, you can manually delete the backup if everything works', 2);
  console.log();
  
  // Decision D1.2: Simple Yes/No confirmation
  const confirmed = await p.confirm({
    message: 'Create backup and upgrade?',
    initialValue: false
  });
  
  // Handle Ctrl+C (Decision D3.5)
  if (p.isCancel(confirmed)) {
    p.cancel('Installation cancelled.');
    return false;
  }
  
  return confirmed;
}

/**
 * Show backup completion message
 * Decision D2.4: Simple confirmation with manual deletion instructions
 */
export function showBackupComplete(backupPath) {
  console.log();
  logger.success(`Backup created: ${backupPath}`, 2);
  logger.info('You can delete this manually after verifying the installation', 2);
  console.log();
  
  // Decision D3.4: Simple transition message
  logger.info('Old version backed up. Now ready to install latest version.', 2);
  console.log();
}

/**
 * Show migration error message
 * Decision D3.1: Clear error, preserve old installation
 */
export function showMigrationError(error, oldVersion) {
  console.log();
  logger.errorSubtitle('Migration Failed', 0, 80, true);
  logger.error(`Backup failed: ${error.message}`, 2);
  logger.info(`Your v${oldVersion} installation is unchanged`, 2);
  
  // Show recovery steps based on error type
  if (error.code === 'ENOSPC') {
    logger.info('Please free up disk space and try again', 2);
  } else if (error.code === 'EACCES' || error.code === 'EPERM') {
    logger.info('Please check file permissions and try again', 2);
  } else {
    logger.info('Please fix the issue and try again', 2);
  }
  console.log();
}
```

### Example 4: Integration with Orchestrator
```javascript
// bin/lib/installer/orchestrator.js (modifications)
import { detectOldVersion } from '../migration/old-version-detector.js';
import { createBackup } from '../migration/backup-manager.js';
import { promptMigration, showBackupComplete, showMigrationError } from '../migration/migration-prompts.js';

export async function install(appVersion, options) {
  const { platform, adapter, isGlobal, isVerbose, scriptDir, targetDir: targetDirOverride, skipPrompts } = options;
  
  // Determine target directory
  const targetBase = adapter.getTargetDir(isGlobal);
  const targetDir = targetDirOverride || (isGlobal
    ? join(homedir(), targetBase.replace('~/', ''))
    : targetBase);
  
  // === NEW: Old version detection and migration (Decision D1.4) ===
  const oldVersionResult = await detectOldVersion(platform, targetDir);
  
  if (oldVersionResult.isOld) {
    logger.blockTitle('Migration Required', { style: 'double', width: 50 });
    
    // Generate backup path
    const backupPath = generateBackupPath(targetDir, oldVersionResult.version);
    
    // Prompt user (skip if -y flag used)
    const confirmed = skipPrompts || await promptMigration(
      platform,
      oldVersionResult.version,
      backupPath,
      { isVerbose }
    );
    
    if (!confirmed) {
      // User declined migration (Decision D1.2)
      logger.info('Installation cancelled', 2);
      logger.info('v1.x is incompatible with v2.0.0', 2);
      process.exit(0);
    }
    
    try {
      // Create backup (Decisions D2.1, D2.3, D3.2)
      await createBackup(
        oldVersionResult.paths,
        oldVersionResult.version,
        targetDir,
        { isVerbose, maxRetries: 3 }
      );
      
      // Show completion (Decision D2.4, D3.4)
      showBackupComplete(backupPath);
      
      // Remove old files (only after successful backup)
      for (const oldPath of oldVersionResult.paths) {
        await fs.remove(oldPath);
      }
      
    } catch (error) {
      // Migration failed (Decision D3.1)
      showMigrationError(error, oldVersionResult.version);
      process.exit(1);
    }
  }
  
  // === EXISTING: Version validation gate ===
  await validateVersionBeforeInstall(platform, targetDir, appVersion, { skipPrompts });
  
  // ... rest of installation continues normally
}
```

---

## UX Best Practices

User experience patterns for migration prompts using @clack/prompts:

### Practice 1: Progressive Disclosure
**What:** Show information in order of importance, don't overwhelm user
**Pattern:**
```
1. Warning header (what's wrong)
2. Brief explanation (why it matters)
3. Detailed steps (what will happen)
4. Confirmation prompt (user decision)
```

**Implementation:**
```javascript
// 1. Header
logger.warnSubtitle('Old Version Detected', 0, 80, true);

// 2. Explanation
logger.warn(`Version ${oldVersion} detected (incompatible with v2.0.0)`, 2);
logger.info('Your installation needs to be upgraded', 2);

// 3. Steps
logger.info('What will happen:', 2);
logger.listItem('Backup old version', 4);
logger.listItem('Install new version', 4);

// 4. Confirmation
const confirmed = await p.confirm({ message: 'Continue?' });
```

### Practice 2: Consistent Logger Usage
**What:** Use logger functions from cli/logger.js for all migration messages
**Why:** Maintains visual consistency with rest of installer

**Logger function mapping:**
| Purpose | Function | When to Use |
|---------|----------|-------------|
| Warnings | `logger.warn()` | Non-fatal issues, old version detected |
| Errors | `logger.error()` | Fatal problems, migration failed |
| Info | `logger.info()` | Explanatory text, recovery steps |
| Success | `logger.success()` | Completed operations |
| Subtitles | `logger.warnSubtitle()` | Section headers for warnings |
| Lists | `logger.listItem()` | Bullet points in steps |

### Practice 3: Path Display
**What:** Show relative or basename of paths, not full absolute paths
**Why:** Reduces visual clutter, focuses on important part

**Implementation:**
```javascript
import { basename, relative } from 'path';

// BAD: /Users/john/project/.gsd-backup/2026-01-28-1400/
// GOOD: .gsd-backup/2026-01-28-1400/

const displayPath = relative(process.cwd(), backupPath);
logger.success(`Backup created: ${displayPath}`, 2);
```

### Practice 4: Error Recovery Guidance
**What:** Always tell user what to do next when operation fails
**Why:** Prevents user frustration, provides clear action steps

**Pattern:**
```javascript
// Always include recovery steps
logger.error(`Backup failed: ${error.message}`, 2);

// Specific guidance based on error type
if (error.code === 'ENOSPC') {
  logger.info('Free up disk space and try again', 2);
} else if (error.code === 'EACCES') {
  logger.info('Check file permissions or run with elevated privileges', 2);
} else {
  logger.info('Fix the issue and run installer again', 2);
}
```

### Practice 5: Confirm Before Destructive Operations
**What:** Always get explicit user confirmation before deleting or overwriting files
**Why:** Builds trust, prevents accidental data loss

**Implementation:**
```javascript
// Show WHAT will happen BEFORE asking
logger.info('What will happen:', 2);
logger.listItem('Old files will be backed up', 4);
logger.listItem('Old files will be deleted', 4); // CLEAR about deletion

// Then ask for confirmation
const confirmed = await p.confirm({
  message: 'Continue?',
  initialValue: false // Default to safe choice
});
```

### Practice 6: Graceful Ctrl+C Handling
**What:** Let @clack/prompts handle Ctrl+C, show cancellation message, exit cleanly
**Why:** User expects Ctrl+C to abort immediately

**Implementation:**
```javascript
const confirmed = await p.confirm({ message: 'Continue?' });

// @clack/prompts returns special cancel symbol on Ctrl+C
if (p.isCancel(confirmed)) {
  p.cancel('Installation cancelled.');
  process.exit(0); // Clean exit, not error
}
```

---

## Integration Patterns

How migration module integrates with existing codebase:

### Integration Point 1: Orchestrator Pre-Check
**Location:** `bin/lib/installer/orchestrator.js`
**Timing:** Before version validation, before any file operations
**Pattern:**
```javascript
export async function install(appVersion, options) {
  // ... setup targetDir ...
  
  // NEW: Old version check (earliest point)
  const oldVersion = await detectOldVersion(platform, targetDir);
  if (oldVersion.isOld) {
    await handleMigration(oldVersion, targetDir, options);
  }
  
  // EXISTING: Version validation
  await validateVersionBeforeInstall(...);
  
  // ... rest of installation ...
}
```

### Integration Point 2: Interactive Mode
**Location:** `bin/lib/cli/interactive.js`
**Timing:** After banner, before platform/scope selection
**Pattern:**
```javascript
export async function runInteractive(appVersion, options) {
  p.intro('Interactive Installer');
  
  // NEW: Early migration check for all scopes
  await checkAndMigrateAllScopes(options);
  
  // EXISTING: Detect platforms
  const detected = await detectBinaries();
  
  // ... rest of interactive flow ...
}
```

### Integration Point 3: Check-Updates Flow
**Location:** `bin/lib/updater/check-update.js`
**Timing:** During installation discovery
**Pattern:**
```javascript
// When checking for updates, detect old versions
const installations = await findInstallations(scope, customPaths);

for (const install of installations) {
  // NEW: Check if it's an old v1.x installation
  const oldVersion = await detectOldVersion(install.platform, install.path);
  if (oldVersion.isOld) {
    // Show incompatibility warning instead of update available
    showIncompatibilityWarning(install.platform, oldVersion.version);
    continue;
  }
  
  // EXISTING: Regular version check
  const version = await getInstalledVersion(install.path);
  // ... compare versions ...
}
```

**Key principle:** Migration checks happen EARLY in flow, before any destructive operations, and exit cleanly if user declines.

---

## State of the Art

Current approaches to file migration and backup in Node.js ecosystem (2025):

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual df/du parsing | Node.js `statfs()` API | Node 19.0 (2022-10) | Native disk space checks, no child_process |
| Custom copy loops | fs-extra `copy()` with options | fs-extra 10+ | Built-in retry, permissions, atomic operations |
| readline for prompts | @clack/prompts | 2023 | Beautiful UX, Ctrl+C handling, consistent styling |
| String version comparison | semver library | Industry standard | Handles pre-release, build metadata, ranges |

**Deprecated/outdated:**
- **child_process exec('df'):** Replaced by statfs() in Node 19+, no need for shell parsing
- **fs.copyFile() loops:** Replaced by fs-extra's recursive copy with options
- **Inquirer.js:** Largely replaced by @clack/prompts for new projects (better UX)

---

## Open Questions

Things that need validation during implementation:

1. **Backup Verification**
   - What we know: Copy operations return success/failure
   - What's unclear: Should we verify backup integrity (checksum)?
   - Recommendation: Trust fs-extra copy operations, add optional verification flag

2. **Multiple Platforms in Same Scope**
   - What we know: User might have v1.x on Copilot AND Codex in same directory
   - What's unclear: Single confirmation for all, or per-platform?
   - Recommendation: Single confirmation with list of platforms (Decision D4.2)

3. **Node Version Fallback**
   - What we know: statfs() requires Node 19+, package.json says >=16.7.0
   - What's unclear: What happens on Node 16-18?
   - Recommendation: Show warning, proceed without disk check (allow operation)

4. **Windows Path Lengths**
   - What we know: Windows has MAX_PATH (260 chars) limitation
   - What's unclear: Will deeply nested backup paths exceed this?
   - Recommendation: Test on Windows, add path length validation if needed

---

## Sources

### Primary (HIGH confidence)
- **Existing codebase:**
  - `bin/lib/io/file-operations.js` - File operation patterns
  - `bin/lib/validation/pre-install-checks.js` - Disk space checking with statfs
  - `bin/lib/cli/interactive.js` - @clack/prompts usage patterns
  - `bin/lib/cli/logger.js` - Logger function patterns
  - `bin/lib/errors/install-error.js` - Error types and exit codes

- **Package.json dependencies:**
  - fs-extra@11.3.3 - Official npm registry
  - @clack/prompts@0.11.0 - Official npm registry
  - semver@7.7.3 - Official npm registry

- **Node.js documentation:**
  - statfs() API - Node.js v19+ documentation
  - fs module - Node.js official docs

### Secondary (MEDIUM confidence)
- **CONTEXT.md decisions:** 17 specific decisions from /gsd-discuss-phase session
- **Existing RESEARCH.md:** Old vs new structure analysis, detection markers

### Tertiary (LOW confidence)
- None - all findings verified against existing codebase or official documentation

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All dependencies already in package.json, verified by npm list
- Architecture: HIGH - Based on existing codebase patterns and CONTEXT.md decisions
- Pitfalls: MEDIUM - Derived from common Node.js file operation issues, not migration-specific
- UX practices: HIGH - Based on existing @clack/prompts usage in interactive.js
- Integration: HIGH - Exact integration points specified in CONTEXT.md

**Research date:** 2026-01-28  
**Valid until:** 2026-02-28 (30 days - stable dependencies, no fast-moving tech)

**Node.js version:** 25.4.0 (local environment)  
**Package versions:** Verified from package.json and npm list output
