---
phase: 05.1-codebase-architecture-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - analysis-unused-deps.txt
  - analysis-unused-files.txt
  - analysis-circular-deps.txt
  - analysis-dep-tree.txt
  - baseline-coverage.txt
autonomous: true
must_haves:
  - codebase: Analysis tools installed (depcheck, unimported, madge, dependency-cruiser)
  - codebase: Baseline test coverage recorded with line counts and percentages
  - codebase: Unused npm dependencies identified in analysis-unused-deps.txt
  - codebase: Unused source files identified in analysis-unused-files.txt
  - codebase: Circular dependencies identified in analysis-circular-deps.txt
  - codebase: Complete dependency tree mapped from install.js entry point
  - planning: Clear list of files to remove (strict audit - not in dep tree)
  - quality: Zero circular dependencies or plan to fix each one
---

# Phase 5.1 Plan 01: Codebase Audit & Dependency Analysis

## Objective

Establish baseline state and identify cleanup targets using mature npm ecosystem tools. Generate comprehensive analysis of unused files, circular dependencies, and dependency tree to inform restructuring decisions.

## Context

**Current state:**
- 1800 LOC install.js with mixed organization
- Files scattered across bin/lib/ with unclear structure
- Coverage/ directory tracked in git (should be ignored)
- Tests in both __tests__/ and bin/lib/ (needs unification)
- Dependencies potentially outdated

**What we're doing:**
- Install analysis tools (depcheck, unimported, madge, dependency-cruiser)
- Run comprehensive analysis to identify cleanup targets
- Establish baseline metrics (test coverage, file count)
- Create data-driven removal plan

**Why this first:**
Cannot safely restructure without knowing:
- Which files are actually used (dependency tree)
- Which dependencies are needed
- Where circular dependencies exist
- Current test coverage baseline

## Tasks

<task name="install-analysis-tools" type="auto">
  <files>package.json</files>
  <action>
Install mature ecosystem analysis tools as dev dependencies:

```bash
npm install --save-dev depcheck@1.4.7 unimported@1.31.1 madge@8.0.0 dependency-cruiser@17.3.7 npm-check-updates@19.3.1
```

**Tools purpose:**
- depcheck: Find unused npm packages in package.json
- unimported: Find unused source files (not in dependency tree)
- madge: Dependency graph visualization + circular detection
- dependency-cruiser: Advanced architecture validation
- npm-check-updates: Aggressive dependency update workflow (for Wave 3)

Verify installation:
```bash
npx depcheck --version
npx unimported --version
npx madge --version
npx depcruise --version
npx ncu --version
```
  </action>
  <verify>
```bash
# All tools should show version numbers
npm list depcheck unimported madge dependency-cruiser npm-check-updates --depth=0
```
  </verify>
  <done>Analysis tools installed and verified in package.json devDependencies</done>
</task>

<task name="establish-baseline" type="auto">
  <files>baseline-coverage.txt, .git/</files>
  <action>
Establish baseline state before any changes:

```bash
# 1. Commit current state (checkpoint)
git add -A
git commit -m "chore: checkpoint before phase 5.1 optimization"

# 2. Capture baseline test coverage
npm test -- --coverage > baseline-coverage.txt 2>&1

# 3. Record file count
echo "=== File Count Baseline ===" >> baseline-coverage.txt
find bin/ lib-ghcc/ -type f -name "*.js" | wc -l >> baseline-coverage.txt
echo "" >> baseline-coverage.txt
find bin/ lib-ghcc/ -type f -name "*.js" >> baseline-coverage.txt
```

This creates recovery point and metrics for comparison.
  </action>
  <verify>
```bash
# Baseline file should contain:
# - Jest test results (passing count)
# - Coverage percentages
# - File list
grep -E "(Tests:.*passed|% Stmts|% Branch|% Funcs|% Lines)" baseline-coverage.txt
```
  </verify>
  <done>Baseline test results and coverage captured in baseline-coverage.txt with git checkpoint created</done>
</task>

<task name="analyze-dependencies" type="auto">
  <files>analysis-unused-deps.txt, analysis-dep-tree.txt</files>
  <action>
Analyze npm dependencies and dependency tree:

```bash
# 1. Find unused npm packages
npx depcheck > analysis-unused-deps.txt 2>&1

# 2. Map complete dependency tree from install.js entry point
echo "=== Dependency Tree from install.js ===" > analysis-dep-tree.txt
npx madge --depends install.js bin/ lib-ghcc/ >> analysis-dep-tree.txt 2>&1

echo "" >> analysis-dep-tree.txt
echo "=== All file dependencies ===" >> analysis-dep-tree.txt
npx madge --list bin/ lib-ghcc/ >> analysis-dep-tree.txt 2>&1

# 3. Check for outdated packages (for Wave 3 planning)
npm outdated > analysis-outdated-before.txt 2>&1 || true
```

**Output interpretation:**
- analysis-unused-deps.txt: npm packages safe to remove
- analysis-dep-tree.txt: files reachable from install.js (keep these)
- analysis-outdated-before.txt: packages needing updates
  </action>
  <verify>
```bash
# Check analysis files exist and have content
ls -lh analysis-unused-deps.txt analysis-dep-tree.txt analysis-outdated-before.txt
wc -l analysis-*.txt
```
  </verify>
  <done>Dependency analysis complete with unused packages and complete dependency tree documented</done>
</task>

<task name="find-unused-files" type="auto">
  <files>analysis-unused-files.txt</files>
  <action>
Find unused source files using static analysis:

```bash
# 1. Run unimported to find files not in dependency tree
npx unimported > analysis-unused-files.txt 2>&1 || true

# 2. Cross-reference with our manual dependency tree
echo "" >> analysis-unused-files.txt
echo "=== Files NOT in madge dependency tree ===" >> analysis-unused-files.txt

# Get all JS files
find bin/ lib-ghcc/ -type f -name "*.js" | sort > all-files-temp.txt

# Get files in dependency tree
grep -oE "(bin|lib-ghcc)/[^ ]+" analysis-dep-tree.txt | sort -u > dep-tree-files-temp.txt

# Find difference
comm -23 all-files-temp.txt dep-tree-files-temp.txt >> analysis-unused-files.txt

# Cleanup temp files
rm all-files-temp.txt dep-tree-files-temp.txt

# 3. Flag test files separately (keep all tests for now)
echo "" >> analysis-unused-files.txt
echo "=== Test files (review separately) ===" >> analysis-unused-files.txt
find bin/ lib-ghcc/ __tests__/ -name "*.test.js" >> analysis-unused-files.txt
```

**Manual review required:** Not all "unused" files are safe to delete (entry points, test utilities, scripts).
  </action>
  <verify>
```bash
# Should show unused files categorized
cat analysis-unused-files.txt | grep -E "(bin/|lib-ghcc/)" | head -20
```
  </verify>
  <done>Unused files identified and categorized with test files flagged separately for review</done>
</task>

<task name="detect-circular-dependencies" type="auto">
  <files>analysis-circular-deps.txt</files>
  <action>
Detect circular dependencies (MUST be fixed before restructuring):

```bash
# 1. Find circular dependencies
echo "=== Circular Dependencies ===" > analysis-circular-deps.txt
npx madge --circular bin/ lib-ghcc/ >> analysis-circular-deps.txt 2>&1

# 2. Generate dependency graph visualization (before state)
npx madge --image architecture-before.png bin/lib/ 2>&1 || echo "Graph generation failed (non-critical)"

# 3. Count circular dependencies
CIRCULAR_COUNT=$(grep -c "bin\|lib-ghcc" analysis-circular-deps.txt || echo "0")
echo "" >> analysis-circular-deps.txt
echo "Total circular dependencies found: $CIRCULAR_COUNT" >> analysis-circular-deps.txt

if [ "$CIRCULAR_COUNT" -gt 0 ]; then
  echo "⚠️  FOUND $CIRCULAR_COUNT CIRCULAR DEPENDENCIES - MUST FIX IN WAVE 2" >> analysis-circular-deps.txt
else
  echo "✓ No circular dependencies found" >> analysis-circular-deps.txt
fi
```

**Critical:** Circular dependencies MUST be resolved before restructuring.
  </action>
  <verify>
```bash
# Check circular dependency status
tail -5 analysis-circular-deps.txt
```
  </verify>
  <done>Circular dependencies detected and documented with count and resolution plan</done>
</task>

## Verification

After completion, verify these observable truths:

1. **Tools installed:** `npm list depcheck unimported madge --depth=0` shows all analysis tools
2. **Baseline captured:** baseline-coverage.txt contains test results with coverage percentages
3. **Dependencies analyzed:** analysis-unused-deps.txt lists unused npm packages
4. **Files analyzed:** analysis-unused-files.txt lists files not in dependency tree
5. **Circular deps detected:** analysis-circular-deps.txt shows count (may be 0)
6. **Dependency tree mapped:** analysis-dep-tree.txt shows files reachable from install.js
7. **Git checkpoint:** `git log -1` shows "checkpoint before phase 5.1" commit

## Success Criteria

- ✅ All analysis tools installed (5 packages)
- ✅ Baseline test coverage recorded with exact percentages
- ✅ Complete dependency tree mapped from install.js entry point
- ✅ Unused npm dependencies identified (may be 0)
- ✅ Unused source files identified (may be 0) 
- ✅ Circular dependencies detected and counted (may be 0)
- ✅ Git checkpoint created for rollback safety
- ✅ All analysis files committed for reference

## Output Files

Generated artifacts for Wave 2 planning:

```
baseline-coverage.txt           # Test baseline (coverage %, test count)
analysis-unused-deps.txt        # npm packages safe to remove
analysis-unused-files.txt       # Source files safe to remove (after review)
analysis-circular-deps.txt      # Circular deps to fix (may be empty)
analysis-dep-tree.txt          # Complete dependency graph
analysis-outdated-before.txt   # Packages needing updates (Wave 3)
architecture-before.png        # Visualization of current structure
```

These files inform all Wave 2 decisions: what to remove, what to fix, what to preserve.
