---
phase: 05-simple-command-migration
plan: 05
type: execute
wave: 3
depends_on: [05-01, 05-02, 05-03, 05-04]
files_modified:
  - specs/skills/gsd-verify-work/SKILL.md
  - specs/skills/gsd-discuss-phase/SKILL.md
  - .claude/skills/gsd-verify-work.md (generated)
  - .claude/skills/gsd-discuss-phase.md (generated)
autonomous: true
must_haves:
  goal: "Migrate verification suite commands with subagent spawning and workflow file references"
  truths:
    - Two spec folders exist for verification commands
    - verify-work spawns gsd-debugger and gsd-planner for UAT gap handling
    - discuss-phase references workflow file for adaptive questioning
    - Both commands create planning artifacts (UAT.md, CONTEXT.md)
    - Spawning logic preserves exact patterns from Phase 4 commands
    - Both commands generate and install successfully
  artifacts:
    - specs/skills/gsd-verify-work/SKILL.md
    - specs/skills/gsd-discuss-phase/SKILL.md
  wiring:
    - verify-work spawns gsd-debugger when issues found
    - verify-work spawns gsd-planner when gaps need closure
    - discuss-phase references workflows/discuss-phase.md via @-reference
    - discuss-phase uses context.md template for CONTEXT.md creation
  key_links:
    - verify-work UAT workflow → spawns debugger/planner → creates UAT.md
    - discuss-phase workflow → adaptive questions → creates CONTEXT.md
---

# Phase 5 Plan 05: Batch 5 - Verification Suite

**Objective:** Migrate verification suite commands (verify-work, discuss-phase) that spawn subagents or reference workflow files for complex user interactions

## Context

**From Research (05-RESEARCH.md):**
- **verify-work**: 219 lines, spawns gsd-debugger + gsd-planner for UAT orchestration
- **discuss-phase**: 80 lines, references workflow file for adaptive questioning
- **Complexity**: MEDIUM-HIGH (subagent spawning, workflow file delegation)
- **Pattern**: Similar to Phase 4 commands (research-phase, map-codebase)

**Commands in batch:**
1. **gsd-verify-work** (219 lines) - UAT orchestration with issue triage
2. **gsd-discuss-phase** (80 lines) - Pre-planning phase discussion

**Why Wave 3:**
- Depends on Waves 1-2 providing foundation commands
- Independent of milestone lifecycle (05-06) and progress (05-08)
- Can run in parallel with 05-06 and 05-07

**Spawning dependencies (all exist):**
- gsd-debugger (✓ migrated in Phase 4)
- gsd-planner (✓ migrated in Phase 4)

## Tasks

<task name="verify-workflow-files" type="auto">
  <files>None (read-only verification)</files>
  <action>
Verify workflow files exist for discuss-phase command.

Check for workflow file:
```bash
# Check if workflow files exist at expected paths
find ~/.claude/get-shit-done/workflows/ -name "discuss-phase.md" 2>/dev/null
find ~/.claude/get-shit-done/templates/ -name "context.md" 2>/dev/null

# If not found, check alternative locations
find . -path "*/workflows/discuss-phase.md" 2>/dev/null
find . -path "*/templates/context.md" 2>/dev/null
```

If workflow files are missing:
- Check legacy commands/gsd/discuss-phase.md for @-reference paths
- Document correct paths for spec creation
- Note: Workflow files should exist in installed GSD (Phase 2 established this pattern)
  </action>
  <verify>Workflow files found and paths documented</verify>
  <done>Workflow file paths confirmed for discuss-phase spec</done>
</task>

<task name="migrate-verify-work-command" type="auto">
  <files>specs/skills/gsd-verify-work/SKILL.md</files>
  <action>
Create gsd-verify-work spec from legacy commands/gsd/verify-work.md (219 lines).

Frontmatter:
```yaml
name: gsd-verify-work
description: Orchestrate UAT testing, triage issues, spawn debugger or planner as needed
skill_version: 1.9.1
requires_version: 1.9.0+
platforms: [claude, copilot, codex]
tools:
  - name: read
  - name: write
  - name: bash
  - name: task
arguments:
  - name: phase
    type: integer
    required: true
    description: Phase number to verify
```

Body structure:
```xml
<objective>
Run User Acceptance Testing on completed phase. Guide human through testing 
flows, triage issues, then route to debugger (if bugs) or planner (if gaps).

Purpose: Validate phase goal achievement from user perspective before marking 
phase complete.
</objective>

<process>
<step name="load_phase_context">
Load phase directory, SUMMARY files, phase goal from roadmap.
Understand what was built and what needs verification.
</step>

<step name="check_existing_uat">
Check for existing {phase}-XX-UAT.md files.
If exists with status "diagnosed": offer to resume or start fresh.
</step>

<step name="generate_test_scenarios">
Based on phase goal and SUMMARYs:
1. Derive 3-5 test scenarios (user perspective)
2. For each scenario: steps to test, expected outcome
3. Present test plan to user for confirmation
</step>

<step name="guide_testing">
For each test scenario:
1. Present test steps clearly
2. Ask: "What happened? (success / issue / unclear)"
3. If issue: capture detailed description, reproduction steps
4. If unclear: provide clarification, retry
</step>

<step name="triage_issues">
If issues found:
- Categorize: bug (behavior broken) vs gap (feature missing)
- Assess severity: blocker / major / minor
</step>

<step name="route_to_resolution">
Based on triage:

If bugs found:
```javascript
task({
  agent_type: "gsd-debugger",
  description: "Debug UAT issues",
  prompt: `
<issues>
${issueDescriptions}
</issues>

<context>
Phase ${phase} completed. UAT revealed issues.
Load SUMMARYs and investigate root causes.
</context>

<objective>
Create DEBUG.md session with reproduction steps and investigation strategy.
</objective>
  `
})
```

If gaps found (missing features):
```javascript
task({
  agent_type: "gsd-planner", 
  description: "Plan gap closure",
  prompt: `
<gaps>
${gapDescriptions}
</gaps>

<context>
Phase ${phase} UAT revealed missing features.
Create plans to address gaps.
</context>

<objective>
Create gap closure plans using --gaps flag pattern.
</objective>
  `
})
```

If all passed:
Write UAT.md with status: passed, no further action needed.
</step>

<step name="write_uat_report">
Create .planning/phases/{phase}-*/{phase}-XX-UAT.md:

```yaml
---
phase: {phase}
tested: {timestamp}
status: {passed|diagnosed}
severity: {blocker|major|minor|none}
---

## Test Scenarios

{scenarios with results}

## Issues Found

{issues with triage}

## Next Steps

{route to debugger/planner/complete}
```
</step>

<step name="commit">
```bash
git add .planning/phases/{phase}-*/{phase}-*-UAT.md
git commit -m "test(${phase}): UAT ${status}"
```
</step>
</process>
```

**Critical elements:**
- Spawning pattern matches Phase 4 (research-phase, map-codebase)
- Task tool invocation with agent_type parameter
- Separate routes for bugs (debugger) vs gaps (planner)
- UAT.md creation with structured frontmatter
- Status field drives progress routing
  </action>
  <verify>
Test spec creation and generation:
```bash
# Create spec
cat specs/skills/gsd-verify-work/SKILL.md

# Generate skill
npm run install:local

# Verify output
ls -la .claude/skills/gsd-verify-work.md

# Check spawning logic preserved
grep -A 10 "agent_type.*gsd-debugger" .claude/skills/gsd-verify-work.md
grep -A 10 "agent_type.*gsd-planner" .claude/skills/gsd-verify-work.md
```
  </verify>
  <done>gsd-verify-work spec exists with dual spawning logic intact</done>
</task>

<task name="migrate-discuss-phase-command" type="auto">
  <files>specs/skills/gsd-discuss-phase/SKILL.md</files>
  <action>
Create gsd-discuss-phase spec from legacy commands/gsd/discuss-phase.md (80 lines).

Frontmatter:
```yaml
name: gsd-discuss-phase
description: Pre-planning discussion to extract implementation decisions
skill_version: 1.9.1
requires_version: 1.9.0+
platforms: [claude, copilot, codex]
tools:
  - name: read
  - name: write
  - name: bash
arguments:
  - name: phase
    type: integer
    required: true
    description: Phase number to discuss
```

Body structure:
```xml
<objective>
Extract implementation decisions that downstream agents need - researcher 
and planner will use CONTEXT.md to know what to investigate and what 
choices are locked.

Purpose: Lock in architectural decisions before research/planning begins.
Output: {phase}-XX-CONTEXT.md with essential features and boundaries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/discuss-phase.md
@~/.claude/get-shit-done/templates/context.md
</execution_context>

<process>
<step name="validate_phase">
Validate phase number argument.
Check if phase exists in ROADMAP.md.
Error if phase not found.
</step>

<step name="check_existing_context">
Check for existing CONTEXT.md in phase directory.

If exists:
- Display current content
- Offer: "Update / View only / Skip"
- If Update: proceed with discussion
- If View: display and exit
- If Skip: exit
</step>

<step name="follow_workflow">
Follow detailed workflow in workflows/discuss-phase.md:

1. Analyze phase goal and identify domain
2. Generate phase-specific "gray areas" (tech choices, scope, approach)
3. Present gray areas as multi-select (which to discuss?)
4. For each selected area:
   - Ask 4 adaptive questions
   - Dig deeper based on answers
   - Offer "Ask more / Next area"
5. Synthesize discussion into CONTEXT.md sections
</step>

<step name="write_context_file">
Use template from templates/context.md.

Create .planning/phases/{phase}-*/{phase}-XX-CONTEXT.md:

```yaml
---
phase: {phase}
discussed: {timestamp}
areas: [{list of discussed areas}]
---

## Essential Features

{Must-have features user specified}

## Technical Boundaries

{Locked decisions: libraries, patterns, architecture}

## Scope Limits

{Explicitly out of scope items}

## Open Questions

{Things to investigate during research}
```
</step>

<step name="commit">
```bash
git add .planning/phases/{phase}-*/{phase}-*-CONTEXT.md
git commit -m "docs(${phase}): capture context from discussion"
```
</step>

<step name="offer_next">
Present next steps:
- "Ready to research? Run: /gsd:research-phase {phase}"
- "Skip research? Run: /gsd:plan-phase {phase}"
</step>
</process>
```

**Critical elements:**
- @-references to workflow and template files (paths from task 1)
- Workflow file delegation pattern (references external file for detailed logic)
- Adaptive questioning flow (handled by workflow file)
- CONTEXT.md creation with frontmatter
- Next step routing to research or planning
  </action>
  <verify>
Test spec creation and generation:
```bash
# Create spec
cat specs/skills/gsd-discuss-phase/SKILL.md

# Generate skill
npm run install:local

# Verify output
ls -la .claude/skills/gsd-discuss-phase.md

# Check @-references preserved
grep "@~/.claude/get-shit-done/workflows/discuss-phase.md" .claude/skills/gsd-discuss-phase.md
grep "@~/.claude/get-shit-done/templates/context.md" .claude/skills/gsd-discuss-phase.md
```
  </verify>
  <done>gsd-discuss-phase spec exists with workflow file references preserved</done>
</task>

<task name="test-generated-skills" type="auto">
  <files>None (testing only)</files>
  <action>
Test both generated skills install and basic structure is correct.

```bash
# Verify both skills generated
ls -la .claude/skills/gsd-verify-work.md
ls -la .claude/skills/gsd-discuss-phase.md

# Check file sizes (should be substantial)
wc -l .claude/skills/gsd-verify-work.md  # Expect ~200+ lines
wc -l .claude/skills/gsd-discuss-phase.md  # Expect ~80+ lines

# Verify spawning preserved in verify-work
echo "=== Checking gsd-verify-work spawning ==="
grep -c "agent_type" .claude/skills/gsd-verify-work.md  # Should be 2 (debugger + planner)

# Verify workflow references in discuss-phase
echo "=== Checking gsd-discuss-phase @-references ==="
grep -c "@~/.claude/get-shit-done/" .claude/skills/gsd-discuss-phase.md  # Should be 2

# Run basic syntax check (no obvious errors)
node -e "
const fs = require('fs');
const verifyWork = fs.readFileSync('.claude/skills/gsd-verify-work.md', 'utf8');
const discuss = fs.readFileSync('.claude/skills/gsd-discuss-phase.md', 'utf8');

console.log('verify-work frontmatter:', verifyWork.split('---')[1].substring(0, 100));
console.log('discuss-phase frontmatter:', discuss.split('---')[1].substring(0, 100));
console.log('Both skills have valid structure');
"
```
  </action>
  <verify>Both generated files exist with correct spawning/references</verify>
  <done>verify-work and discuss-phase generated successfully</done>
</task>

## Verification

**After execution:**
- [ ] Two spec folders exist: specs/skills/gsd-verify-work/, specs/skills/gsd-discuss-phase/
- [ ] Both specs have complete frontmatter (name, description, tools, arguments)
- [ ] verify-work spawning logic intact (gsd-debugger for bugs, gsd-planner for gaps)
- [ ] discuss-phase @-references preserved (workflow file, template file)
- [ ] Both skills generate successfully via npm run install:local
- [ ] Generated files exist in .claude/skills/ with substantial content

## Success Criteria

**Observable truths:**
1. verify-work command can orchestrate UAT testing with user
2. verify-work routes correctly to debugger or planner based on triage
3. verify-work creates UAT.md with proper frontmatter and status
4. discuss-phase command guides adaptive questioning
5. discuss-phase creates CONTEXT.md from discussion
6. Both commands install and are discoverable

**Key deliverable:** Two verification suite commands migrated with complex patterns (spawning, workflow delegation) preserved from Phase 4 patterns.

## Output

Files created:
- `specs/skills/gsd-verify-work/SKILL.md` - UAT orchestration with spawning
- `specs/skills/gsd-discuss-phase/SKILL.md` - Pre-planning discussion with workflow reference
- `.claude/skills/gsd-verify-work.md` - Generated skill (200+ lines)
- `.claude/skills/gsd-discuss-phase.md` - Generated skill (80+ lines)

Ready for: Wave 4 (progress hub migration after all commands exist)
