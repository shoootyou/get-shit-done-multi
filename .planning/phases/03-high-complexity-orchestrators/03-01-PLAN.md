---
phase: 03-high-complexity-orchestrators
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md
autonomous: true
must_haves:
  goal: "Audit all cross-command dependencies and @-references before migration"
  truths:
    - File DEPENDENCY-AUDIT.md exists documenting all 76 @-references across commands
    - Bidirectional dependencies mapped (X spawns Y, Z references X's output)
    - Commands grouped by dependency clusters identified
    - Migration risk assessment completed for each orchestrator
    - @-reference validation script exists and runs without errors
  artifacts:
    - .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md
    - scripts/validate-references.sh (validation script)
  wiring:
    - Audit identifies which commands must migrate together
    - Risk scores inform migration order within Phase 3
  key_links:
    - 03-DEPENDENCY-AUDIT.md findings → 03-02/03-03 plan execution order
---

# Phase 3 Plan 01: Dependency Audit

**Objective:** Document all cross-command dependencies, @-references, and orchestration relationships before migration to prevent breakage

## Context

Phase 3 migrates the three most complex orchestrators (new-project, new-milestone, execute-phase) that spawn 4-14 subagents each and use extensive @-references. Research (03-RESEARCH.md) found 76 @-references across legacy commands pointing to templates, references, and planning artifacts.

**Critical insight from research:** Commands don't just spawn subagents—they reference each other's outputs. Example: `plan-phase` reads `ROADMAP.md` created by `new-project`. Breaking these links during migration would cascade failures.

**From Research (03-RESEARCH.md Pitfall 4):**
- "Miss cross-command @-references, migration breaks dependent commands"
- "Grep for command name across all commands"
- "Check for indirect references via files"
- "Document bidirectional dependencies: X spawns Y, Z references X's output"

## Tasks

<task name="audit-at-references" type="auto">
  <files>.planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md</files>
  <action>
Create comprehensive audit of all @-references across GSD commands.

**1. Scan for @-references:**
```bash
# Find all @-references in legacy commands
grep -rn "@" commands/gsd/*.md > /tmp/at-references.txt

# Count by command
for cmd in commands/gsd/*.md; do
  count=$(grep -c "@" "$cmd" 2>/dev/null || echo 0)
  echo "$cmd: $count references"
done | sort -t: -k2 -rn > /tmp/reference-counts.txt
```

**2. Categorize references by type:**
- Template references: `@~/.claude/get-shit-done/templates/*.md`
- Reference files: `@~/.claude/get-shit-done/references/*.md`
- Planning artifacts: `@.planning/*.md`
- Phase artifacts: `@.planning/phases/*/*.md`
- Research outputs: `@.planning/research/*.md`

**3. Identify critical paths for Phase 3 orchestrators:**

For each target command (new-project, new-milestone, execute-phase):
- Which templates does it @-reference?
- Which reference files does it load?
- Which planning artifacts does it read/write?
- Which subagents does it spawn?
- Which commands depend on ITS outputs?

**4. Document in DEPENDENCY-AUDIT.md:**

Structure:
```markdown
# Dependency Audit: Phase 3 Orchestrators

## Summary
- Total @-references found: {N}
- Commands with @-references: {N}/29
- Template files referenced: {list}
- Reference files referenced: {list}

## By Command

### gsd-new-project
**@-references (count: X):**
- Templates: [list with line numbers]
- References: [list with line numbers]
- Artifacts: [list with line numbers]

**Spawns subagents:**
- gsd-project-researcher (4 parallel)
- gsd-research-synthesizer (1)
- gsd-roadmapper (1)

**Creates artifacts:**
- .planning/PROJECT.md
- .planning/REQUIREMENTS.md
- .planning/ROADMAP.md
- .planning/STATE.md
- .planning/research/*.md (4 files)

**Consumed by:**
- gsd-plan-phase (reads ROADMAP.md, STATE.md)
- gsd-execute-phase (reads ROADMAP.md)
- gsd-progress (reads STATE.md)

[Repeat for new-milestone, execute-phase]

## Dependency Graph

```
new-project → creates → PROJECT.md, ROADMAP.md, STATE.md
                ↓
         plan-phase (reads)
                ↓
         execute-phase (reads + spawns executors)
```

## Migration Risk Assessment

| Command | Risk | Reason |
|---------|------|--------|
| new-project | HIGH | Creates foundational artifacts, 14 spawns, 4 @-refs |
| execute-phase | MEDIUM | Wave-based spawning, reads plans |
| new-milestone | MEDIUM | Similar to new-project but simpler |

## Validation Script

[Include script to validate @-references exist]
```
  </action>
  <verify>
```bash
# Verify audit file exists and has required sections
test -f .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md

# Check for key sections
grep -q "## Summary" .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md
grep -q "## By Command" .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md
grep -q "## Dependency Graph" .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md
grep -q "## Migration Risk Assessment" .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md

# Verify it documents all three target commands
grep -q "gsd-new-project" .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md
grep -q "gsd-new-milestone" .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md
grep -q "gsd-execute-phase" .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md
```
  </verify>
  <done>
- Audit file exists with complete analysis
- All @-references documented with line numbers
- Subagent spawning patterns documented
- Artifact creation/consumption mapped
- Dependency graph visualized
  </done>
</task>

<task name="create-validation-script" type="auto">
  <files>scripts/validate-references.sh</files>
  <action>
Create validation script that checks @-references exist before migration.

```bash
#!/bin/bash
# Validate @-references in legacy commands before migration

set -e

ERRORS=0

echo "Validating @-references in commands..."

# Extract @-references and check existence
grep -rh "@" commands/gsd/*.md | grep -oE "@[~.][^[:space:]]*" | sort -u | while read ref; do
  # Remove @ prefix
  path="${ref#@}"
  
  # Expand ~ if present
  if [[ "$path" == ~/* ]]; then
    path="${path/#\~/$HOME}"
  fi
  
  # Check if file exists
  if [ ! -f "$path" ]; then
    echo "❌ Missing: $ref"
    ((ERRORS++))
  fi
done

if [ $ERRORS -eq 0 ]; then
  echo "✅ All @-references valid"
  exit 0
else
  echo "❌ Found $ERRORS missing references"
  exit 1
fi
```

Make executable:
```bash
chmod +x scripts/validate-references.sh
```

Test it:
```bash
./scripts/validate-references.sh
```
  </action>
  <verify>
```bash
# Verify script exists and is executable
test -x scripts/validate-references.sh

# Run it (may have warnings but shouldn't error fatally)
bash scripts/validate-references.sh || echo "Script executed with findings"
```
  </verify>
  <done>
- Validation script exists and is executable
- Script checks all @-references for existence
- Script provides clear pass/fail output
- Script returns appropriate exit codes
  </done>
</task>

<task name="identify-parallel-safe-migrations" type="auto">
  <files>.planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md</files>
  <action>
Add section to audit identifying which migrations can happen in parallel.

Analyze dependency graph to determine:
1. **execute-phase dependencies:** Does it depend on new-project/new-milestone being migrated first?
2. **Shared @-references:** Do commands share templates that might be affected?
3. **Subagent dependencies:** Can we migrate orchestrator before migrating its subagents?

Add section to DEPENDENCY-AUDIT.md:

```markdown
## Parallel Migration Feasibility

### Wave 1 Candidates (No dependencies on each other)
- execute-phase: Reads plans created by planner (not in Phase 3), safe to migrate independently
- [Analysis for others]

### Sequential Requirements
- If new-project is migrated, new-milestone should follow (similar patterns)
- Orchestrators can migrate before their subagents (subagents are separate specs)

### Recommendation
Wave 1: execute-phase (simplest orchestrator, no creation dependencies)
Wave 2: new-project + new-milestone (can parallelize if no shared artifacts)
```
  </action>
  <verify>
```bash
# Verify parallel migration analysis exists
grep -q "## Parallel Migration Feasibility" .planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md
```
  </verify>
  <done>
- Parallel migration feasibility analyzed
- Wave recommendations documented
- Shared dependency risks identified
- Migration order rationale clear
  </done>
</task>

## Verification

```bash
# Complete audit validation
.planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md exists
scripts/validate-references.sh runs successfully
Audit documents all three target commands
Risk assessment complete with scores
Parallel migration strategy documented
```

## Success Criteria

- [x] DEPENDENCY-AUDIT.md exists with comprehensive analysis
- [x] All 76 @-references documented with locations
- [x] Bidirectional dependencies mapped (spawner → spawnee, creator → consumer)
- [x] Subagent spawning patterns documented for all three orchestrators
- [x] Validation script exists and runs
- [x] Parallel migration strategy identified
- [x] Risk assessment completed

## Output

**Created:**
- `.planning/phases/03-high-complexity-orchestrators/03-DEPENDENCY-AUDIT.md` - Complete dependency analysis
- `scripts/validate-references.sh` - Reference validation tool

**Technical notes:**
- Audit informs migration order in plans 03-02 and 03-03
- Validation script reusable for future phases
- Bidirectional mapping prevents cascading failures
