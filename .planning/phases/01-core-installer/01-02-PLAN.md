---
phase: 01-core-installer
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified:
  - bin/lib/templates/template-loader.js
  - bin/lib/templates/template-renderer.js
  - bin/lib/templates/template-validator.js
  - bin/lib/installer/installer.js
  - bin/install.js
autonomous: true
must_haves:
  observables:
    - Run `npx get-shit-done-multi --claude` → skills install to ~/.claude/skills/
    - Template variables {{PLATFORM_ROOT}}, {{VERSION}}, {{COMMAND_PREFIX}}, {{INSTALL_DATE}}, {{USER}} replaced correctly
    - `--help` shows usage information with available flags
    - `--version` shows version and detected installations
  artifacts:
    - bin/lib/templates/template-renderer.js (regex-based {{VAR}} replacement)
    - bin/lib/templates/template-loader.js (loads from templates/)
    - bin/lib/installer/installer.js (orchestrates installation)
    - bin/install.js (thin CLI entry point with Commander)
  wiring:
    - install.js → installer.js → template-renderer.js → file-operations.js
    - installer.js uses path-resolver.js for target paths
    - install.js uses output.js for progress messages
  key_links:
    - bin/install.js (CLI) → installer.js (orchestration)
    - installer.js → template-renderer.js (rendering)
    - installer.js → file-operations.js (copying)
---

# Phase 1, Plan 2: Templates, CLI & Installation Orchestrator

## Objective

Build the template rendering system, CLI entry point, and installation orchestrator. User runs `npx get-shit-done-multi --claude` and skills install to `~/.claude/skills/` with all template variables replaced correctly.

## Context

Plan 1 created the foundation (build script, file operations, path resolver, output modules). Plan 2 integrates these into a working installer that:
- Loads templates from templates/ directory
- Renders {{VARIABLES}} at runtime (not pre-rendered)
- Orchestrates installation flow (create dirs, copy files, render templates)
- Provides CLI interface with Commander

**Research findings:**
- Runtime rendering enables {{INSTALL_DATE}}, {{USER}} variables
- Simple regex renderer sufficient (no template library needed)
- Thin entry point pattern (logic in lib/, entry does CLI setup)
- Commander for CLI parsing (handles --help, --version, flag validation)

## Tasks

<task name="create-template-renderer" type="auto">
  <files>bin/lib/templates/template-renderer.js</files>
  <action>
Create template rendering module with single-pass variable replacement:

**Module: bin/lib/templates/template-renderer.js**
```javascript
/**
 * Render template content by replacing {{VARIABLES}}
 * 
 * Uses single-pass replacement to prevent double-replacement
 * if variable values contain {{...}}.
 * 
 * Missing variables are replaced with [MISSING:VAR_NAME]
 * to make issues visible without breaking rendering.
 */
export function renderTemplate(content, variables) {
  return content.replace(/\{\{([A-Z_]+)\}\}/g, (match, variableName) => {
    if (variableName in variables) {
      return variables[variableName];
    }
    // Unknown variable - make visible for debugging
    return `[MISSING:${variableName}]`;
  });
}

/**
 * Get runtime variables for template rendering
 */
export function getRuntimeVariables(platform, scope = 'global') {
  const platformRoots = {
    claude: '.claude/',
    copilot: '.github/',
    codex: '.codex/'
  };
  
  const commandPrefixes = {
    claude: '/gsd-',
    copilot: '/gsd-',
    codex: '$gsd-'
  };
  
  return {
    PLATFORM_ROOT: platformRoots[platform] || '.claude/',
    PLATFORM_NAME: platform,
    VERSION: '2.0.0',
    COMMAND_PREFIX: commandPrefixes[platform] || '/gsd-',
    INSTALL_DATE: new Date().toISOString(),
    USER: process.env.USER || process.env.USERNAME || 'unknown',
    SCOPE: scope
  };
}

/**
 * Render file content with variables
 */
export async function renderFile(content, platform, scope = 'global') {
  const variables = getRuntimeVariables(platform, scope);
  return renderTemplate(content, variables);
}
```

**Implementation notes:**
- Regex matches uppercase {{VAR_NAME}} only (enforces convention)
- Single-pass replacement prevents double-replacement bugs
- Missing variables become [MISSING:VAR] for visibility
- getRuntimeVariables provides all Phase 1 variables
  </action>
  <verify>
Test template rendering:

```bash
cat > /tmp/test-template-renderer.js << 'EOF'
import { renderTemplate, getRuntimeVariables, renderFile } from './bin/lib/templates/template-renderer.js';

// Test basic replacement
const template = 'Install to {{PLATFORM_ROOT}}skills/{{COMMAND_PREFIX}}test';
const variables = { PLATFORM_ROOT: '.claude/', COMMAND_PREFIX: '/gsd-' };
const result = renderTemplate(template, variables);
console.log('Basic:', result);

// Test missing variable
const template2 = 'Version {{VERSION}} with {{MISSING}}';
const result2 = renderTemplate(template2, { VERSION: '2.0.0' });
console.log('Missing:', result2);

// Test runtime variables
const runtimeVars = getRuntimeVariables('claude', 'global');
console.log('Runtime vars:', runtimeVars);

// Test renderFile
const content = 'Install to {{PLATFORM_ROOT}} on {{INSTALL_DATE}}';
const rendered = await renderFile(content, 'claude', 'global');
console.log('Rendered:', rendered);

console.log('\n✓ Template rendering working');
EOF

node /tmp/test-template-renderer.js
```

Verify:
- {{PLATFORM_ROOT}} and {{COMMAND_PREFIX}} replaced correctly
- Missing variables show [MISSING:VAR_NAME]
- Runtime variables include INSTALL_DATE, USER
- Codex uses $gsd- prefix (not /gsd-)
  </verify>
  <done>
✓ Template renderer created with single-pass replacement
✓ Missing variables show [MISSING:VAR] for visibility
✓ Runtime variables include all Phase 1 variables
  </done>
</task>

<task name="create-template-loader" type="auto">
  <files>bin/lib/templates/template-loader.js</files>
  <action>
Create template loader to read from templates/ directory:

**Module: bin/lib/templates/template-loader.js**
```javascript
import path from 'path';
import { fileURLToPath } from 'url';
import { readFile, readDirectory, pathExists } from '../io/file-operations.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Get root directory (bin/lib/templates/ -> root/)
const ROOT_DIR = path.resolve(__dirname, '../../..');

/**
 * Get templates directory path
 */
export function getTemplatesDir() {
  return path.join(ROOT_DIR, 'templates');
}

/**
 * Get skills templates directory
 */
export function getSkillsTemplatesDir() {
  return path.join(getTemplatesDir(), 'skills');
}

/**
 * Get agents templates directory
 */
export function getAgentsTemplatesDir() {
  return path.join(getTemplatesDir(), 'agents');
}

/**
 * Get shared directory template
 */
export function getSharedTemplateDir() {
  return path.join(getTemplatesDir(), 'get-shit-done');
}

/**
 * Load all skill templates (directory names)
 */
export async function loadSkillTemplates() {
  const skillsDir = getSkillsTemplatesDir();
  
  if (!(await pathExists(skillsDir))) {
    throw new Error('Skills templates not found. Run: npm run build:templates');
  }
  
  const entries = await readDirectory(skillsDir);
  
  // Filter to directories only
  const skills = [];
  for (const entry of entries) {
    const fullPath = path.join(skillsDir, entry);
    const skillFile = path.join(fullPath, 'SKILL.md');
    
    if (await pathExists(skillFile)) {
      skills.push({
        name: entry,
        path: fullPath,
        skillFile: skillFile
      });
    }
  }
  
  return skills;
}

/**
 * Load all agent templates (flat .agent.md files)
 */
export async function loadAgentTemplates() {
  const agentsDir = getAgentsTemplatesDir();
  
  if (!(await pathExists(agentsDir))) {
    throw new Error('Agent templates not found. Run: npm run build:templates');
  }
  
  const entries = await readDirectory(agentsDir);
  
  const agents = entries
    .filter(file => file.endsWith('.agent.md'))
    .map(file => ({
      name: file.replace('.agent.md', ''),
      fileName: file,
      path: path.join(agentsDir, file)
    }));
  
  return agents;
}

/**
 * Load template file content
 */
export async function loadTemplateFile(filePath) {
  return await readFile(filePath);
}
```

**Implementation notes:**
- Uses fileURLToPath to get __dirname in ESM
- Resolves templates/ relative to package root
- Returns structured metadata (name, path) not just file names
- Validates templates/ exists before loading
  </action>
  <verify>
Test template loading:

```bash
cat > /tmp/test-template-loader.js << 'EOF'
import { loadSkillTemplates, loadAgentTemplates, getTemplatesDir } from './bin/lib/templates/template-loader.js';

console.log('Templates dir:', getTemplatesDir());

const skills = await loadSkillTemplates();
console.log(`\n✓ Loaded ${skills.length} skills`);
console.log('First skill:', skills[0]);

const agents = await loadAgentTemplates();
console.log(`\n✓ Loaded ${agents.length} agents`);
console.log('First agent:', agents[0]);

console.log('\n✓ Template loading working');
EOF

# First build templates, then test
npm run build:templates
node /tmp/test-template-loader.js
```

Verify:
- Skills loaded correctly (28 skills)
- Agents loaded correctly (13 agents)
- Each has name and path properties
  </verify>
  <done>
✓ Template loader created to read from templates/
✓ Returns structured metadata for skills and agents
✓ Validates templates/ exists before loading
  </done>
</task>

<task name="create-template-validator" type="auto">
  <files>bin/lib/templates/template-validator.js</files>
  <action>
Create template validator for pre-flight validation:

**Module: bin/lib/templates/template-validator.js**
```javascript
/**
 * Validate template syntax and variables
 */
export function validateTemplate(content, filePath) {
  const issues = [];
  
  // Check for unbalanced braces
  const openBraces = (content.match(/\{\{/g) || []).length;
  const closeBraces = (content.match(/\}\}/g) || []).length;
  
  if (openBraces !== closeBraces) {
    issues.push(`Unbalanced braces (${openBraces} open, ${closeBraces} close)`);
  }
  
  // Check for invalid variable names (lowercase or non-standard)
  const invalidVars = content.match(/\{\{([a-z][A-Za-z_]*)\}\}/g);
  if (invalidVars) {
    issues.push(`Lowercase variables (should be uppercase): ${invalidVars.join(', ')}`);
  }
  
  // Check for known variables
  const knownVars = [
    'PLATFORM_ROOT',
    'PLATFORM_NAME',
    'VERSION',
    'COMMAND_PREFIX',
    'INSTALL_DATE',
    'USER',
    'SCOPE'
  ];
  
  const variables = content.match(/\{\{([A-Z_]+)\}\}/g) || [];
  const unknownVars = variables
    .map(v => v.replace(/[{}]/g, ''))
    .filter(v => !knownVars.includes(v));
  
  if (unknownVars.length > 0) {
    issues.push(`Unknown variables: ${[...new Set(unknownVars)].join(', ')}`);
  }
  
  if (issues.length > 0) {
    throw new Error(`Template validation failed: ${filePath}\n- ${issues.join('\n- ')}`);
  }
  
  return true;
}

/**
 * Validate all templates before installation
 */
export async function validateAllTemplates(skills, agents) {
  const { loadTemplateFile } = await import('./template-loader.js');
  
  let validationErrors = [];
  
  // Validate skills
  for (const skill of skills) {
    try {
      const content = await loadTemplateFile(skill.skillFile);
      validateTemplate(content, skill.skillFile);
    } catch (error) {
      validationErrors.push(error.message);
    }
  }
  
  // Validate agents
  for (const agent of agents) {
    try {
      const content = await loadTemplateFile(agent.path);
      validateTemplate(content, agent.path);
    } catch (error) {
      validationErrors.push(error.message);
    }
  }
  
  if (validationErrors.length > 0) {
    throw new Error(`Template validation failed:\n\n${validationErrors.join('\n\n')}`);
  }
  
  return true;
}
```

**Implementation notes:**
- Validates template syntax (balanced braces)
- Enforces uppercase variable convention
- Warns about unknown variables
- Fails fast before any file operations
  </action>
  <verify>
Template validation tested during installation flow in next task.
  </verify>
  <done>
✓ Template validator created with syntax and variable checks
✓ Enforces uppercase variable names
✓ Validates before installation starts
  </done>
</task>

<task name="create-installer-orchestrator" type="auto">
  <files>bin/lib/installer/installer.js</files>
  <action>
Create installation orchestrator that coordinates the installation flow:

**Module: bin/lib/installer/installer.js**
```javascript
import path from 'path';
import { 
  loadSkillTemplates, 
  loadAgentTemplates, 
  loadTemplateFile,
  getSharedTemplateDir
} from '../templates/template-loader.js';
import { renderFile } from '../templates/template-renderer.js';
import { validateAllTemplates } from '../templates/template-validator.js';
import { 
  copyDirectory, 
  writeFile, 
  createDirectory,
  checkSymlink 
} from '../io/file-operations.js';
import { 
  getSkillsPath, 
  getAgentsPath, 
  getSharedPath,
  joinPaths
} from '../paths/path-resolver.js';
import { 
  printStep, 
  printSuccess, 
  printWarning, 
  printCompletion 
} from '../cli/output.js';

/**
 * Main installation function
 */
export async function install(options) {
  const platform = options.claude ? 'claude' : null;
  const isGlobal = !options.local; // Default to global
  
  if (!platform) {
    throw new Error('No platform specified. Use --claude flag.');
  }
  
  printStep('Loading templates...');
  const skills = await loadSkillTemplates();
  const agents = await loadAgentTemplates();
  
  printStep(`Validating templates (${skills.length} skills, ${agents.length} agents)...`);
  await validateAllTemplates(skills, agents);
  
  const targetSkillsPath = getSkillsPath(platform, isGlobal);
  const targetAgentsPath = getAgentsPath(platform, isGlobal);
  const targetSharedPath = getSharedPath(platform, isGlobal);
  
  // Check for symlinks and warn
  const symlinkCheck = await checkSymlink(targetSkillsPath);
  if (symlinkCheck.isSymlink) {
    printWarning(`${targetSkillsPath} is a symlink`);
  }
  
  printStep('Creating directories...');
  await createDirectory(targetSkillsPath);
  await createDirectory(targetAgentsPath);
  await createDirectory(targetSharedPath);
  
  printStep(`Installing skills to ${targetSkillsPath}...`);
  await installSkills(skills, targetSkillsPath, platform, isGlobal ? 'global' : 'local');
  
  printStep(`Installing agents to ${targetAgentsPath}...`);
  await installAgents(agents, targetAgentsPath, platform, isGlobal ? 'global' : 'local');
  
  printStep(`Installing shared directory to ${targetSharedPath}...`);
  await installSharedDirectory(targetSharedPath, platform, isGlobal ? 'global' : 'local');
  
  printCompletion(isGlobal ? getSkillsPath(platform, true) : getSkillsPath(platform, false), platform);
}

/**
 * Install skills (directory-based)
 */
async function installSkills(skills, targetPath, platform, scope) {
  for (const skill of skills) {
    const targetSkillDir = joinPaths(targetPath, skill.name);
    const targetSkillFile = joinPaths(targetSkillDir, 'SKILL.md');
    
    // Create skill directory
    await createDirectory(targetSkillDir);
    
    // Load and render SKILL.md
    const content = await loadTemplateFile(skill.skillFile);
    const rendered = await renderFile(content, platform, scope);
    
    // Write rendered file
    await writeFile(targetSkillFile, rendered);
  }
}

/**
 * Install agents (flat files)
 */
async function installAgents(agents, targetPath, platform, scope) {
  for (const agent of agents) {
    const targetFile = joinPaths(targetPath, agent.fileName);
    
    // Load and render agent file
    const content = await loadTemplateFile(agent.path);
    const rendered = await renderFile(content, platform, scope);
    
    // Write rendered file
    await writeFile(targetFile, rendered);
  }
}

/**
 * Install shared directory
 */
async function installSharedDirectory(targetPath, platform, scope) {
  const sharedTemplateDir = getSharedTemplateDir();
  
  // Copy entire directory structure
  await copyDirectory(sharedTemplateDir, targetPath);
  
  // Render manifest template
  const manifestPath = joinPaths(targetPath, '.gsd-install-manifest.json');
  const manifestContent = await loadTemplateFile(manifestPath);
  const rendered = await renderFile(manifestContent, platform, scope);
  await writeFile(manifestPath, rendered);
}
```

**Implementation notes:**
- Orchestrates full installation flow
- Validates templates before any file writes
- Shows progress at each major step
- Warns about symlinks but continues
- Creates directories automatically
- Renders templates with runtime variables
  </action>
  <verify>
Installer tested in integration test (Plan 3).
  </verify>
  <done>
✓ Installer orchestrator created with full installation flow
✓ Validates templates before file operations
✓ Shows progress at each step
✓ Handles skills, agents, and shared directory
  </done>
</task>

<task name="create-cli-entry-point" type="auto">
  <files>bin/install.js</files>
  <action>
Create thin CLI entry point using Commander:

**File: bin/install.js**
```javascript
#!/usr/bin/env node

import { Command } from 'commander';
import { install } from './lib/installer/installer.js';
import { withErrorHandling } from './lib/cli/errors.js';
import { printVersion } from './lib/cli/output.js';
import { handleUnsupportedPlatform } from './lib/cli/errors.js';
import { getInstallPath, getSharedPath } from './lib/paths/path-resolver.js';
import { pathExists } from './lib/io/file-operations.js';

const VERSION = '2.0.0';

const program = new Command();

program
  .name('get-shit-done-multi')
  .description('Multi-platform installer for get-shit-done AI CLI skills')
  .version(VERSION, '-v, --version', 'Output version information')
  .helpOption('-h, --help', 'Display help information');

program
  .option('--claude', 'Install to Claude Code (~/.claude/)')
  .option('--copilot', 'Install to GitHub Copilot CLI (not yet supported)')
  .option('--codex', 'Install to Codex CLI (not yet supported)')
  .option('--local', 'Install to current directory (.claude/ instead of ~/.claude/)')
  .option('--global', 'Install globally to home directory (default)')
  .option('--no-color', 'Disable colored output')
  .option('--color', 'Force colored output')
  .action(async (options) => {
    await withErrorHandling(async () => {
      // Check for unsupported platforms in Phase 1
      if (options.copilot) {
        handleUnsupportedPlatform('copilot');
      }
      if (options.codex) {
        handleUnsupportedPlatform('codex');
      }
      
      // Check if any platform specified
      if (!options.claude && !options.copilot && !options.codex) {
        throw new Error(
          'No platform specified.\n\n' +
          'Usage: npx get-shit-done-multi --claude\n\n' +
          'Run --help for more information.'
        );
      }
      
      await install(options);
    });
  });

// Custom --version handler to show installations
program
  .command('version')
  .description('Show version and detected installations')
  .action(async () => {
    // Detect existing installations
    const installations = [];
    
    const platforms = ['claude', 'copilot', 'codex'];
    const scopes = [
      { name: 'global', isGlobal: true },
      { name: 'local', isGlobal: false }
    ];
    
    for (const platform of platforms) {
      for (const scope of scopes) {
        try {
          const sharedPath = getSharedPath(platform, scope.isGlobal);
          if (await pathExists(sharedPath)) {
            installations.push({
              path: sharedPath,
              platform: `${platform} (${scope.name})`
            });
          }
        } catch (error) {
          // Ignore errors (platform might not be supported)
        }
      }
    }
    
    printVersion(VERSION, installations);
  });

program.parse();
```

**Implementation notes:**
- Thin entry point (logic in lib/)
- Commander handles --help, --version, flag validation
- Custom version command shows detected installations
- Unsupported platforms error with clear message
- withErrorHandling wraps async operations
  </action>
  <verify>
Test CLI entry point:

```bash
# Make executable
chmod +x bin/install.js

# Test help
./bin/install.js --help

# Test version
./bin/install.js --version

# Test unsupported platform
./bin/install.js --copilot 2>&1 | grep "not supported"

# Test no platform
./bin/install.js 2>&1 | grep "No platform specified"
```

Verify:
- --help shows usage information
- --version shows version number
- Unsupported platforms error correctly
- No platform specified shows error with usage
  </verify>
  <done>
✓ CLI entry point created with Commander
✓ --help and --version working
✓ Unsupported platforms error with clear message
✓ Thin orchestrator delegates to installer.js
  </done>
</task>

## Success Criteria

- [ ] `npx get-shit-done-multi --claude` installs skills to ~/.claude/skills/
- [ ] All 28 skills installed as directories with SKILL.md
- [ ] All 13 agents installed as .agent.md files
- [ ] Shared directory copied to ~/.claude/get-shit-done/
- [ ] Template variables replaced correctly in output files
- [ ] `--help` shows usage information
- [ ] `--version` shows version and detects installations
- [ ] Progress messages show during installation
- [ ] Completion message shows next steps

## Output

Working installer ready for testing in Plan 3:
- ✓ bin/lib/templates/template-renderer.js
- ✓ bin/lib/templates/template-loader.js
- ✓ bin/lib/templates/template-validator.js
- ✓ bin/lib/installer/installer.js
- ✓ bin/install.js (NPX entry point)
