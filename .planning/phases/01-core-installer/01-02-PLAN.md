---
phase: 01-core-installer
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - templates/skills/gsd-new-project.md
  - templates/agents/gsd-planner.md
  - get-shit-done/.gsd-install-manifest.json
  - bin/install.js
  - bin/lib/installer.js
autonomous: true
must_haves:
  observables:
    - "bin/install.js executable with shebang, responds to --help and --version"
    - "Templates exist with {{VARIABLES}} placeholders"
    - "Installation manifest template exists in get-shit-done/"
    - "Running bin/install.js --claude triggers installation flow"
    - "Progress feedback shows step-by-step with checkmarks"
  artifacts:
    - bin/install.js (CLI entry point)
    - bin/lib/installer.js (installation orchestrator)
    - templates/skills/gsd-new-project.md (example skill)
    - templates/agents/gsd-planner.md (example agent)
    - get-shit-done/.gsd-install-manifest.json (manifest template)
  wiring:
    - bin/install.js imports installer.js and core modules
    - installer.js orchestrates path resolution, file ops, rendering
    - Commander wired to option handlers
  key_links:
    - bin/install.js shebang makes it executable via npx
    - Installer calls modules in correct order (validate → copy → render → write)
    - Manifest copied to installation location after successful install
---

# Plan 02: Templates, CLI & Installation Orchestrator

**Objective:** Create template content, CLI entry point with Commander, and installation orchestration logic

## Context

This plan builds on Plan 01's modules to create the complete installer:
- Template files (skills, agents) with variable placeholders
- CLI entry point (bin/install.js) with Commander for flag parsing
- Installation orchestrator (bin/lib/installer.js) that coordinates the modules

User workflow: `npx get-shit-done-multi --claude` → reads templates → renders with variables → copies to `~/.claude/skills/gsd/` → shows success message

Per CONTEXT.md decisions:
- Moderate progress feedback (step-based with checkmarks)
- Success message includes next steps
- Errors show actionable fixes
- Colors auto-detect with --no-color override

## Tasks

<task name="create-templates" type="auto">
  <files>
    templates/skills/gsd-new-project.md
    templates/agents/gsd-planner.md
    get-shit-done/.gsd-install-manifest.json
  </files>
  <action>
Create template files with {{VARIABLES}} placeholders:

**1. templates/skills/gsd-new-project.md**
```markdown
# /gsd-new-project

Start a new project with GSD methodology.

**Usage:** `/gsd-new-project`

**Installed:** {{INSTALL_DATE}}
**Platform:** {{PLATFORM_NAME}}
**Version:** {{VERSION}}

This skill guides you through:
1. Defining project vision
2. Creating requirements
3. Building roadmap

Files created in: {{PLATFORM_ROOT}}planning/
```

**2. templates/agents/gsd-planner.md**
```markdown
# GSD Planner Agent

**Command:** {{COMMAND_PREFIX}}plan-phase

Orchestrates phase planning and spawns specialists when needed.

**Platform:** {{PLATFORM_NAME}}
**Installed by:** {{USER}}
**Version:** {{VERSION}}

Reference files: @{{PLATFORM_ROOT}}get-shit-done/references/
```

**3. get-shit-done/.gsd-install-manifest.json**
```json
{
  "version": "{{VERSION}}",
  "platform": "{{PLATFORM_NAME}}",
  "scope": "global",
  "installedAt": "{{INSTALL_DATE}}",
  "installedBy": "{{USER}}",
  "files": []
}
```

These are example templates to validate the system. Full template content will be copied from existing get-shit-done/ directory in later integration.

**Template validation:**
- All variables use uppercase: {{VERSION}}, {{PLATFORM_NAME}}, etc.
- Balanced braces (each {{ has matching }})
- No special characters that break rendering
  </action>
  <verify>
    ```bash
    # Check templates exist
    ls templates/skills/gsd-new-project.md
    ls templates/agents/gsd-planner.md
    ls get-shit-done/.gsd-install-manifest.json
    
    # Verify variable syntax
    grep -E '\{\{[A-Z_]+\}\}' templates/skills/gsd-new-project.md
    grep -E '\{\{[A-Z_]+\}\}' templates/agents/gsd-planner.md
    
    # Check no lowercase variables
    ! grep -E '\{\{[^}]*[a-z][^}]*\}\}' templates/**/*.md
    ```
  </verify>
  <done>
    - Template files exist with {{VARIABLES}}
    - All variables are uppercase
    - Manifest template created
  </done>
</task>

<task name="cli-entry-point" type="auto">
  <files>bin/install.js</files>
  <action>
Create bin/install.js as thin CLI entry point with Commander:

**File structure:**
```javascript
#!/usr/bin/env node

import { Command } from 'commander';
import chalk from 'chalk';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { readFileSync } from 'fs';
import { install } from './lib/installer.js';

// ESM __dirname equivalent
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load version from package.json
const packageJson = JSON.parse(
  readFileSync(join(__dirname, '../package.json'), 'utf-8')
);

const program = new Command();

program
  .name('get-shit-done-multi')
  .description('Install GSD skills and agents to Claude Code platform')
  .version(packageJson.version)
  .option('--claude', 'Install to Claude Code')
  .option('--no-color', 'Disable colored output')
  .action(async (options) => {
    try {
      // Validate platform flag
      if (!options.claude) {
        console.error(chalk.red('✗ No platform specified'));
        console.log('\nUsage: npx get-shit-done-multi --claude');
        console.log('\nRun --help for more information');
        process.exit(1);
      }

      await install({
        platform: 'claude',
        scope: 'global',
        version: packageJson.version
      });
      
      process.exit(0);
    } catch (error) {
      console.error(chalk.red('✗'), error.message);
      process.exit(1);
    }
  });

program.parse();
```

**Key points:**
- Shebang `#!/usr/bin/env node` makes it executable
- Thin entry point (orchestration only, logic in lib/installer.js)
- Loads version from package.json
- Commander handles --help automatically
- Validates --claude flag is present
- Error handling with process.exit codes
- Chalk respects --no-color via auto-detection

**Make executable:**
```bash
chmod +x bin/install.js
```
  </action>
  <verify>
    ```bash
    # Check shebang
    head -1 bin/install.js | grep "#!/usr/bin/env node"
    
    # Check executable
    test -x bin/install.js && echo "Executable OK"
    
    # Test help output
    node bin/install.js --help
    
    # Test version output
    node bin/install.js --version
    ```
  </verify>
  <done>
    - bin/install.js exists with shebang
    - File is executable (chmod +x)
    - --help shows usage information
    - --version shows 2.0.0
    - Commander integrated correctly
  </done>
</task>

<task name="installation-orchestrator" type="auto">
  <files>bin/lib/installer.js</files>
  <action>
Create bin/lib/installer.js with installation orchestration logic:

**Main export: `install(options)`**
```javascript
import chalk from 'chalk';
import { resolvePlatformPath, resolveSharedPath } from './paths/path-resolver.js';
import { copyDirectory, ensureDirectory, writeFile, checkSymlink } from './io/file-operations.js';
import { renderTemplate, validateTemplate, getVariableContext } from './rendering/template-renderer.js';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import fs from 'fs-extra';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export async function install(options) {
  const { platform, scope, version } = options;
  
  // Step 1: Resolve paths
  console.log(chalk.blue('→ Resolving installation paths...'));
  const targetPath = resolvePlatformPath(platform, scope);
  const sharedPath = resolveSharedPath(platform, scope);
  
  // Step 2: Check for symlinks (warn but continue)
  const symlinkCheck = await checkSymlink(targetPath);
  if (symlinkCheck.isSymlink) {
    console.log(chalk.yellow('⚠ Warning:'), `${targetPath} is a symlink to ${symlinkCheck.target}`);
  }
  
  // Step 3: Ensure target directories exist
  console.log(chalk.blue('→ Creating directories...'));
  await ensureDirectory(targetPath);
  await ensureDirectory(sharedPath);
  console.log(chalk.green('✓ Directories ready'));
  
  // Step 4: Load and validate templates
  console.log(chalk.blue('→ Validating templates...'));
  const templateDir = join(__dirname, '../../templates');
  const templates = await loadTemplates(templateDir);
  
  for (const template of templates) {
    const validation = validateTemplate(template.content, template.path);
    if (!validation.valid) {
      throw new Error(`Template validation failed for ${template.path}:\n${validation.errors.join('\n')}`);
    }
  }
  console.log(chalk.green('✓ Templates validated'));
  
  // Step 5: Render and copy templates
  console.log(chalk.blue('→ Installing templates...'));
  const variables = getVariableContext(platform, scope, version);
  
  for (const template of templates) {
    const rendered = renderTemplate(template.content, variables);
    const relativePath = template.path.replace(templateDir, '');
    const targetFile = join(targetPath, relativePath);
    await writeFile(targetFile, rendered);
  }
  console.log(chalk.green('✓ Templates installed'));
  
  // Step 6: Copy shared directory
  console.log(chalk.blue('→ Copying shared resources...'));
  const sharedSourceDir = join(__dirname, '../../get-shit-done');
  await copyDirectory(sharedSourceDir, sharedPath);
  
  // Render manifest with variables
  const manifestPath = join(sharedPath, '.gsd-install-manifest.json');
  const manifestContent = await fs.readFile(manifestPath, 'utf-8');
  const renderedManifest = renderTemplate(manifestContent, variables);
  await writeFile(manifestPath, renderedManifest);
  
  console.log(chalk.green('✓ Shared resources copied'));
  
  // Step 7: Success message with next steps
  console.log();
  console.log(chalk.green.bold('✓ Installation complete!'));
  console.log();
  console.log('Installed to:', chalk.cyan(targetPath));
  console.log('Shared resources:', chalk.cyan(sharedPath));
  console.log();
  console.log('Next steps:');
  console.log('  - Restart Claude Code or reload skills');
  console.log('  - Run /gsd-new-project to start a new project');
  console.log();
}

async function loadTemplates(dir) {
  const templates = [];
  const files = await fs.readdir(dir, { recursive: true, withFileTypes: true });
  
  for (const file of files) {
    if (file.isFile() && file.name.endsWith('.md')) {
      const fullPath = join(file.path, file.name);
      const content = await fs.readFile(fullPath, 'utf-8');
      templates.push({ path: fullPath, content });
    }
  }
  
  return templates;
}
```

**Flow:**
1. Resolve paths (using path-resolver)
2. Check symlinks (warn but continue per CONTEXT.md)
3. Create directories (using file-operations)
4. Load and validate all templates (fail fast)
5. Render templates with variables
6. Write rendered files to target
7. Copy shared directory
8. Render manifest
9. Show success message with next steps

**Error handling:**
- Each step wrapped in try/catch at caller level (bin/install.js)
- Specific error messages per CONTEXT.md decisions
- Process exits with code 1 on error (handled in bin/install.js)
  </action>
  <verify>
    ```bash
    # Verify module loads
    node -e "import('./bin/lib/installer.js').then(m => console.log('Exports:', Object.keys(m)))"
    
    # Check imports are correct
    grep -q "import.*path-resolver" bin/lib/installer.js
    grep -q "import.*file-operations" bin/lib/installer.js
    grep -q "import.*template-renderer" bin/lib/installer.js
    ```
  </verify>
  <done>
    - installer.js exists with install() export
    - Orchestrates all modules in correct order
    - Progress messages use chalk with checkmarks
    - Success message includes next steps
    - Error handling defers to caller
  </done>
</task>

## Verification

**Integration Test (dry run):**
```bash
# Test CLI parses flags correctly
node bin/install.js --help
node bin/install.js --version

# Test error on missing platform flag
node bin/install.js || echo "Expected failure - no platform flag"

# Module integration check
node -e "
Promise.all([
  import('./bin/install.js'),
  import('./bin/lib/installer.js')
]).then(() => console.log('✓ CLI and installer load successfully'))
"
```

**Template Check:**
```bash
# Verify templates have valid variables
node -e "
import('./bin/lib/rendering/template-renderer.js').then(async (m) => {
  const fs = await import('fs-extra');
  const content = await fs.readFile('templates/skills/gsd-new-project.md', 'utf-8');
  const result = m.validateTemplate(content, 'gsd-new-project.md');
  console.log('Template validation:', result);
})
"
```

## Success Criteria

- [ ] Templates created with {{VARIABLES}} placeholders
- [ ] bin/install.js executable with shebang
- [ ] --help and --version work correctly
- [ ] installer.js orchestrates all modules
- [ ] Progress shows step-by-step with colored checkmarks
- [ ] Success message includes next steps
- [ ] Module imports work without errors

## Output

**Created files:**
- bin/install.js (CLI entry point)
- bin/lib/installer.js (orchestrator)
- templates/skills/gsd-new-project.md
- templates/agents/gsd-planner.md
- get-shit-done/.gsd-install-manifest.json

**Ready for:** Plan 03 (Integration testing and verification)
