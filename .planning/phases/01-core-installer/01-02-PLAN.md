---
phase: 01-core-installer
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified:
  - templates/skills/gsd-*/SKILL.md (29 skills)
  - templates/agents/gsd-*.agent.md (13 agents)
  - templates/.gsd-install-manifest.json
  - bin/lib/installer.js
  - bin/install.js
autonomous: true
must_haves:
  observables:
    - Templates directory exists with 29 skills and 13 agents
    - Each template has {{VARIABLES}} replacing hardcoded values
    - User runs `npx get-shit-done-multi --claude` → skills install to target
    - Installation completes with success message showing next steps
  artifacts:
    - templates/skills/ (29 directories copied from .github/skills/)
    - templates/agents/ (13 files copied from .github/agents/)
    - templates/.gsd-install-manifest.json (template)
    - bin/lib/installer.js (orchestrates installation)
  wiring:
    - bin/install.js calls bin/lib/installer.js install()
    - installer.js uses modules from Plan 1 (io, paths, rendering)
    - Template conversion replaces hardcoded values with variables
  key_links:
    - installer.js → io/file-operations.js (copy templates to target)
    - installer.js → rendering/template-renderer.js (variable replacement)
    - installer.js → paths/path-resolver.js (determine target paths)
---

# Phase 1, Plan 2: Templates, CLI & Installation Orchestrator

## Objective

Copy 29 skills and 13 agents from `.github/` to `/templates/`, convert them to templates by adding `{{VARIABLES}}`, and implement the installation orchestrator that renders and installs them to Claude Code.

## Context

**What exists (from Plan 1):**
- NPX entry point with CLI flags
- Core modules: file operations, path resolver, template renderer, error handler
- Dependencies installed (fs-extra, chalk, commander)

**What's needed:**
- Templates directory with converted skills/agents
- Installation orchestrator that uses Plan 1 modules
- End-to-end installation flow

**Critical constraints:**
- COPY from `.github/`, don't generate new content
- Convert copies by adding `{{VARIABLES}}`
- Maintain directory structure for skills (gsd-*/SKILL.md)
- Never modify source files in `.github/`
- All tests in `/tmp` only

## Tasks

<task name="copy-skills-to-templates" type="auto">
  <files>templates/skills/*</files>
  <action>
Copy ALL 29 skill directories from `.github/skills/` to `templates/skills/`:

```bash
mkdir -p templates/skills
cp -R .github/skills/gsd-* templates/skills/
```

Verify count:
```bash
ls -1 templates/skills/ | wc -l
```
Should show 29 directories.

**Structure verification:**
Each skill should be: `templates/skills/gsd-<name>/SKILL.md`

DO NOT modify content yet - this task just copies.
  </action>
  <verify>
```bash
# Count skills
SKILL_COUNT=$(ls -1 templates/skills/ | wc -l)
echo "Skills copied: $SKILL_COUNT"

# Check structure (sample)
ls templates/skills/gsd-new-project/SKILL.md
ls templates/skills/gsd-execute-phase/SKILL.md
```

Output: "Skills copied: 29" and both sample files exist
  </verify>
  <done>29 skill directories copied to templates/skills/</done>
</task>

<task name="copy-agents-to-templates" type="auto">
  <files>templates/agents/*</files>
  <action>
Copy ALL 13 agent files from `.github/agents/` to `templates/agents/`:

```bash
mkdir -p templates/agents
cp .github/agents/gsd-*.agent.md templates/agents/
```

Verify count:
```bash
ls -1 templates/agents/*.agent.md | wc -l
```
Should show 13 files.

**Structure verification:**
Each agent should be: `templates/agents/gsd-<name>.agent.md`

DO NOT modify content yet - this task just copies.
  </action>
  <verify>
```bash
# Count agents
AGENT_COUNT=$(ls -1 templates/agents/*.agent.md | wc -l)
echo "Agents copied: $AGENT_COUNT"

# Check structure (sample)
ls templates/agents/gsd-planner.agent.md
ls templates/agents/gsd-executor.agent.md
```

Output: "Agents copied: 13" and both sample files exist
  </verify>
  <done>13 agent files copied to templates/agents/</done>
</task>

<task name="convert-templates-add-variables" type="auto">
  <files>templates/skills/*, templates/agents/*</files>
  <action>
Convert all copied templates by replacing hardcoded values with `{{VARIABLES}}`:

**Replacements to make:**

1. **Platform roots** - Replace `.github/` with `{{PLATFORM_ROOT}}`:
   ```bash
   find templates/ -type f -name "*.md" -exec sed -i '' 's|\.github/|{{PLATFORM_ROOT}}|g' {} +
   ```

2. **Command prefixes** - Replace `/gsd-` with `{{COMMAND_PREFIX}}`:
   ```bash
   find templates/ -type f -name "*.md" -exec sed -i '' 's|/gsd-|{{COMMAND_PREFIX}}|g' {} +
   ```

3. **Platform names** - Replace `GitHub` or `copilot` references with `{{PLATFORM_NAME}}`:
   ```bash
   find templates/ -type f -name "*.md" -exec sed -i '' 's|GitHub Copilot|{{PLATFORM_NAME}}|g' {} +
   ```

**Verification after conversion:**
```bash
# Check that variables exist
grep -r "{{PLATFORM_ROOT}}" templates/ | wc -l
grep -r "{{COMMAND_PREFIX}}" templates/ | wc -l
```

Should show many matches (templates now have variables).

**IMPORTANT:** Use `sed -i ''` on macOS or `sed -i` on Linux for in-place replacement.
  </action>
  <verify>
```bash
# Check variables exist in templates
PLATFORM_ROOT_COUNT=$(grep -r "{{PLATFORM_ROOT}}" templates/ | wc -l)
COMMAND_PREFIX_COUNT=$(grep -r "{{COMMAND_PREFIX}}" templates/ | wc -l)

echo "PLATFORM_ROOT occurrences: $PLATFORM_ROOT_COUNT"
echo "COMMAND_PREFIX occurrences: $COMMAND_PREFIX_COUNT"

# Sample a file to verify
head -20 templates/skills/gsd-new-project/SKILL.md | grep "{{PLATFORM_ROOT}}"
```

Both counts > 0, sample shows `{{PLATFORM_ROOT}}`
  </verify>
  <done>Templates converted with {{VARIABLES}} replacing hardcoded values</done>
</task>

<task name="create-manifest-template" type="auto">
  <files>templates/.gsd-install-manifest.json</files>
  <action>
Create `templates/.gsd-install-manifest.json` as template for installation manifest:

```json
{
  "version": "{{VERSION}}",
  "platform": "{{PLATFORM_NAME}}",
  "scope": "{{SCOPE}}",
  "installedAt": "{{INSTALL_DATE}}",
  "installedBy": "{{USER}}",
  "files": []
}
```

This template will be rendered and written to target `get-shit-done/.gsd-install-manifest.json` during installation.

The `files` array will be populated by the installer with actual installed file paths.
  </action>
  <verify>
```bash
cat templates/.gsd-install-manifest.json | grep "{{VERSION}}"
cat templates/.gsd-install-manifest.json | grep "{{PLATFORM_NAME}}"
```

Both variables exist in template
  </verify>
  <done>Manifest template created with variables</done>
</task>

<task name="create-installation-orchestrator" type="auto">
  <files>bin/lib/installer.js</files>
  <action>
Create `bin/lib/installer.js` that orchestrates the installation:

**Export this function:**

```javascript
export async function install(options)
```

**Installation flow:**

1. **Determine scope** (default to 'global' for Phase 1)
   ```javascript
   const scope = 'global';  // Phase 1: always global
   const platform = 'claude';
   ```

2. **Resolve paths** using path-resolver.js:
   ```javascript
   import { resolvePlatformPath, resolveSharedPath } from './paths/path-resolver.js';
   const targetSkillsPath = resolvePlatformPath(platform, scope);
   const targetSharedPath = resolveSharedPath(platform, scope);
   ```

3. **Get template variables** from template-renderer.js:
   ```javascript
   import { getDefaultVariables, renderTemplate } from './rendering/template-renderer.js';
   const variables = {
     ...getDefaultVariables(),
     SCOPE: scope
   };
   ```

4. **Show progress** with chalk:
   ```javascript
   console.log(chalk.green('✓'), 'Copying templates...');
   ```

5. **Copy skills** - For each skill directory in templates/skills/:
   - Read SKILL.md content
   - Render template with variables
   - Write to target: `${targetSkillsPath}/<skill-name>/SKILL.md`
   - Use file-operations.js functions

6. **Copy agents** - For each agent file in templates/agents/:
   - Read .agent.md content
   - Render template with variables
   - Write to target: `${targetSkillsPath}/<agent-name>.agent.md` (flat structure)

7. **Copy shared directory**:
   ```javascript
   import { copyDirectory } from './io/file-operations.js';
   await copyDirectory('./get-shit-done', targetSharedPath);
   ```

8. **Create manifest**:
   - Read templates/.gsd-install-manifest.json
   - Render with variables (including populated files array)
   - Write to `${targetSharedPath}/.gsd-install-manifest.json`

9. **Show success message**:
   ```javascript
   console.log(chalk.green('✓'), 'Installation complete!');
   console.log();
   console.log('Installed to:', targetSkillsPath);
   console.log();
   console.log('Next steps:');
   console.log('- Restart Claude Code or reload skills');
   console.log('- Run /gsd-new-project to start a new project');
   ```

**Error handling:** Let errors propagate (caught by entry point's error handler)

**Key patterns:**
- Use ESM imports with `.js` extensions
- Use chalk for colored output (auto-detects TTY)
- Use fs-extra via file-operations.js
- Show moderate progress (step-based with checkmarks)
  </action>
  <verify>
Run installation in isolated test directory:

```bash
TEST_DIR="/tmp/gsd-test-install-$(date +%s)"
mkdir -p "$TEST_DIR"
cd "$TEST_DIR"

# Run installer (will install to ~/.claude by default in test)
# For true isolation, mock os.homedir() or test with --local flag when implemented
# For now, verify installer runs without errors

node /path/to/source/bin/install.js --claude 2>&1 | tee install.log

# Check for success indicators
grep "Installation complete" install.log
grep "Next steps" install.log
```

Output shows success message and next steps
  </verify>
  <done>Installation orchestrator working, coordinates all modules</done>
</task>

<task name="wire-installer-to-entry-point" type="auto">
  <files>bin/install.js</files>
  <action>
Update `bin/install.js` to call the installer:

1. Add import at top:
   ```javascript
   import { install } from './lib/installer.js';
   ```

2. Remove placeholder install function (was: `async function install(options) { console.log('TODO'); }`)

3. The action handler already calls `await install(options)` from Plan 1, so no change needed there.

4. Add validation for --claude flag requirement:
   ```javascript
   .action(async (options) => {
     if (!options.claude) {
       console.error(chalk.red('✗'), 'Error: --claude flag required in Phase 1');
       console.error();
       console.error('Usage: npx get-shit-done-multi --claude');
       process.exit(1);
     }
     
     try {
       await install(options);
       process.exit(0);
     } catch (error) {
       exitWithError(error);
     }
   });
   ```

This completes the wiring from entry point → installer → modules.
  </action>
  <verify>
```bash
# Test without flag (should error)
node bin/install.js 2>&1 | grep "required"

# Test with flag (should run)
node bin/install.js --claude 2>&1 | head -5
```

First command shows "required" error, second starts installation
  </verify>
  <done>Entry point wired to installer, validates --claude flag</done>
</task>

<task name="handle-existing-files-and-directories" type="auto">
  <files>bin/lib/installer.js</files>
  <action>
Update installer.js to handle existing files per CONTEXT.md decisions:

**Before copying:**

1. **Check for symlinks** at target paths:
   ```javascript
   import { checkSymlink } from './io/file-operations.js';
   await checkSymlink(targetSkillsPath);  // Warns but continues
   ```

2. **Create missing directories** automatically:
   ```javascript
   import { ensureDirectory } from './io/file-operations.js';
   await ensureDirectory(targetSkillsPath);
   console.log(chalk.blue('ℹ'), `Created ${targetSkillsPath}`);
   ```

3. **Overwrite existing files** silently (no prompts):
   - Use `fs.outputFile()` which overwrites by default
   - No existence checks needed (per CONTEXT.md: "overwrite silently")

**Error handling for permissions:**
- If EACCES error occurs, it propagates to error handler (from Plan 1)
- Error handler shows: "Permission denied to write {path}\n\nFix: Check directory permissions"

This implements CONTEXT.md decisions:
- Missing directories → create automatically
- Existing files → overwrite silently
- Symlinks → warn but continue
- Permission errors → fail with clear message
  </action>
  <verify>
Test directory creation:

```bash
TEST_DIR="/tmp/gsd-test-dirs-$(date +%s)"
node -e "
import { install } from './bin/lib/installer.js';
// Mock test would check ensureDirectory calls
console.log('Directory handling verified');
"
```

Manual verification: Check installer.js contains ensureDirectory calls
  </verify>
  <done>Installer handles existing files per CONTEXT.md requirements</done>
</task>

## Verification

**Must work:**
1. Templates directory has 29 skills + 13 agents
2. Templates contain `{{PLATFORM_ROOT}}` and `{{COMMAND_PREFIX}}` variables
3. `node bin/install.js --claude` installs to `~/.claude/skills/gsd/`
4. Installation shows progress with checkmarks
5. Success message includes next steps
6. Shared directory copies to `.claude/get-shit-done/`
7. Manifest created at `.claude/get-shit-done/.gsd-install-manifest.json`

**Files exist:**
- `templates/skills/gsd-*/SKILL.md` (29 skills)
- `templates/agents/gsd-*.agent.md` (13 agents)
- `templates/.gsd-install-manifest.json`
- `bin/lib/installer.js`

**Source protection:**
- `.github/skills/` and `.github/agents/` unchanged (originals intact)
- All tests in `/tmp` only

## Success Criteria

Plan 2 complete when:
- ✅ Templates directory created with all 29 skills and 13 agents
- ✅ All templates converted with {{VARIABLES}}
- ✅ User runs `npx get-shit-done-multi --claude` → installation succeeds
- ✅ Installed files in `~/.claude/skills/gsd/` have variables replaced
- ✅ Shared directory copied to `.claude/get-shit-done/`
- ✅ Success message shows installation location and next steps
- ✅ Missing directories created automatically
- ✅ Symlinks generate warning but continue
- ✅ Source files in `.github/` unchanged

## Output

**Deliverables:**
- Templates directory with 29 skills + 13 agents (converted)
- Installation orchestrator (bin/lib/installer.js)
- Working end-to-end installation to Claude Code
- Progress feedback and success message
- Manifest template and installation

**Next:** Plan 3 implements integration testing and verification in `/tmp`.
