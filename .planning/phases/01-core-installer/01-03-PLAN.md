---
phase: 01-core-installer
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - tests/helpers/test-env.js
  - package.json (add test script and test dependencies)
autonomous: true
must_haves:
  observable_truths:
    - Installation completes successfully end-to-end
    - All 29 skills and 13 agents install to target directory
    - Template variables render correctly in installed files
    - Error scenarios produce helpful actionable messages
    - Tests execute in isolated environments (never modify source)
  required_artifacts:
    - tests/helpers/test-env.js (creates isolated /tmp test environments)
    - package.json (with vitest dependencies and test scripts)
  required_wiring:
    - test-env.js creates unique /tmp directories for each test
    - test-env.js provides installCmd() helper that runs installer
    - test-env.js provides cleanup() to remove test directories
    - package.json includes vitest dev dependencies
    - package.json includes test, test:watch, test:ui scripts
  key_links:
    - npm test runs vitest test suite
    - All test environments created in /tmp (never in source)
---

# Phase 1, Plan 3: Test Infrastructure

## Objective

Set up the testing infrastructure for Phase 1: install Vitest as the test runner, create test-env.js helper that enforces TEST-01 requirement (all tests in /tmp), and configure package.json with test scripts. This foundation enables Plan 4 to create comprehensive integration tests.

## Context

**Why this matters:** Testing infrastructure is the foundation for verifying the installer works. Without proper test isolation (TEST-01 requirement), we risk corrupting the source directory during tests. The test-env.js helper enforces this isolation by ensuring all tests run in /tmp.

**What exists:**
- From Plan 1: All foundation modules (file-operations, path-resolver, template-renderer, etc.)
- From Plan 2: CLI entry point, installer orchestrator, platform detector, templates/
- Project uses ESM (type: "module" in package.json)

**Decisions from context:**
- ALL tests execute in /tmp directory only (from CONTEXT.md TEST-01 requirement)
- Each test gets unique isolated folder /tmp/gsd-test-{timestamp}/ (from CONTEXT.md)
- Tests clean up after success, may leave failed tests for debugging (from CONTEXT.md TEST-02)
- Use Vitest for testing (native ESM support, parallel execution)

**Requirements covered:**
- TEST-01: Testing isolation (all tests in /tmp)
- TEST-02: Test cleanup

**Dependencies:**
- Plans 1 and 2 must complete (need installer implementation to test)

## Tasks

<task name="add-test-dependencies" type="auto">
  <files>package.json</files>
  <action>
Add testing dependencies and test script to package.json:

```bash
# Install testing libraries
npm install --save-dev vitest @vitest/ui
```

Add test script to package.json:
```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest watch",
    "test:ui": "vitest --ui"
  }
}
```

**Why Vitest:**
- Native ESM support (our project uses type: "module")
- Fast execution with parallel test running
- Compatible API with Jest (familiar for most developers)
- Built-in coverage support
- Small bundle size

Alternative considered: Node's built-in test runner (node:test). Vitest chosen for better assertion library and parallel execution.
  </action>
  <verify>
```bash
# Verify dependencies installed
npm ls vitest @vitest/ui

# Verify test script exists
cat package.json | grep '"test":'
```
  </verify>
  <done>package.json includes vitest dependencies and test scripts</done>
</task>

<task name="create-test-environment-helper" type="auto">
  <files>tests/helpers/test-env.js</files>
  <action>
Create test environment helper that creates isolated /tmp directories for testing.

**Purpose:** Enforce TEST-01 requirement that all tests execute in /tmp, never in source directory.

**Implementation:**
```javascript
import { mkdtempSync, rmSync, mkdirSync, cpSync } from 'fs';
import { tmpdir } from 'os';
import { join } from 'path';
import { execSync } from 'child_process';

/**
 * Creates isolated test environment in /tmp
 * Returns { testDir, cleanup, installCmd }
 */
export function createTestEnv() {
  // Create unique /tmp directory
  const testDir = mkdtempSync(join(tmpdir(), 'gsd-test-'));
  
  // Get source directory (where package.json lives)
  const sourceDir = join(import.meta.dirname, '../..');
  
  return {
    testDir,
    sourceDir,
    
    /**
     * Run installer command in test directory
     * Example: installCmd('--claude --local')
     */
    installCmd(args = '') {
      const cmd = `node "${join(sourceDir, 'bin/install.js')}" ${args}`;
      return execSync(cmd, { 
        cwd: testDir,
        encoding: 'utf-8',
        env: { ...process.env, FORCE_COLOR: '0' } // Disable colors in tests
      });
    },
    
    /**
     * Copy templates to test directory (for testing build script)
     */
    copyTemplates() {
      const templatesDir = join(sourceDir, 'templates');
      const destDir = join(testDir, 'templates');
      cpSync(templatesDir, destDir, { recursive: true });
    },
    
    /**
     * Copy source files to test directory (for testing build script)
     */
    copySource() {
      const githubDir = join(sourceDir, '.github');
      const gsdDir = join(sourceDir, 'get-shit-done');
      
      cpSync(githubDir, join(testDir, '.github'), { recursive: true });
      cpSync(gsdDir, join(testDir, 'get-shit-done'), { recursive: true });
    },
    
    /**
     * Cleanup test directory (called after successful test)
     */
    cleanup() {
      try {
        rmSync(testDir, { recursive: true, force: true });
      } catch (error) {
        // Ignore cleanup errors (failed tests may want to inspect directory)
        console.warn(`Warning: Failed to cleanup ${testDir}`);
      }
    }
  };
}

/**
 * Creates isolated test environment and auto-cleans up
 * Use in tests: const env = await withTestEnv(async (env) => { ... })
 */
export async function withTestEnv(testFn) {
  const env = createTestEnv();
  try {
    await testFn(env);
    env.cleanup();
  } catch (error) {
    // Don't cleanup on error - allow inspection
    console.error(`Test failed. Inspect: ${env.testDir}`);
    throw error;
  }
}
```

Export both createTestEnv (manual control) and withTestEnv (auto-cleanup) for flexibility.
  </action>
  <verify>
```bash
# Test helper can create and cleanup test environments
node -e "
import { createTestEnv } from './tests/helpers/test-env.js';
import { existsSync } from 'fs';

const env = createTestEnv();
console.assert(existsSync(env.testDir), 'Test dir not created');
console.assert(env.testDir.includes('/tmp/gsd-test-'), 'Test dir not in /tmp');

env.cleanup();
console.assert(!existsSync(env.testDir), 'Test dir not cleaned up');

console.log('✓ Test environment helper works');
"
```
  </verify>
  <done>tests/helpers/test-env.js exists with createTestEnv and withTestEnv functions</done>
</task>

## Verification

After completing both tasks, verify the test infrastructure is ready:

```bash
# 1. Verify dependencies installed
npm ls vitest @vitest/ui

# 2. Verify test script exists
npm run test --version 2>&1 | head -1

# 3. Test environment helper works
node -e "
import { createTestEnv } from './tests/helpers/test-env.js';
import { existsSync } from 'fs';

const env = createTestEnv();
console.assert(existsSync(env.testDir), 'Test dir not created');
console.assert(env.testDir.includes('/tmp/gsd-test-'), 'Test dir not in /tmp');

env.cleanup();
console.assert(!existsSync(env.testDir), 'Test dir not cleaned up');

console.log('✓ Test infrastructure ready');
"

# 4. Verify test-env can run installer command
node -e "
import { createTestEnv } from './tests/helpers/test-env.js';

const env = createTestEnv();
try {
  // Try to run installer with --help (should work even without templates)
  const output = env.installCmd('--help');
  console.assert(output.includes('Install to Claude Code'), 'Installer help not working');
  console.log('✓ installCmd() helper works');
} finally {
  env.cleanup();
}
"
```

## Success Criteria

**Observable outcomes:**
- [ ] Vitest installed and `npm test` command works
- [ ] test-env.js creates unique /tmp directories for each test
- [ ] test-env.js provides installCmd() that runs the installer
- [ ] test-env.js cleanup() removes test directories after success
- [ ] All test environments isolated in /tmp (never in source directory)

**Required artifacts:**
- [x] package.json with vitest dev dependencies
- [x] package.json with test, test:watch, test:ui scripts
- [x] tests/helpers/test-env.js with createTestEnv and withTestEnv functions

**Wiring validated:**
- [x] npm test invokes vitest
- [x] test-env.js creates /tmp/gsd-test-* directories
- [x] test-env.js can execute bin/install.js from test directory
- [x] test-env.js cleans up test directories on success

**Key links functional:**
- [x] `npm test` runs vitest (even with no test files yet)
- [x] test-env.js enforces TEST-01 requirement (all tests in /tmp)
- [x] Ready for Plan 4 to create integration test suites

## Output

**Files created:**
- `tests/helpers/test-env.js` — Isolated test environment helper with /tmp enforcement

**Files modified:**
- `package.json` — Added vitest dependencies and test scripts

**Next step:** Plan 4 will create the actual integration test suites (install.test.js, template-rendering.test.js, error-scenarios.test.js) and human verification checkpoint.
