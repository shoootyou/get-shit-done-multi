---
phase: 01-core-installer
plan: 03
type: execute
wave: 3
depends_on: [01, 02]
files_modified:
  - test/integration/install.test.js
  - test/helpers/test-env.js
  - package.json (test script)
autonomous: true
must_haves:
  observables:
    - Tests execute in /tmp, never in source directory
    - End-to-end installation test passes
    - Template variable replacement verified in output
    - Installation completes in <30 seconds
    - All 29 skills and 13 agents installed correctly
  artifacts:
    - test/integration/install.test.js (E2E test)
    - test/helpers/test-env.js (test isolation utilities)
  wiring:
    - Test creates isolated /tmp environment
    - Test runs actual npx installer
    - Test verifies output files and content
  key_links:
    - test-env.js creates /tmp/gsd-test-{timestamp}/
    - install.test.js verifies variables replaced correctly
    - Cleanup removes test directories after success
---

# Phase 1, Plan 3: Integration Testing & Verification

## Objective

Create integration tests that verify end-to-end installation works correctly, all templates are rendered properly, and the phase success criteria are met. All tests execute in `/tmp` with proper isolation.

## Context

**What exists (from Plans 1-2):**
- Working NPX entry point with CLI
- Core modules (io, paths, rendering, errors)
- Templates (29 skills + 13 agents converted)
- Installation orchestrator

**What's needed:**
- Integration test that verifies complete flow
- Test utilities for /tmp isolation
- Verification of all success criteria

**Critical constraints:**
- ALL tests MUST execute in /tmp
- Each test gets unique folder: /tmp/gsd-test-{timestamp}/
- NEVER test in source directory
- NEVER modify source files
- Clean up test directories after success

## Tasks

<task name="create-test-environment-helper" type="auto">
  <files>test/helpers/test-env.js</files>
  <action>
Create `test/helpers/test-env.js` with test isolation utilities:

```javascript
import fs from 'fs-extra';
import path from 'path';
import os from 'os';

/**
 * Create isolated test environment in /tmp
 * Returns: { testDir, cleanup }
 */
export async function createTestEnv(testName = 'test') {
  const timestamp = Date.now();
  const testDir = path.join('/tmp', `gsd-test-${testName}-${timestamp}`);
  
  // Ensure test directory exists
  await fs.ensureDir(testDir);
  
  // Cleanup function
  const cleanup = async () => {
    await fs.remove(testDir);
  };
  
  return { testDir, cleanup };
}

/**
 * Mock home directory for installation tests
 * Creates a fake home directory in test environment
 */
export function mockHomeDir(testDir) {
  const fakeHome = path.join(testDir, 'home');
  fs.ensureDirSync(fakeHome);
  
  // Store original
  const originalHome = os.homedir;
  
  // Override os.homedir()
  os.homedir = () => fakeHome;
  
  // Restore function
  const restore = () => {
    os.homedir = originalHome;
  };
  
  return { fakeHome, restore };
}

/**
 * Verify installation output
 * Checks that files exist and templates rendered correctly
 */
export async function verifyInstallation(installPath, options = {}) {
  const errors = [];
  
  // Check skills directory exists
  const skillsExist = await fs.pathExists(installPath);
  if (!skillsExist) {
    errors.push(`Skills directory not found: ${installPath}`);
    return errors;
  }
  
  // Count skills (should be 29)
  const skills = await fs.readdir(installPath);
  const skillDirs = skills.filter(name => name.startsWith('gsd-'));
  if (skillDirs.length !== 29) {
    errors.push(`Expected 29 skills, found ${skillDirs.length}`);
  }
  
  // Verify template variables replaced (sample check)
  const sampleSkill = path.join(installPath, 'gsd-new-project', 'SKILL.md');
  if (await fs.pathExists(sampleSkill)) {
    const content = await fs.readFile(sampleSkill, 'utf-8');
    
    // Should NOT contain template variables
    if (content.includes('{{PLATFORM_ROOT}}')) {
      errors.push('Template variables not replaced in output');
    }
    
    // SHOULD contain rendered values
    if (!content.includes('.claude/')) {
      errors.push('Expected .claude/ in rendered output');
    }
    if (!content.includes('/gsd-')) {
      errors.push('Expected /gsd- command prefix in output');
    }
  } else {
    errors.push('Sample skill not found for verification');
  }
  
  return errors;
}
```

This provides test isolation, home directory mocking, and verification utilities.
  </action>
  <verify>
Test the test utilities:

```bash
node -e "
import { createTestEnv, verifyInstallation } from './test/helpers/test-env.js';

const { testDir, cleanup } = await createTestEnv('utility-check');
console.log('Test dir created:', testDir);
console.log('Exists:', await import('fs-extra').then(fs => fs.pathExists(testDir)));
await cleanup();
console.log('Cleaned up');
"
```

Output shows test dir created and cleaned up
  </verify>
  <done>Test environment utilities created and verified</done>
</task>

<task name="create-integration-test" type="auto">
  <files>test/integration/install.test.js</files>
  <action>
Create `test/integration/install.test.js` that tests complete installation:

```javascript
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import fs from 'fs-extra';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { createTestEnv, mockHomeDir, verifyInstallation } from '../helpers/test-env.js';

const execAsync = promisify(exec);

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = path.join(__dirname, '../..');

/**
 * Integration test for Phase 1 installer
 * Tests complete flow: npx ‚Üí installation ‚Üí verification
 */
async function testInstallation() {
  console.log('üß™ Starting integration test...\n');
  
  // Create isolated test environment
  const { testDir, cleanup } = await createTestEnv('install');
  console.log('‚úì Test environment created:', testDir);
  
  try {
    // Mock home directory
    const { fakeHome, restore } = mockHomeDir(testDir);
    console.log('‚úì Home directory mocked:', fakeHome);
    
    try {
      // Run installer
      console.log('Running installer...');
      const startTime = Date.now();
      
      const { stdout, stderr } = await execAsync(
        `node ${path.join(projectRoot, 'bin/install.js')} --claude`,
        { 
          cwd: testDir,
          env: { ...process.env, HOME: fakeHome }
        }
      );
      
      const duration = Date.now() - startTime;
      console.log(`‚úì Installation completed in ${duration}ms`);
      
      // Check duration (<30 seconds)
      if (duration > 30000) {
        throw new Error(`Installation too slow: ${duration}ms (max 30000ms)`);
      }
      
      // Check success message
      if (!stdout.includes('Installation complete')) {
        throw new Error('Missing success message in output');
      }
      console.log('‚úì Success message displayed');
      
      // Verify installation
      const installPath = path.join(fakeHome, '.claude', 'skills', 'gsd');
      const errors = await verifyInstallation(installPath);
      
      if (errors.length > 0) {
        throw new Error(`Verification failed:\n${errors.join('\n')}`);
      }
      console.log('‚úì Installation verified (29 skills)');
      
      // Verify shared directory
      const sharedPath = path.join(fakeHome, '.claude', 'get-shit-done');
      const sharedExists = await fs.pathExists(sharedPath);
      if (!sharedExists) {
        throw new Error('Shared directory not copied');
      }
      console.log('‚úì Shared directory copied');
      
      // Verify manifest
      const manifestPath = path.join(sharedPath, '.gsd-install-manifest.json');
      const manifestExists = await fs.pathExists(manifestPath);
      if (!manifestExists) {
        throw new Error('Manifest not created');
      }
      
      const manifest = await fs.readJson(manifestPath);
      if (manifest.version !== '2.0.0') {
        throw new Error(`Wrong version in manifest: ${manifest.version}`);
      }
      if (manifest.platform !== 'claude') {
        throw new Error(`Wrong platform in manifest: ${manifest.platform}`);
      }
      console.log('‚úì Manifest created with correct version');
      
      // Verify agents (13 flat files)
      const agentFiles = (await fs.readdir(installPath))
        .filter(name => name.endsWith('.agent.md'));
      if (agentFiles.length !== 13) {
        throw new Error(`Expected 13 agents, found ${agentFiles.length}`);
      }
      console.log('‚úì Agents installed (13 files)');
      
      console.log('\n‚úÖ All tests passed!\n');
      
    } finally {
      restore();
    }
    
    // Cleanup test directory
    await cleanup();
    console.log('‚úì Test environment cleaned up');
    
  } catch (error) {
    console.error('\n‚ùå Test failed:', error.message);
    // Don't cleanup on failure (leave for debugging)
    console.log('Test directory preserved for debugging:', testDir);
    process.exit(1);
  }
}

// Run test
testInstallation();
```

This test:
- Creates isolated /tmp environment
- Mocks home directory
- Runs actual installer
- Verifies all output
- Cleans up on success, preserves on failure
  </action>
  <verify>
Run the integration test:

```bash
node test/integration/install.test.js
```

Test should pass with all checkmarks, cleanup after success
  </verify>
  <done>Integration test created and passing</done>
</task>

<task name="add-test-script-to-package-json" type="auto">
  <files>package.json</files>
  <action>
Add test script to package.json:

```json
{
  "scripts": {
    "test": "node test/integration/install.test.js",
    "test:cleanup": "rm -rf /tmp/gsd-test-*"
  }
}
```

This allows running tests with `npm test` and cleaning up failed test directories with `npm run test:cleanup`.
  </action>
  <verify>
```bash
npm test
```

Test runs and passes
  </verify>
  <done>Test script added to package.json</done>
</task>

<task name="verify-all-phase-success-criteria" type="auto">
  <files>None (manual verification)</files>
  <action>
Verify all Phase 1 success criteria from ROADMAP.md:

**From ROADMAP.md Phase 1 Success Criteria:**

1. ‚úÖ **User runs `npx get-shit-done-multi --claude`** ‚Üí verify with:
   ```bash
   npx . --claude
   ```
   Check: Installation succeeds

2. ‚úÖ **All 29 skills from `.github/skills/` converted to templates** ‚Üí verify with:
   ```bash
   ls -1 templates/skills/ | wc -l
   ```
   Check: Shows 29

3. ‚úÖ **All 13 agents from `.github/agents/` converted to templates** ‚Üí verify with:
   ```bash
   ls -1 templates/agents/*.agent.md | wc -l
   ```
   Check: Shows 13

4. ‚úÖ **Shared directory copies to `.claude/get-shit-done/`** ‚Üí verify with:
   ```bash
   ls ~/.claude/get-shit-done/
   ```
   Check: Directory exists with contents

5. ‚úÖ **Template variables replaced correctly** ‚Üí verify with:
   ```bash
   grep -L "{{PLATFORM_ROOT}}" ~/.claude/skills/gsd/gsd-new-project/SKILL.md
   grep "\.claude/" ~/.claude/skills/gsd/gsd-new-project/SKILL.md
   ```
   Check: No template vars, has rendered values

6. ‚úÖ **Skill structure: `.claude/skills/gsd-<name>/SKILL.md`** ‚Üí verify with:
   ```bash
   ls ~/.claude/skills/gsd/gsd-new-project/SKILL.md
   ```
   Check: Directory-based structure correct

7. ‚úÖ **Installation completes in <30 seconds** ‚Üí verified by integration test

8. ‚úÖ **`--help` and `--version` flags work** ‚Üí verify with:
   ```bash
   npx . --help
   npx . --version
   ```
   Check: Both show correct information

9. ‚úÖ **Version displays as 2.0.0** ‚Üí verified by --version output

**Run these manual checks and confirm all pass.**
  </action>
  <verify>
Create verification script:

```bash
cat > verify-phase-1.sh << 'EOF'
#!/bin/bash
echo "Verifying Phase 1 Success Criteria..."
echo ""

# 1. Templates exist
SKILL_COUNT=$(ls -1 templates/skills/ | wc -l | tr -d ' ')
echo "Skills in templates: $SKILL_COUNT (expected: 29)"

AGENT_COUNT=$(ls -1 templates/agents/*.agent.md | wc -l | tr -d ' ')
echo "Agents in templates: $AGENT_COUNT (expected: 13)"

# 2. Version check
VERSION=$(node bin/install.js --version 2>&1 | grep -o "[0-9]\+\.[0-9]\+\.[0-9]\+")
echo "Version: $VERSION (expected: 2.0.0)"

# 3. Help works
node bin/install.js --help > /dev/null 2>&1
if [ $? -eq 0 ]; then
  echo "Help flag: ‚úì works"
else
  echo "Help flag: ‚úó failed"
fi

# 4. Integration test passes
npm test > /dev/null 2>&1
if [ $? -eq 0 ]; then
  echo "Integration test: ‚úì passed"
else
  echo "Integration test: ‚úó failed"
fi

echo ""
echo "Verification complete!"
EOF

chmod +x verify-phase-1.sh
./verify-phase-1.sh
```

All checks should pass
  </verify>
  <done>All Phase 1 success criteria verified</done>
</task>

<task name="document-testing-constraints" type="auto">
  <files>test/README.md</files>
  <action>
Create `test/README.md` documenting testing constraints:

```markdown
# Testing Guidelines

## Critical Constraints

**ALL testing activities MUST follow these rules:**

### Test Location
- ALL tests execute under `/tmp` directory only
- Each test gets unique folder: `/tmp/gsd-test-{name}-{timestamp}/`
- NEVER test in source directory
- NEVER test in current working directory

### Source Protection
- CANNOT execute installation in current source directory
- CANNOT modify source files in `.github/`, `.claude/`, `.codex/`, `get-shit-done/`
- Applies to: Manual testing, automated testing, verification, ALL phases

### Test Cleanup
- Tests SHOULD cleanup `/tmp/gsd-test-*` folders after successful completion
- Tests MAY leave folders on failure for debugging
- Use `npm run test:cleanup` to remove all test directories

### Example Test Pattern

```bash
# ‚úÖ CORRECT: Create isolated test environment
TEST_DIR="/tmp/gsd-test-$(date +%s)"
mkdir -p "$TEST_DIR"
cd "$TEST_DIR"
npx /path/to/source/package --claude

# ‚ùå WRONG: Testing in source directory
cd /path/to/source
npx . --claude  # NEVER DO THIS
```

## Running Tests

```bash
# Run integration tests
npm test

# Clean up test directories
npm run test:cleanup
```

## Test Structure

```
test/
‚îú‚îÄ‚îÄ integration/       # End-to-end tests
‚îÇ   ‚îî‚îÄ‚îÄ install.test.js
‚îú‚îÄ‚îÄ helpers/           # Test utilities
‚îÇ   ‚îî‚îÄ‚îÄ test-env.js
‚îî‚îÄ‚îÄ README.md          # This file
```
```

This documents the critical testing constraints for future developers.
  </action>
  <verify>
```bash
cat test/README.md | grep "/tmp"
cat test/README.md | grep "NEVER"
```

Documentation exists with constraints clearly stated
  </verify>
  <done>Testing constraints documented in test/README.md</done>
</task>

## Verification

**Must work:**
1. Integration test passes with all checks
2. Tests execute in `/tmp` only
3. Test creates unique timestamped directories
4. Verification checks 29 skills + 13 agents installed
5. Template variables confirmed replaced in output
6. Installation completes in <30 seconds
7. Test cleanup works (on success)
8. Failed tests preserve directories for debugging

**Files exist:**
- `test/integration/install.test.js`
- `test/helpers/test-env.js`
- `test/README.md`
- `verify-phase-1.sh` (verification script)

**Source protection:**
- No source files modified during testing
- All tests in `/tmp` directories

## Success Criteria

Phase 1 complete when:
- ‚úÖ Integration test passes all checks
- ‚úÖ All 9 ROADMAP success criteria verified
- ‚úÖ Tests execute in `/tmp` with proper isolation
- ‚úÖ Installation completes in <30 seconds
- ‚úÖ 29 skills + 13 agents installed correctly
- ‚úÖ Template variables replaced in output
- ‚úÖ Shared directory and manifest created
- ‚úÖ `--help` and `--version` work correctly
- ‚úÖ Testing constraints documented

## Output

**Deliverables:**
- Integration test suite
- Test isolation utilities
- Verification script for manual checks
- Testing documentation
- Clean test cleanup mechanism

**Phase 1 Status:** COMPLETE - Ready for Phase 2 (Multi-Platform Support)
