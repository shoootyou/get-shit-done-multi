---
phase: 01-core-installer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/build-templates.js
  - bin/lib/io/file-operations.js
  - bin/lib/paths/path-resolver.js
  - bin/lib/cli/output.js
  - bin/lib/cli/errors.js
  - package.json
autonomous: true
must_haves:
  observables:
    - Run `npm run build:templates` ‚Üí templates/ directory created with 28 skill dirs + 13 agent files + 1 shared dir
    - Template files contain {{VARIABLES}} where platform-specific values were
    - package.json has prepublishOnly hook that runs build:templates
  artifacts:
    - scripts/build-templates.js (copies .github/ ‚Üí templates/ with variable injection)
    - bin/lib/io/file-operations.js (fs-extra wrappers for copy, mkdir, write)
    - bin/lib/paths/path-resolver.js (path.join, os.homedir, normalization)
  wiring:
    - build-templates.js imports io/file-operations.js for copying
    - prepublishOnly npm hook calls build:templates script
  key_links:
    - package.json "prepublishOnly" ‚Üí scripts/build-templates.js
    - build-templates.js ‚Üí io/file-operations.js
---

# Phase 1, Plan 1: Foundation & Core Modules

## Objective

Build the template generation system and core utility modules. User runs `npm run build:templates` and gets self-contained templates/ directory with 42 items (28 skills + 13 agents + 1 shared directory), each with {{VARIABLES}} injected at correct replacement points.

## Context

Phase 1 uses a **pre-build approach**: templates are generated from `.github/` source at package publish time using the `prepublishOnly` npm hook. This ensures the NPM package is self-contained with rendered templates ready for variable substitution at runtime.

**Research findings:**
- Pre-build strategy recommended for NPM self-containment
- Runtime substitution enables {{INSTALL_DATE}}, {{USER}} variables
- Mock HOME approach for testing isolation
- Domain-organized modules under bin/lib/

**Key decisions:**
- Build script runs before npm publish (prepublishOnly hook)
- Templates generated by copying .github/ ‚Üí templates/ with variable injection
- Core modules provide reusable operations for build script AND installer

## Tasks

<task name="create-build-script" type="auto">
  <files>scripts/build-templates.js</files>
  <action>
Create template build script that converts source files to templates:

**Script: scripts/build-templates.js**
```javascript
#!/usr/bin/env node

import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(__dirname, '..');

async function buildTemplates() {
  console.log('üèóÔ∏è  Building templates from .github/...');
  
  // 1. Clean and create templates directory
  const templatesDir = path.join(rootDir, 'templates');
  await fs.remove(templatesDir);
  await fs.ensureDir(templatesDir);
  
  // 2. Copy skills (28 directories)
  const skillsSourceDir = path.join(rootDir, '.github/skills');
  const skillsDestDir = path.join(templatesDir, 'skills');
  await fs.ensureDir(skillsDestDir);
  
  const skillDirs = await fs.readdir(skillsSourceDir);
  
  let skillCount = 0;
  for (const skillDir of skillDirs) {
    if (skillDir === 'get-shit-done') continue; // Handle separately
    
    const srcPath = path.join(skillsSourceDir, skillDir);
    const stat = await fs.stat(srcPath);
    
    if (stat.isDirectory()) {
      const destPath = path.join(skillsDestDir, skillDir);
      await fs.copy(srcPath, destPath);
      
      // Convert SKILL.md to template
      const skillFile = path.join(destPath, 'SKILL.md');
      if (await fs.pathExists(skillFile)) {
        await convertToTemplate(skillFile);
        skillCount++;
      }
    }
  }
  
  // 3. Copy agents (13 flat files)
  const agentsSourceDir = path.join(rootDir, '.github/agents');
  const agentsDestDir = path.join(templatesDir, 'agents');
  await fs.ensureDir(agentsDestDir);
  
  const agentFiles = await fs.readdir(agentsSourceDir);
  let agentCount = 0;
  
  for (const agentFile of agentFiles) {
    if (agentFile.endsWith('.agent.md')) {
      const srcPath = path.join(agentsSourceDir, agentFile);
      const destPath = path.join(agentsDestDir, agentFile);
      await fs.copy(srcPath, destPath);
      await convertToTemplate(destPath);
      agentCount++;
    }
  }
  
  // 4. Copy shared directory
  const sharedSrc = path.join(skillsSourceDir, 'get-shit-done');
  const sharedDest = path.join(templatesDir, 'get-shit-done');
  await fs.copy(sharedSrc, sharedDest);
  
  // Add manifest template
  const manifestPath = path.join(sharedDest, '.gsd-install-manifest.json');
  const manifest = {
    version: '{{VERSION}}',
    platform: '{{PLATFORM_NAME}}',
    scope: '{{SCOPE}}',
    installedAt: '{{INSTALL_DATE}}',
    installedBy: '{{USER}}',
    installerVersion: '2.0.0'
  };
  await fs.writeJSON(manifestPath, manifest, { spaces: 2 });
  
  console.log(`‚úì Built ${skillCount} skills, ${agentCount} agents, 1 shared directory`);
}

async function convertToTemplate(filePath) {
  let content = await fs.readFile(filePath, 'utf-8');
  
  // Replace platform-specific hardcoded values with template variables
  content = content
    .replace(/\.github\//g, '{{PLATFORM_ROOT}}')
    .replace(/\.claude\//g, '{{PLATFORM_ROOT}}')
    .replace(/\.codex\//g, '{{PLATFORM_ROOT}}')
    .replace(/\/gsd-/g, '{{COMMAND_PREFIX}}')
    .replace(/\$gsd-/g, '{{COMMAND_PREFIX}}');
  
  await fs.writeFile(filePath, content, 'utf-8');
}

buildTemplates().catch(error => {
  console.error('‚ùå Build failed:', error.message);
  process.exit(1);
});
```

**Add npm scripts to package.json:**
```json
{
  "scripts": {
    "build:templates": "node scripts/build-templates.js",
    "clean:templates": "rm -rf templates/",
    "prebuild": "npm run clean:templates",
    "build": "npm run build:templates",
    "prepublishOnly": "npm run build"
  },
  "files": [
    "bin/",
    "templates/",
    "README.md",
    "LICENSE"
  ]
}
```

**Implementation notes:**
- Script copies directory structure, then converts files in place
- convertToTemplate replaces platform-specific values with {{VARIABLES}}
- Manifest template added to get-shit-done/ directory
- prepublishOnly hook ensures templates built before npm publish
  </action>
  <verify>
Run: `npm run build:templates`

Check:
- templates/ directory exists
- templates/skills/ has 28 directories (gsd-*)
- templates/agents/ has 13 .agent.md files
- templates/get-shit-done/ directory exists
- templates/get-shit-done/.gsd-install-manifest.json exists with {{VARIABLES}}
- Sample file contains {{PLATFORM_ROOT}} instead of .github/
- Sample file contains {{COMMAND_PREFIX}} instead of /gsd-

Verify prepublishOnly:
- package.json has "prepublishOnly": "npm run build"
- templates/ is listed in "files" array
  </verify>
  <done>
‚úì Build script creates templates/ with 28 skills + 13 agents + 1 shared directory
‚úì Template files contain {{VARIABLES}} at correct injection points
‚úì prepublishOnly hook configured to run build before publish
  </done>
</task>

<task name="create-file-operations-module" type="auto">
  <files>bin/lib/io/file-operations.js</files>
  <action>
Create file operations module wrapping fs-extra with error handling:

**Module: bin/lib/io/file-operations.js**
```javascript
import fs from 'fs-extra';
import path from 'path';

/**
 * Copy file with error handling
 */
export async function copyFile(src, dest) {
  try {
    await fs.copy(src, dest, { overwrite: true });
  } catch (error) {
    throw formatFileError(error, 'copy', dest);
  }
}

/**
 * Copy directory recursively with error handling
 */
export async function copyDirectory(src, dest) {
  try {
    await fs.copy(src, dest, { overwrite: true });
  } catch (error) {
    throw formatFileError(error, 'copy directory', dest);
  }
}

/**
 * Create directory (recursive, like mkdir -p)
 */
export async function createDirectory(dirPath) {
  try {
    await fs.ensureDir(dirPath);
  } catch (error) {
    throw formatFileError(error, 'create directory', dirPath);
  }
}

/**
 * Write file with automatic parent directory creation
 */
export async function writeFile(filePath, content) {
  try {
    await fs.outputFile(filePath, content, 'utf-8');
  } catch (error) {
    throw formatFileError(error, 'write', filePath);
  }
}

/**
 * Read file
 */
export async function readFile(filePath) {
  try {
    return await fs.readFile(filePath, 'utf-8');
  } catch (error) {
    throw formatFileError(error, 'read', filePath);
  }
}

/**
 * Check if path exists
 */
export async function pathExists(filePath) {
  return await fs.pathExists(filePath);
}

/**
 * Read directory contents
 */
export async function readDirectory(dirPath) {
  try {
    return await fs.readdir(dirPath);
  } catch (error) {
    throw formatFileError(error, 'read directory', dirPath);
  }
}

/**
 * Check if path is a symlink and get target
 */
export async function checkSymlink(filePath) {
  try {
    const stats = await fs.lstat(filePath);
    if (stats.isSymbolicLink()) {
      const target = await fs.readlink(filePath);
      return { isSymlink: true, target };
    }
    return { isSymlink: false };
  } catch (error) {
    return { isSymlink: false };
  }
}

/**
 * Format filesystem errors with actionable messages
 */
function formatFileError(error, operation, filePath) {
  const baseMessage = `Failed to ${operation}: ${filePath}`;
  
  switch (error.code) {
    case 'EACCES':
      return new Error(`${baseMessage}\n\nFix: Check directory permissions or create directory manually`);
    
    case 'ENOSPC':
      return new Error(`${baseMessage}\n\nFix: Free up disk space (requires at least 50MB)`);
    
    case 'ENOENT':
      return new Error(`${baseMessage}\n\nFix: Path does not exist or is invalid`);
    
    case 'EEXIST':
      return new Error(`${baseMessage}\n\nFix: File or directory already exists`);
    
    default:
      return new Error(`${baseMessage}\n\nError: ${error.message}`);
  }
}
```

**Implementation notes:**
- All functions throw formatted errors with specific fixes
- copyDirectory overwrites by default (Phase 1 behavior)
- writeFile creates parent directories automatically (fs.outputFile)
- checkSymlink used for warning messages
  </action>
  <verify>
Test file operations module by creating a simple test script and running it.
  </verify>
  <done>
‚úì File operations module created with fs-extra wrappers
‚úì Error handling provides actionable fix messages
  </done>
</task>

<task name="create-path-resolver-module" type="auto">
  <files>bin/lib/paths/path-resolver.js</files>
  <action>
Create path resolution module for cross-platform path operations:

**Module: bin/lib/paths/path-resolver.js**
```javascript
import path from 'path';
import os from 'os';

/**
 * Get home directory (cross-platform)
 */
export function getHomeDirectory() {
  return os.homedir();
}

/**
 * Resolve platform-specific installation path
 * @param {string} platform - 'claude', 'copilot', 'codex'
 * @param {boolean} isGlobal - true for ~/.xxx/, false for .xxx/
 */
export function getInstallPath(platform, isGlobal = true) {
  const platformDirs = {
    claude: '.claude',
    copilot: '.copilot',
    codex: '.codex'
  };
  
  const platformDir = platformDirs[platform];
  if (!platformDir) {
    throw new Error(`Unknown platform: ${platform}`);
  }
  
  if (isGlobal) {
    return path.join(getHomeDirectory(), platformDir);
  } else {
    return path.join(process.cwd(), platformDir);
  }
}

/**
 * Get skills installation directory
 */
export function getSkillsPath(platform, isGlobal = true) {
  const basePath = getInstallPath(platform, isGlobal);
  return path.join(basePath, 'skills');
}

/**
 * Get agents installation directory  
 */
export function getAgentsPath(platform, isGlobal = true) {
  const basePath = getInstallPath(platform, isGlobal);
  return path.join(basePath, 'agents');
}

/**
 * Get shared directory installation path
 */
export function getSharedPath(platform, isGlobal = true) {
  const basePath = getInstallPath(platform, isGlobal);
  return path.join(basePath, 'get-shit-done');
}

/**
 * Normalize path (resolve . and .., remove duplicate separators)
 */
export function normalizePath(filePath) {
  return path.normalize(filePath);
}

/**
 * Join paths safely (never use string concatenation)
 */
export function joinPaths(...parts) {
  return path.join(...parts);
}

/**
 * Resolve path to absolute
 */
export function resolvePath(filePath) {
  return path.resolve(filePath);
}

/**
 * Get path relative to another path
 */
export function getRelativePath(from, to) {
  return path.relative(from, to);
}

/**
 * Basic path validation (Phase 1 - minimal)
 * Phase 6 will add deeper security validation
 */
export function validatePath(filePath) {
  // Basic check: reject paths with obvious traversal attempts
  const normalized = path.normalize(filePath);
  
  if (normalized.includes('..')) {
    throw new Error(`Invalid path (contains ..): ${filePath}`);
  }
  
  return normalized;
}

/**
 * Detect if path is inside target directory (basic containment check)
 */
export function isPathInside(childPath, parentPath) {
  const relative = path.relative(parentPath, childPath);
  return !relative.startsWith('..') && !path.isAbsolute(relative);
}
```

**Implementation notes:**
- Use os.homedir() for home directory (not process.env.HOME)
- Use path.join() for all path operations (never string concat)
- Basic path validation in Phase 1 (deeper security in Phase 6)
- Platform-aware path resolution
  </action>
  <verify>
Test path resolver works correctly with different platforms and validates traversal attempts.
  </verify>
  <done>
‚úì Path resolver module created with cross-platform support
‚úì Platform-specific path resolution working
‚úì Basic path validation implemented
  </done>
</task>

<task name="create-output-modules" type="auto">
  <files>bin/lib/cli/output.js, bin/lib/cli/errors.js</files>
  <action>
Create CLI output and error formatting modules:

**Module: bin/lib/cli/output.js**
```javascript
import chalk from 'chalk';

/**
 * Detect if output should be colored (TTY detection)
 */
export function shouldUseColors() {
  // Respect explicit flags
  if (process.env.NO_COLOR || process.argv.includes('--no-color')) {
    return false;
  }
  
  if (process.env.FORCE_COLOR || process.argv.includes('--color')) {
    return true;
  }
  
  // Auto-detect TTY
  return process.stdout.isTTY;
}

const useColors = shouldUseColors();

/**
 * Print success message with checkmark
 */
export function printSuccess(message) {
  if (useColors) {
    console.log(chalk.green('‚úì') + ' ' + message);
  } else {
    console.log('‚úì ' + message);
  }
}

/**
 * Print error message with X
 */
export function printError(message) {
  if (useColors) {
    console.error(chalk.red('‚úó') + ' ' + message);
  } else {
    console.error('‚úó ' + message);
  }
}

/**
 * Print warning message
 */
export function printWarning(message) {
  if (useColors) {
    console.warn(chalk.yellow('‚ö†') + ' ' + message);
  } else {
    console.warn('‚ö† ' + message);
  }
}

/**
 * Print info message
 */
export function printInfo(message) {
  if (useColors) {
    console.log(chalk.blue('‚Ñπ') + ' ' + message);
  } else {
    console.log('‚Ñπ ' + message);
  }
}

/**
 * Print step message (for progress)
 */
export function printStep(message) {
  if (useColors) {
    console.log(chalk.cyan('‚Üí') + ' ' + message);
  } else {
    console.log('‚Üí ' + message);
  }
}

/**
 * Print completion message with next steps
 */
export function printCompletion(installedPath, platform) {
  console.log('');
  printSuccess('Installation complete!');
  console.log('');
  console.log(`Installed to: ${installedPath}`);
  console.log('');
  console.log('Next steps:');
  console.log('- Restart Claude Code or reload skills');
  console.log('- Run /gsd-new-project to start a new project');
  console.log('');
}

/**
 * Print version information
 */
export function printVersion(version, installations = []) {
  console.log(`get-shit-done-multi v${version}`);
  
  if (installations.length > 0) {
    console.log('');
    console.log('Installed at:');
    installations.forEach(install => {
      console.log(`- ${install.path} (${install.platform})`);
    });
  } else {
    console.log('');
    console.log('(no installations detected)');
  }
}
```

**Module: bin/lib/cli/errors.js**
```javascript
import { printError } from './output.js';

/**
 * Format and print error with exit
 */
export function exitWithError(message, exitCode = 1) {
  printError(message);
  process.exit(exitCode);
}

/**
 * Handle unknown flag error with suggestions
 */
export function handleUnknownFlag(flag, validFlags) {
  const suggestions = findClosestMatches(flag, validFlags);
  
  let message = `Unknown flag: ${flag}`;
  
  if (suggestions.length > 0) {
    message += '\n\nDid you mean: ' + suggestions.join(', ') + '?';
  }
  
  message += '\n\nRun --help for all available flags.';
  
  exitWithError(message);
}

/**
 * Find closest matching flags (simple prefix/substring matching)
 */
function findClosestMatches(input, validOptions, maxResults = 3) {
  const inputLower = input.toLowerCase().replace(/^--?/, '');
  
  const matches = validOptions
    .filter(option => {
      const optionLower = option.toLowerCase().replace(/^--?/, '');
      return optionLower.includes(inputLower) || inputLower.includes(optionLower);
    })
    .slice(0, maxResults);
  
  return matches;
}

/**
 * Handle unsupported platform error
 */
export function handleUnsupportedPlatform(platform) {
  exitWithError(
    `--${platform} is not supported in this version\n\n` +
    `Phase 1 supports --claude only.\n` +
    `Copilot and Codex support coming in Phase 2.`
  );
}

/**
 * Wrap async errors
 */
export async function withErrorHandling(fn) {
  try {
    await fn();
  } catch (error) {
    if (error.message) {
      exitWithError(error.message);
    } else {
      exitWithError('An unexpected error occurred');
    }
  }
}
```

**Implementation notes:**
- Color detection respects NO_COLOR, FORCE_COLOR, --no-color, --color flags
- Auto-detects TTY for appropriate color usage
- Error formatting includes actionable guidance
- Flag suggestion uses simple substring matching (good enough for Phase 1)
  </action>
  <verify>
Test output formatting displays correctly with and without colors.
  </verify>
  <done>
‚úì CLI output module created with color detection
‚úì Error formatting module created with flag suggestions
‚úì Messages display correctly with/without colors
  </done>
</task>

<task name="install-dependencies" type="auto">
  <action>
Install Phase 1 dependencies and update package.json:

**Install dependencies:**
```bash
npm install fs-extra@11.3.3 chalk@5.6.2 commander@14.0.2
```

**Ensure package.json includes these critical fields:**
- `"type": "module"` (ESM support)
- `"engines": { "node": ">=16.7.0" }`
- `"bin": { "get-shit-done-multi": "./bin/install.js" }`
- `"files": ["bin/", "templates/", "get-shit-done/", "README.md", "LICENSE"]`
- prepublishOnly hook in scripts

**Implementation notes:**
- ESM mode required (type: "module")
- Node.js ‚â•16.7.0 for native ESM support
- bin entry points to ./bin/install.js (will be created in Plan 2)
- files array includes bin/, templates/, and shared get-shit-done/
- prepublishOnly ensures templates built before publish
  </action>
  <verify>
Check package installation:

```bash
# Verify dependencies installed
npm list fs-extra chalk commander

# Verify package.json configuration
cat package.json | grep '"type"'
cat package.json | grep -A 2 '"engines"'
cat package.json | grep -A 2 '"bin"'
```

Verify:
- All three dependencies installed and listed
- package.json has correct type: "module"
- engines specifies node >=16.7.0
- bin entry points to ./bin/install.js
  </verify>
  <done>
‚úì Dependencies installed (fs-extra, chalk, commander)
‚úì package.json configured for ESM and NPX entry
‚úì npm hooks configured for template building
  </done>
</task>

## Success Criteria

- [ ] `npm run build:templates` creates templates/ with 28 skills + 13 agents + 1 shared directory
- [ ] Template files contain {{VARIABLES}} where platform-specific values were replaced
- [ ] package.json has prepublishOnly hook that runs build:templates before publish
- [ ] File operations module exists with fs-extra wrappers and error formatting
- [ ] Path resolver module exists with cross-platform path operations
- [ ] CLI output modules exist with color detection and formatting
- [ ] All dependencies installed (fs-extra, chalk, commander)
- [ ] package.json configured for ESM with Node ‚â•16.7.0

## Output

Foundation modules ready for integration in Plan 2:
- ‚úì scripts/build-templates.js
- ‚úì bin/lib/io/file-operations.js
- ‚úì bin/lib/paths/path-resolver.js
- ‚úì bin/lib/cli/output.js
- ‚úì bin/lib/cli/errors.js
- ‚úì package.json with dependencies and npm hooks
