---
phase: 01-core-installer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - bin/lib/paths/path-resolver.js
  - bin/lib/io/file-operations.js
  - bin/lib/rendering/template-renderer.js
autonomous: true
must_haves:
  observables:
    - "bin/lib/ directory structure exists with domains (io/, paths/, rendering/)"
    - "Dependencies installed: fs-extra, chalk, commander appear in package.json and node_modules/"
    - "Path resolver can normalize paths and resolve Claude home directory"
    - "File operations can copy directories and create files recursively"
    - "Template renderer can replace {{VARIABLES}} and validate templates"
  artifacts:
    - package.json (updated with type: module, dependencies)
    - bin/lib/paths/path-resolver.js
    - bin/lib/io/file-operations.js
    - bin/lib/rendering/template-renderer.js
  wiring:
    - All modules export functions that can be imported by orchestrator
    - ESM imports work (__dirname equivalent via import.meta.url)
  key_links:
    - package.json "type": "module" enables ESM across project
    - Each module independently testable (pure functions, no cross-dependencies)
---

# Plan 01: Foundation & Core Modules

**Objective:** Create project structure and implement core utility modules (paths, file operations, template rendering)

## Context

Phase 1 builds a CLI installer for Claude Code. This plan establishes the foundation:
- Project structure (bin/, templates/, bin/lib/ with domain organization)
- Dependencies (fs-extra for file ops, chalk for colors, commander for CLI)
- Core modules that higher-level code will use (paths, file ops, templates)

Research decisions:
- ESM-first ("type": "module")
- Commander for CLI parsing (tiered help, suggestions)
- Custom template renderer (regex-based, no library needed)
- Domain-organized modules (io/, paths/, rendering/)

No platform adapters yet (Phase 2). No interactive prompts yet (Phase 3). No rollback yet (Phase 4).

## Tasks

<task name="setup-structure" type="auto">
  <files>
    package.json
    bin/lib/paths/.gitkeep
    bin/lib/io/.gitkeep
    bin/lib/rendering/.gitkeep
  </files>
  <action>
1. Update package.json:
   - Add "type": "module" for ESM support
   - Confirm "engines": { "node": ">=16.7.0" }
   - Confirm "bin": { "get-shit-done-multi": "bin/install.js" }

2. Install dependencies:
   ```bash
   npm install fs-extra@11.3.3 chalk@5.6.2 commander@14.0.2
   ```

3. Create directory structure:
   ```bash
   mkdir -p bin/lib/paths
   mkdir -p bin/lib/io
   mkdir -p bin/lib/rendering
   mkdir -p templates/skills
   mkdir -p templates/agents
   ```

4. Verify structure:
   ```bash
   ls -la bin/lib/
   # Should show: io/, paths/, rendering/
   
   ls -la package.json
   # Should contain: "type": "module"
   
   npm list fs-extra chalk commander
   # Should show installed versions
   ```
  </action>
  <verify>
    ```bash
    # Check ESM enabled
    grep '"type": "module"' package.json
    
    # Check dependencies installed
    npm list fs-extra chalk commander --depth=0
    
    # Check directory structure
    test -d bin/lib/paths && test -d bin/lib/io && test -d bin/lib/rendering && echo "Structure OK"
    ```
  </verify>
  <done>
    - package.json has "type": "module"
    - fs-extra, chalk, commander installed
    - bin/lib/ structure exists with domains
    - templates/ structure exists
  </done>
</task>

<task name="path-resolver" type="auto">
  <files>bin/lib/paths/path-resolver.js</files>
  <action>
Create bin/lib/paths/path-resolver.js with ESM exports:

**Functions to implement:**

1. `resolvePlatformPath(platform, scope)`
   - platform: 'claude' (only option in Phase 1)
   - scope: 'global' or 'local' (default: 'global')
   - Returns: Absolute path to skills directory
   - Global: `~/.claude/skills/gsd/`
   - Local: `.claude/skills/gsd/`
   - Use os.homedir() and path.join() exclusively

2. `resolveSharedPath(platform, scope)`
   - Returns: Absolute path to shared directory
   - Global: `~/.claude/get-shit-done/`
   - Local: `.claude/get-shit-done/`

3. `normalizePath(inputPath)`
   - Returns: path.resolve(inputPath)
   - Converts to absolute, normalizes separators

4. `isPathSafe(basePath, targetPath)`
   - Basic safety check (Phase 1 level)
   - Returns: true if resolved target is under base
   - Use path.resolve() for both, check startsWith()

**ESM setup:**
```javascript
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
```

**Imports needed:**
```javascript
import path from 'path';
import os from 'os';
```

**Error handling:**
- Throw descriptive errors for unknown platforms
- Never use tilde (~) directly, always os.homedir()
- Never concatenate strings, always path.join()

Reference: RESEARCH.md sections "Path Resolution Cross-Platform" and "Common Pitfalls"
  </action>
  <verify>
    ```bash
    # Verify module loads
    node -e "import('./bin/lib/paths/path-resolver.js').then(m => console.log('Exports:', Object.keys(m)))"
    
    # Quick function test
    node -e "import('./bin/lib/paths/path-resolver.js').then(m => console.log('Claude path:', m.resolvePlatformPath('claude', 'global')))"
    ```
  </verify>
  <done>
    - path-resolver.js exists with ESM exports
    - resolvePlatformPath() returns correct paths
    - Uses os.homedir() and path.join() exclusively
    - Module can be imported successfully
  </done>
</task>

<task name="file-operations" type="auto">
  <files>bin/lib/io/file-operations.js</files>
  <action>
Create bin/lib/io/file-operations.js with fs-extra wrappers:

**Functions to implement:**

1. `copyDirectory(src, dest)`
   - Wraps fs.copy() with standard options
   - Options: { overwrite: true, errorOnExist: false, dereference: true }
   - Async function (returns Promise)
   - Handles symlinks, permissions, special files

2. `ensureDirectory(dirPath)`
   - Wraps fs.ensureDir() (creates parents recursively)
   - Async function
   - Equivalent to mkdir -p

3. `writeFile(filePath, content)`
   - Wraps fs.outputFile() (creates parent dirs automatically)
   - Encoding: 'utf-8'
   - Async function

4. `checkSymlink(targetPath)`
   - Uses fs.lstat() (doesn't follow symlinks)
   - Returns: { isSymlink: boolean, target: string | null }
   - Handles ENOENT gracefully (return { isSymlink: false, target: null })
   - Async function

5. `formatError(error, context)`
   - Takes fs error and operation context
   - Returns user-friendly message based on error.code
   - EACCES → "Permission denied to {context}"
   - ENOSPC → "No space left on device"
   - ENOENT → "Path not found: {context}"
   - Default → error.message

**Imports:**
```javascript
import fs from 'fs-extra';
```

**Error handling:**
- Use try/catch in wrapper functions
- Check error.code for specific errors
- Throw formatted errors with actionable guidance

Reference: RESEARCH.md sections "File Operations with fs-extra" and "Error Handling"
  </action>
  <verify>
    ```bash
    # Verify module loads
    node -e "import('./bin/lib/io/file-operations.js').then(m => console.log('Exports:', Object.keys(m)))"
    
    # Test basic functionality (uses /tmp per testing constraints)
    node -e "
    import('./bin/lib/io/file-operations.js').then(async (m) => {
      const testDir = '/tmp/gsd-test-' + Date.now();
      await m.ensureDirectory(testDir);
      await m.writeFile(testDir + '/test.txt', 'hello');
      console.log('File ops test passed');
    })
    "
    ```
  </verify>
  <done>
    - file-operations.js exists with ESM exports
    - All functions use fs-extra
    - Error handling formats by error.code
    - Module can be imported and tested
  </done>
</task>

<task name="template-renderer" type="auto">
  <files>bin/lib/rendering/template-renderer.js</files>
  <action>
Create bin/lib/rendering/template-renderer.js with custom regex-based rendering:

**Functions to implement:**

1. `renderTemplate(content, variables)`
   - Replaces {{UPPERCASE_VAR}} with values from variables object
   - Single-pass replacement using regex with callback
   - Unknown variables → `[MISSING:VARNAME]`
   - Returns: Rendered string
   - Pattern: `/\{\{([A-Z_]+)\}\}/g`

2. `validateTemplate(content, templatePath)`
   - Checks for balanced braces ({{ and }})
   - Checks for lowercase variables (invalid)
   - Returns: { valid: boolean, errors: string[] }
   - Errors array contains specific issues found

3. `getVariableContext(platform, scope, version)`
   - Returns variables object for template rendering
   - Variables:
     - PLATFORM_ROOT: `.claude/` (for platform)
     - PLATFORM_NAME: `claude`
     - VERSION: `2.0.0` (from version param)
     - COMMAND_PREFIX: `/gsd-`
     - INSTALL_DATE: new Date().toISOString()
     - USER: os.userInfo().username
   - Use os.userInfo() for USER
   - Returns: Object with uppercase keys

**No external template library** - custom regex per research decision.

**Example usage:**
```javascript
const vars = getVariableContext('claude', 'global', '2.0.0');
const rendered = renderTemplate('Welcome {{USER}}!', vars);
// rendered = "Welcome rodolfo!" (or current username)
```

**Validation timing:** Pre-validate all templates before any file writes.

Reference: RESEARCH.md sections "Template Rendering (Custom)" and "Template Variable Behavior"
  </action>
  <verify>
    ```bash
    # Verify module loads
    node -e "import('./bin/lib/rendering/template-renderer.js').then(m => console.log('Exports:', Object.keys(m)))"
    
    # Test rendering
    node -e "
    import('./bin/lib/rendering/template-renderer.js').then(m => {
      const vars = m.getVariableContext('claude', 'global', '2.0.0');
      const result = m.renderTemplate('Platform: {{PLATFORM_NAME}}', vars);
      console.log('Rendered:', result);
      console.log('Expected: Platform: claude');
    })
    "
    
    # Test validation
    node -e "
    import('./bin/lib/rendering/template-renderer.js').then(m => {
      const result = m.validateTemplate('{{VALID}} {{invalid}}', 'test.md');
      console.log('Validation:', result);
    })
    "
    ```
  </verify>
  <done>
    - template-renderer.js exists with ESM exports
    - renderTemplate() uses single-pass regex replacement
    - validateTemplate() checks balanced braces and uppercase
    - getVariableContext() returns correct variables for platform
    - Unknown variables become [MISSING:NAME]
  </done>
</task>

## Verification

**Module Integration Check:**
```bash
# All modules should import successfully
node -e "
Promise.all([
  import('./bin/lib/paths/path-resolver.js'),
  import('./bin/lib/io/file-operations.js'),
  import('./bin/lib/rendering/template-renderer.js')
]).then(() => console.log('✓ All modules load successfully'))
"
```

**Path Resolution Check:**
```bash
node -e "
import('./bin/lib/paths/path-resolver.js').then(m => {
  console.log('Claude global:', m.resolvePlatformPath('claude', 'global'));
  console.log('Claude local:', m.resolvePlatformPath('claude', 'local'));
  console.log('Shared global:', m.resolveSharedPath('claude', 'global'));
})
"
```

**Expected output:**
- Claude global: `/Users/{username}/.claude/skills/gsd/`
- Claude local: `{pwd}/.claude/skills/gsd/`
- Shared global: `/Users/{username}/.claude/get-shit-done/`

## Success Criteria

- [ ] package.json has "type": "module" and dependencies installed
- [ ] bin/lib/ structure exists (io/, paths/, rendering/)
- [ ] path-resolver.js implements all 4 functions with ESM
- [ ] file-operations.js wraps fs-extra with error handling
- [ ] template-renderer.js implements regex-based replacement
- [ ] All modules can be imported without errors
- [ ] Path resolution returns correct Claude paths
- [ ] Template variables render correctly with getVariableContext()

## Output

**Created files:**
- package.json (updated)
- bin/lib/paths/path-resolver.js
- bin/lib/io/file-operations.js
- bin/lib/rendering/template-renderer.js

**Dependencies installed:**
- fs-extra@11.3.3
- chalk@5.6.2
- commander@14.0.2

**Ready for:** Plan 02 (CLI entry point and templates)
