---
phase: 01-core-installer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/io/file-operations.js
  - bin/lib/paths/path-resolver.js
  - bin/lib/templates/template-renderer.js
  - bin/lib/templates/template-validator.js
  - bin/lib/cli/output.js
  - bin/lib/cli/errors.js
  - scripts/build-templates.js
  - package.json
autonomous: true
must_haves:
  observable_truths:
    - User can copy files from templates/ to target directory
    - User can replace {{VARIABLES}} in template content
    - User sees colored progress output in terminal
    - User sees actionable error messages when operations fail
    - NPM package includes pre-built templates/ directory
  required_artifacts:
    - bin/lib/io/file-operations.js (copyFile, copyDirectory, ensureDirectory)
    - bin/lib/paths/path-resolver.js (resolvePath, normalizeHomePath)
    - bin/lib/templates/template-renderer.js (renderTemplate with {{VAR}} replacement)
    - bin/lib/templates/template-validator.js (validateTemplates pre-flight check)
    - bin/lib/cli/output.js (progress, success, colored output with chalk)
    - bin/lib/cli/errors.js (formatError with actionable guidance)
    - scripts/build-templates.js (generate templates/ from .github/)
  required_wiring:
    - file-operations.js uses fs-extra for all filesystem operations
    - path-resolver.js uses Node's path module and os.homedir()
    - template-renderer.js replaces {{UPPERCASE}} variables with nullish coalescing
    - template-validator.js scans for unclosed braces and unknown variables
    - output.js auto-detects TTY and respects --no-color
    - errors.js formats errors with EACCES/ENOSPC specific messages
    - build-templates.js runs via prepublishOnly hook
  key_links:
    - package.json includes "prepublishOnly": "node scripts/build-templates.js"
    - package.json dependencies include fs-extra, chalk, commander
    - All modules export ESM with .js extensions
---

# Phase 1, Plan 1: Foundation & Core Modules

## Objective

Create the foundational modules that all other parts of the installer depend on: file operations (copy/mkdir), path resolution (home directory expansion, normalization), template rendering ({{VARIABLE}} replacement), template validation (pre-flight checks), and CLI output (colored progress, error formatting). Also create the build script that generates templates/ from .github/ source.

## Context

**Why this matters:** These modules are the foundation that the installer orchestrator (Plan 2) and integration tests (Plan 3) will use. Without reliable file copying, path resolution, template rendering, and output formatting, nothing else can work.

**What exists:** Project has existing `.github/skills/` (29 directories) and `.github/agents/` (13 files) that need to be converted to templates. package.json exists with basic metadata but needs dependencies and hooks added.

**Decisions from context:**
- Pre-build templates at package time using scripts/build-templates.js (from RESEARCH.md)
- Runtime variable substitution enables {{INSTALL_DATE}} and {{USER}} (from RESEARCH.md)
- Custom template rendering (regex-based) sufficient for Phase 1's {{VAR}} replacement (from RESEARCH.md)
- Use fs-extra for file operations, chalk for colors, commander for CLI (from RESEARCH.md)
- ALL testing in /tmp directory only - never modify source files (from CONTEXT.md)
- Error messages include error code-specific actionable guidance (from CONTEXT.md)
- Progress shows moderate verbosity with checkmarks (from CONTEXT.md)

**Requirements covered:**
- INSTALL-02: File system operations
- INSTALL-03: Template rendering
- SAFETY-02: Path normalization
- TEMPLATE-01: Skill and agent templates (copy from .github/)
- TEMPLATE-01B: Template conversion process (replace hardcoded values with {{VARIABLES}})
- TEMPLATE-03: Template variables ({{PLATFORM_ROOT}}, {{VERSION}}, etc.)
- TEST-01: Testing isolation (all tests in /tmp)
- TEST-02: Test cleanup

**Dependencies:** None (foundation - no other modules exist yet)

## Tasks

<task name="install-dependencies" type="auto">
  <files>package.json</files>
  <action>
Install core dependencies for Phase 1:

```bash
npm install fs-extra@^11.3.0 chalk@^5.6.0 commander@^14.0.0
```

Update package.json with:
- "type": "module" (ESM support)
- "engines": { "node": ">=16.7.0" }
- "bin": { "get-shit-done-multi": "./bin/install.js" }
- "scripts": { "prepublishOnly": "node scripts/build-templates.js" }

Rationale from RESEARCH.md:
- fs-extra: Promise-based file operations with edge case handling
- chalk: Auto-detects TTY and handles Windows console
- commander: Built-in help generation, flag validation, typo suggestions
  </action>
  <verify>
```bash
# Check dependencies installed
npm ls fs-extra chalk commander

# Check package.json structure
cat package.json | grep '"type": "module"'
cat package.json | grep '"prepublishOnly"'
```
  </verify>
  <done>Dependencies installed, package.json has type:module, engines, bin entry, and prepublishOnly hook</done>
</task>

<task name="create-file-operations-module" type="auto">
  <files>bin/lib/io/file-operations.js</files>
  <action>
Create file operations module using fs-extra. Provide three core functions:

**copyFile(src, dest):**
- Use fs-extra's `copy()` for single file
- Handle permissions and symlinks automatically
- Throw descriptive errors with path information

**copyDirectory(src, dest, options):**
- Use fs-extra's `copy()` for recursive directory copy
- Options: { overwrite: true } (default behavior per CONTEXT.md)
- Preserve directory structure exactly

**ensureDirectory(dirPath):**
- Use fs-extra's `ensureDir()` (creates parents automatically)
- Return created status for logging purposes
- Never fail if directory already exists

**Error handling pattern from RESEARCH.md:**
```javascript
try {
  await fs.copy(src, dest);
} catch (error) {
  if (error.code === 'EACCES') {
    throw new Error(`Permission denied: ${dest}\n\nFix: Check directory permissions`);
  } else if (error.code === 'ENOSPC') {
    throw new Error('No space left on device');
  }
  throw error;
}
```

Export all functions as named ESM exports.
  </action>
  <verify>
```bash
# Test in isolated /tmp directory (per TEST-01 requirement)
TEST_DIR="/tmp/gsd-test-$(date +%s)"
mkdir -p "$TEST_DIR"
cd "$TEST_DIR"

# Create test file structure
mkdir -p test-src/subdir
echo "test content" > test-src/subdir/file.txt

# Test via Node.js
node -e "
import { copyFile, copyDirectory, ensureDirectory } from '$PWD/../bin/lib/io/file-operations.js';
await ensureDirectory('test-dest/deep/path');
await copyDirectory('test-src', 'test-dest/copied');
console.log('✓ File operations work');
"

# Verify files copied
test -f test-dest/copied/subdir/file.txt && echo "✓ Directory copy successful"

# Cleanup
cd - && rm -rf "$TEST_DIR"
```
  </verify>
  <done>bin/lib/io/file-operations.js exists with copyFile, copyDirectory, ensureDirectory functions using fs-extra</done>
</task>

<task name="create-path-resolver-module" type="auto">
  <files>bin/lib/paths/path-resolver.js</files>
  <action>
Create path resolution module using Node's path and os modules. Provide functions:

**resolvePath(inputPath):**
- Use `path.resolve()` to convert relative to absolute paths
- Use `path.normalize()` to clean up path separators
- Return normalized absolute path
- Never use string concatenation (per RESEARCH.md anti-patterns)

**normalizeHomePath(inputPath):**
- If path starts with `~`, replace with `os.homedir()` (not process.env.HOME)
- Then call resolvePath() for normalization
- Handle `~/` and `~` correctly
- Example: `~/foo` → `/Users/username/foo`

**getPlatformPath(platform, scope):**
- platform: 'claude' (Phase 1 only supports Claude)
- scope: 'global' or 'local'
- Return appropriate base path:
  - claude + global → `~/.claude/`
  - claude + local → `./.claude/`
- Use normalizeHomePath() for global paths

**getSkillsPath(platform, scope):**
- Combine getPlatformPath() with 'skills/gsd/'
- Example: claude + global → `~/.claude/skills/gsd/`

**Pattern from RESEARCH.md:**
```javascript
import { join, resolve, normalize } from 'path';
import { homedir } from 'os';

export function normalizeHomePath(inputPath) {
  if (inputPath.startsWith('~/')) {
    return resolve(homedir(), inputPath.slice(2));
  }
  return resolve(inputPath);
}
```

Export all functions as named ESM exports.
  </action>
  <verify>
```bash
# Test path resolution
node -e "
import { resolvePath, normalizeHomePath, getPlatformPath, getSkillsPath } from './bin/lib/paths/path-resolver.js';

const homePath = normalizeHomePath('~/test');
console.assert(homePath.includes('test'), 'Home path expansion failed');

const claudePath = getPlatformPath('claude', 'global');
console.assert(claudePath.includes('.claude'), 'Platform path failed');

const skillsPath = getSkillsPath('claude', 'global');
console.assert(skillsPath.includes('skills/gsd'), 'Skills path failed');

console.log('✓ Path resolution works');
"
```
  </verify>
  <done>bin/lib/paths/path-resolver.js exists with resolvePath, normalizeHomePath, getPlatformPath, getSkillsPath functions</done>
</task>

<task name="create-template-renderer-module" type="auto">
  <files>bin/lib/templates/template-renderer.js</files>
  <action>
Create template rendering module for {{VARIABLE}} replacement. Provide functions:

**renderTemplate(content, variables):**
- Use single-pass regex replacement (per RESEARCH.md Pattern 5)
- Pattern: `/\{\{([A-Z_]+)\}\}/g` (uppercase only per CONTEXT.md)
- Replace with variable value or `[MISSING:VAR_NAME]` if undefined
- Use nullish coalescing: `variables[varName] ?? `[MISSING:${varName}]``

**renderFile(filePath, variables):**
- Read file content
- Call renderTemplate()
- Return rendered content (don't write file)

**getDefaultVariables():**
- Return object with standard Phase 1 variables:
  - PLATFORM_ROOT: '.claude/' (hardcoded for Phase 1)
  - VERSION: '2.0.0'
  - COMMAND_PREFIX: '/gsd-'
  - INSTALL_DATE: new Date().toISOString()
  - USER: os.userInfo().username
  - PLATFORM_NAME: 'claude'

**Pattern from RESEARCH.md:**
```javascript
export function renderTemplate(content, variables) {
  return content.replace(/\{\{([A-Z_]+)\}\}/g, (match, variableName) => {
    return variables[variableName] ?? `[MISSING:${variableName}]`;
  });
}
```

Export all functions as named ESM exports.
  </action>
  <verify>
```bash
# Test template rendering
node -e "
import { renderTemplate, getDefaultVariables } from './bin/lib/templates/template-renderer.js';

const template = 'Path: {{PLATFORM_ROOT}}, Version: {{VERSION}}, Missing: {{UNDEFINED}}';
const variables = getDefaultVariables();
const result = renderTemplate(template, variables);

console.assert(result.includes('.claude/'), 'PLATFORM_ROOT not replaced');
console.assert(result.includes('2.0.0'), 'VERSION not replaced');
console.assert(result.includes('[MISSING:UNDEFINED]'), 'Missing variable not handled');

console.log('✓ Template rendering works');
console.log(result);
"
```
  </verify>
  <done>bin/lib/templates/template-renderer.js exists with renderTemplate, renderFile, getDefaultVariables functions</done>
</task>

<task name="create-template-validator-module" type="auto">
  <files>bin/lib/templates/template-validator.js</files>
  <action>
Create template validation module for pre-flight checks (per CONTEXT.md). Provide functions:

**validateTemplate(content, filePath):**
- Check for unclosed braces: count {{ vs }}
- Check for malformed variables: {{lowercase}}, {{ SPACE }}, {{123}}
- Check for unknown variables (compare against known set)
- Return array of issues: { line, column, message }

**validateTemplateDirectory(dirPath, knownVariables):**
- Recursively scan directory for .md files
- Validate each file
- Collect all issues
- Return summary: { validCount, issueCount, issues: [] }

**Known variables from CONTEXT.md:**
- PLATFORM_ROOT, VERSION, COMMAND_PREFIX, INSTALL_DATE, USER, PLATFORM_NAME

**Pattern:**
```javascript
export function validateTemplate(content, filePath) {
  const issues = [];
  const lines = content.split('\n');
  
  lines.forEach((line, lineNum) => {
    // Check for unclosed braces
    const openCount = (line.match(/\{\{/g) || []).length;
    const closeCount = (line.match(/\}\}/g) || []).length;
    if (openCount !== closeCount) {
      issues.push({ line: lineNum + 1, message: 'Unclosed braces' });
    }
    
    // Check for lowercase variables
    const lowercaseVars = line.match(/\{\{[a-z_]+\}\}/g);
    if (lowercaseVars) {
      issues.push({ line: lineNum + 1, message: `Lowercase variables not allowed: ${lowercaseVars.join(', ')}` });
    }
  });
  
  return issues;
}
```

Export all functions as named ESM exports.
  </action>
  <verify>
```bash
# Test template validation
node -e "
import { validateTemplate } from './bin/lib/templates/template-validator.js';

// Test valid template
const valid = 'Path: {{PLATFORM_ROOT}}';
const validIssues = validateTemplate(valid, 'test.md');
console.assert(validIssues.length === 0, 'Valid template flagged as invalid');

// Test invalid template (unclosed brace)
const invalid = 'Path: {{PLATFORM_ROOT}';
const invalidIssues = validateTemplate(invalid, 'test.md');
console.assert(invalidIssues.length > 0, 'Invalid template not caught');

// Test lowercase variable
const lowercase = 'Path: {{platform_root}}';
const lowercaseIssues = validateTemplate(lowercase, 'test.md');
console.assert(lowercaseIssues.length > 0, 'Lowercase variable not caught');

console.log('✓ Template validation works');
"
```
  </verify>
  <done>bin/lib/templates/template-validator.js exists with validateTemplate and validateTemplateDirectory functions</done>
</task>

<task name="create-cli-output-module" type="auto">
  <files>bin/lib/cli/output.js</files>
  <action>
Create CLI output module with colored formatting using chalk. Provide functions:

**progress(message):**
- Format: `${checkmark} ${message}`
- Use chalk.green for checkmark and message
- Auto-detect TTY (chalk handles this automatically)
- Example output: `✓ Copying templates...`

**success(message, details):**
- Format: Multi-line with checkmark, message, optional details
- Example from CONTEXT.md:
  ```
  ✓ Installation complete!
  
  Installed to: ~/.claude/skills/gsd/
  
  Next steps:
  - Restart Claude Code or reload skills
  - Run /gsd-new-project to start a new project
  ```
- Use chalk.green.bold for main message
- Use chalk.dim for details

**warning(message):**
- Format: `⚠ Warning: ${message}`
- Use chalk.yellow
- Example: `⚠ Warning: ~/.claude/skills/ is a symlink`

**info(message):**
- Format: Plain message with chalk.blue
- Use for informational messages during installation

**createProgressReporter():**
- Return object with methods for step-based progress
- Track current step, total steps
- Example usage:
  ```javascript
  const reporter = createProgressReporter(3);
  reporter.step('Copying templates');
  reporter.step('Rendering variables');
  reporter.complete('Done!');
  ```

**Pattern from CONTEXT.md:**
- Moderate verbosity with step-based progress
- Checkmarks for completed steps
- Colors auto-detect TTY
- Support --no-color flag (chalk respects NO_COLOR env var)

Export all functions as named ESM exports.
  </action>
  <verify>
```bash
# Test CLI output
node -e "
import { progress, success, warning, info } from './bin/lib/cli/output.js';

progress('Testing progress');
success('Installation complete', { installedTo: '~/.claude/skills/gsd/' });
warning('This is a warning');
info('This is info');

console.log('✓ CLI output works (check for colors above)');
"
```
  </verify>
  <done>bin/lib/cli/output.js exists with progress, success, warning, info, createProgressReporter functions using chalk</done>
</task>

<task name="create-cli-errors-module" type="auto">
  <files>bin/lib/cli/errors.js</files>
  <action>
Create error formatting module with actionable guidance. Provide functions:

**formatError(error):**
- Check error.code for specific error types
- Return formatted error message with fix suggestion
- Use chalk.red for error symbol and message
- Use chalk.dim for fix suggestion

**Error code mapping from RESEARCH.md and CONTEXT.md:**
```javascript
const ERROR_MESSAGES = {
  EACCES: (path) => ({
    message: `Permission denied to write ${path}`,
    fix: 'Check directory permissions or create the directory manually'
  }),
  ENOSPC: () => ({
    message: 'No space left on device',
    fix: 'Free up disk space and try again'
  }),
  ENOENT: (path) => ({
    message: `File or directory not found: ${path}`,
    fix: 'Check that the source files exist'
  }),
  EEXIST: (path) => ({
    message: `File already exists: ${path}`,
    fix: 'Remove existing file or use --force flag'
  })
};
```

**createError(message, code, meta):**
- Create Error object with custom properties
- Add code and meta for formatError() to use
- Return Error instance

**isExpectedError(error):**
- Check if error is expected (EACCES, ENOSPC, etc.)
- Return boolean
- Use for determining whether to show stack trace

**Pattern from CONTEXT.md:**
```
✗ Permission denied to write ~/.claude/skills/

Fix: Check directory permissions or create the directory manually:
mkdir -p ~/.claude/skills/
```

Export all functions as named ESM exports.
  </action>
  <verify>
```bash
# Test error formatting
node -e "
import { formatError, createError, isExpectedError } from './bin/lib/cli/errors.js';

// Test EACCES error
const permError = createError('Permission denied', 'EACCES', { path: '~/.claude/skills/' });
const formattedPerm = formatError(permError);
console.assert(formattedPerm.includes('Permission denied'), 'EACCES not formatted');
console.assert(formattedPerm.includes('Fix:'), 'Missing fix suggestion');

// Test expected error detection
console.assert(isExpectedError(permError), 'EACCES not recognized as expected');

const unexpectedError = new Error('Random error');
console.assert(!isExpectedError(unexpectedError), 'Unexpected error misidentified');

console.log('✓ Error formatting works');
console.log(formattedPerm);
"
```
  </verify>
  <done>bin/lib/cli/errors.js exists with formatError, createError, isExpectedError functions</done>
</task>

<task name="create-build-templates-script" type="auto">
  <files>scripts/build-templates.js</files>
  <action>
Create build script that generates templates/ from .github/ source (per RESEARCH.md Pre-Build Templates Pattern).

**Script responsibilities:**
1. Clean existing templates/ directory
2. Copy skills from .github/skills/ to templates/skills/ (29 directories)
   - Skip 'get-shit-done' subdirectory (handle separately as shared directory)
   - Each skill is a directory with SKILL.md inside
3. Copy agents from .github/agents/ to templates/agents/ (13 files)
   - Flat files: *.agent.md
4. Copy shared directory from get-shit-done/ to templates/get-shit-done/
5. Convert files to templates by replacing hardcoded values with {{VARIABLES}}

**Conversion rules from REQUIREMENTS.md TEMPLATE-01B:**
- `.github/` → `{{PLATFORM_ROOT}}`
- `/gsd-` → `{{COMMAND_PREFIX}}`
- Existing version numbers → `{{VERSION}}`
- Platform names like 'copilot' → `{{PLATFORM_NAME}}`

**Implementation pattern from RESEARCH.md:**
```javascript
#!/usr/bin/env node
import fs from 'fs-extra';
import path from 'path';

async function convertToTemplate(filePath) {
  let content = await fs.readFile(filePath, 'utf-8');
  
  // Replace hardcoded values with template variables
  content = content.replace(/\.github\//g, '{{PLATFORM_ROOT}}');
  content = content.replace(/\/gsd-/g, '{{COMMAND_PREFIX}}');
  // Add more replacements as needed
  
  await fs.writeFile(filePath, content, 'utf-8');
}

async function buildTemplates() {
  console.log('Building templates from .github/...');
  
  // 1. Clean and recreate templates/
  await fs.remove('templates');
  await fs.ensureDir('templates');
  
  // 2. Copy skills (directories)
  const skillsDir = '.github/skills';
  const skills = await fs.readdir(skillsDir);
  
  for (const skill of skills) {
    if (skill === 'get-shit-done') continue;
    
    const srcPath = path.join(skillsDir, skill);
    const stat = await fs.stat(srcPath);
    
    if (stat.isDirectory()) {
      const destPath = path.join('templates/skills', skill);
      await fs.copy(srcPath, destPath);
      
      // Convert SKILL.md to template
      const skillFile = path.join(destPath, 'SKILL.md');
      if (await fs.pathExists(skillFile)) {
        await convertToTemplate(skillFile);
      }
    }
  }
  
  // 3. Copy agents (flat files)
  const agentsDir = '.github/agents';
  await fs.ensureDir('templates/agents');
  const agents = await fs.readdir(agentsDir);
  
  for (const agent of agents.filter(f => f.endsWith('.agent.md'))) {
    const srcPath = path.join(agentsDir, agent);
    const destPath = path.join('templates/agents', agent);
    await fs.copy(srcPath, destPath);
    await convertToTemplate(destPath);
  }
  
  // 4. Copy shared directory
  await fs.copy('get-shit-done', 'templates/get-shit-done');
  
  console.log('✓ Templates built successfully');
  console.log(`  - Skills: ${skills.length - 1}`);
  console.log(`  - Agents: ${agents.filter(f => f.endsWith('.agent.md')).length}`);
}

buildTemplates().catch(error => {
  console.error('✗ Build failed:', error.message);
  process.exit(1);
});
```

**Make script executable:**
```bash
chmod +x scripts/build-templates.js
```

**Add shebang:** `#!/usr/bin/env node`
  </action>
  <verify>
```bash
# Create test source structure in /tmp (per TEST-01)
TEST_DIR="/tmp/gsd-test-$(date +%s)"
mkdir -p "$TEST_DIR"
cd "$TEST_DIR"

# Create mock source files
mkdir -p .github/skills/gsd-test-skill
echo "Path: .github/get-shit-done/\nCommand: /gsd-test" > .github/skills/gsd-test-skill/SKILL.md

mkdir -p .github/agents
echo "Path: .github/\nCommand: /gsd-agent" > .github/agents/gsd-test.agent.md

mkdir -p get-shit-done
echo "shared" > get-shit-done/README.md

# Run build script
node "$(cd - && pwd)/scripts/build-templates.js"

# Verify templates created
test -d templates/skills/gsd-test-skill && echo "✓ Skill copied"
test -f templates/agents/gsd-test.agent.md && echo "✓ Agent copied"
test -d templates/get-shit-done && echo "✓ Shared directory copied"

# Verify variable substitution
grep "{{PLATFORM_ROOT}}" templates/skills/gsd-test-skill/SKILL.md && echo "✓ PLATFORM_ROOT substituted"
grep "{{COMMAND_PREFIX}}" templates/skills/gsd-test-skill/SKILL.md && echo "✓ COMMAND_PREFIX substituted"

# Cleanup
cd - && rm -rf "$TEST_DIR"
```
  </verify>
  <done>scripts/build-templates.js exists and generates templates/ from .github/ with variable substitution</done>
</task>

## Verification

After completing all tasks, verify the foundation is solid:

```bash
# 1. Check all modules exist with correct structure
ls -l bin/lib/io/file-operations.js
ls -l bin/lib/paths/path-resolver.js
ls -l bin/lib/templates/template-renderer.js
ls -l bin/lib/templates/template-validator.js
ls -l bin/lib/cli/output.js
ls -l bin/lib/cli/errors.js
ls -l scripts/build-templates.js

# 2. Test build script (in /tmp per TEST-01)
TEST_DIR="/tmp/gsd-test-$(date +%s)"
mkdir -p "$TEST_DIR"
cd "$TEST_DIR"

# Copy source files for build test
cp -r "$OLDPWD/.github" .
cp -r "$OLDPWD/get-shit-done" .

# Run build script from original directory
node "$OLDPWD/scripts/build-templates.js"

# Verify templates created
test -d templates/skills && echo "✓ Skills templates exist"
test -d templates/agents && echo "✓ Agents templates exist"
test -d templates/get-shit-done && echo "✓ Shared directory copied"

# Check variable substitution in a sample file
SAMPLE_SKILL=$(find templates/skills -name "SKILL.md" | head -1)
if [ -f "$SAMPLE_SKILL" ]; then
  grep -q "{{PLATFORM_ROOT}}" "$SAMPLE_SKILL" && echo "✓ Template variables present"
fi

# Cleanup test directory
cd "$OLDPWD"
rm -rf "$TEST_DIR"

# 3. Test that prepublishOnly hook is configured
npm run prepublishOnly --dry-run || echo "✓ prepublishOnly hook configured"

# 4. Test module imports (all modules should be importable)
node --input-type=module -e "
import * as fileOps from './bin/lib/io/file-operations.js';
import * as paths from './bin/lib/paths/path-resolver.js';
import * as renderer from './bin/lib/templates/template-renderer.js';
import * as validator from './bin/lib/templates/template-validator.js';
import * as output from './bin/lib/cli/output.js';
import * as errors from './bin/lib/cli/errors.js';
console.log('✓ All modules importable');
"
```

## Success Criteria

**Observable outcomes:**
- [ ] User can copy files from templates/ to target directory (file-operations.js works)
- [ ] User can resolve home paths with ~ expansion (path-resolver.js works)
- [ ] User can replace {{VARIABLES}} in template content (template-renderer.js works)
- [ ] User can validate templates for syntax errors (template-validator.js works)
- [ ] User sees colored progress output (output.js with chalk works)
- [ ] User sees actionable error messages (errors.js formats by error code)
- [ ] NPM package includes pre-built templates/ directory (build-templates.js + prepublishOnly works)

**Required artifacts:**
- [x] bin/lib/io/file-operations.js with copyFile, copyDirectory, ensureDirectory
- [x] bin/lib/paths/path-resolver.js with resolvePath, normalizeHomePath, getPlatformPath, getSkillsPath
- [x] bin/lib/templates/template-renderer.js with renderTemplate, renderFile, getDefaultVariables
- [x] bin/lib/templates/template-validator.js with validateTemplate, validateTemplateDirectory
- [x] bin/lib/cli/output.js with progress, success, warning, info functions using chalk
- [x] bin/lib/cli/errors.js with formatError, createError, isExpectedError
- [x] scripts/build-templates.js that generates templates/ from .github/
- [x] package.json with dependencies (fs-extra, chalk, commander), prepublishOnly hook

**Wiring validated:**
- [x] File operations use fs-extra (not native fs)
- [x] Path resolution uses Node's path module and os.homedir()
- [x] Template renderer uses single-pass regex with nullish coalescing
- [x] Template validator scans for unclosed braces and lowercase variables
- [x] Output module auto-detects TTY via chalk
- [x] Error module provides error code-specific messages
- [x] Build script runs via prepublishOnly hook

**Key links functional:**
- [x] `npm run prepublishOnly` generates templates/
- [x] All modules export ESM with .js extensions
- [x] All tests execute in /tmp directory only

## Output

**Files created:**
- `bin/lib/io/file-operations.js` — File operations using fs-extra
- `bin/lib/paths/path-resolver.js` — Path resolution with home directory expansion
- `bin/lib/templates/template-renderer.js` — Template variable replacement
- `bin/lib/templates/template-validator.js` — Pre-flight template validation
- `bin/lib/cli/output.js` — Colored CLI output with chalk
- `bin/lib/cli/errors.js` — Error formatting with actionable guidance
- `scripts/build-templates.js` — Template generation from .github/ source

**Files modified:**
- `package.json` — Added dependencies, type:module, bin entry, prepublishOnly hook

**Next step:** Plan 2 will use these modules to build the installer orchestrator and CLI interface.
