---
phase: 01-core-installer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/install.js
  - bin/lib/io/file-operations.js
  - bin/lib/paths/path-resolver.js
  - bin/lib/rendering/template-renderer.js
  - bin/lib/errors/error-handler.js
  - package.json
autonomous: true
must_haves:
  observables:
    - User can run `npx get-shit-done-multi --version` and see "2.0.0"
    - Entry point exists at `bin/install.js` with correct shebang
    - Core modules exist under `bin/lib/` with clean APIs
    - Template renderer can replace `{{VARIABLE}}` with values
    - Path operations use `path.join()` and `os.homedir()` exclusively
  artifacts:
    - bin/install.js (thin orchestrator, ~50 lines)
    - bin/lib/io/file-operations.js (fs-extra wrappers)
    - bin/lib/paths/path-resolver.js (cross-platform path handling)
    - bin/lib/rendering/template-renderer.js (variable replacement)
    - bin/lib/errors/error-handler.js (error formatting)
  wiring:
    - install.js imports from lib/ modules
    - All modules export named functions (ESM)
    - Error handler formats errors with actionable fixes
  key_links:
    - bin/install.js → lib/errors/error-handler.js (catch-all error formatting)
    - lib/io/file-operations.js → fs-extra (recursive copy, mkdir)
    - lib/paths/path-resolver.js → os.homedir() (never use ~)
---

# Phase 1, Plan 1: Foundation & Core Modules

## Objective

Build NPX entry point and core library modules that handle file operations, path resolution, template rendering, and error formatting. This establishes the foundation for the installer with clean separation of concerns.

## Context

**What exists:** Project structure with `package.json` already configured for ESM ("type": "module") and bin entry point defined.

**What's needed:** Implement the thin entry point pattern with domain-organized modules under `bin/lib/`. All code must be ESM with `.js` extensions on imports.

**Key constraints:**
- ESM-only: Use `import`/`export`, include `.js` extensions
- Never use `__dirname` (use `import.meta.url` equivalent)
- Never concatenate paths with strings (use `path.join()`)
- Never use `~` in paths (use `os.homedir()`)
- All tests execute in `/tmp`, never in source directory

## Tasks

<task name="setup-dependencies" type="auto">
  <files>package.json</files>
  <action>
Install Phase 1 dependencies:

```bash
npm install fs-extra chalk commander
```

Verify package.json has:
- "type": "module" (should already exist)
- "engines": { "node": ">=16.7.0" } (should already exist)
- "bin": { "get-shit-done-multi": "bin/install.js" } (should already exist)

No changes to package.json structure needed - dependencies add to existing config.
  </action>
  <verify>
```bash
npm list fs-extra chalk commander
```
All three packages listed without errors.
  </verify>
  <done>Dependencies installed and package.json unchanged except for new dependencies</done>
</task>

<task name="create-npx-entry-point" type="auto">
  <files>bin/install.js</files>
  <action>
Create `bin/install.js` as thin orchestrator following research pattern:

**Structure:**
1. Shebang: `#!/usr/bin/env node`
2. ESM imports (Commander, chalk, error handler, installer logic placeholder)
3. ESM __dirname equivalent using import.meta.url
4. Load version from package.json (sync read is OK in entry point)
5. Commander setup with --claude, --version, --no-color, --help flags
6. Action handler with try/catch
7. Process exit codes (0 = success, 1 = error)

**Key patterns from RESEARCH.md:**
- Use `fileURLToPath(import.meta.url)` for __dirname
- Include `.js` extension on relative imports
- Use Commander's default help (don't customize yet)
- Use chalk.red('✗') for errors
- Always `process.exit(1)` on error, `process.exit(0)` on success

**For now:** Installer function can be placeholder (`async function install(options) { console.log('TODO'); }`)

Reference code example from RESEARCH.md "NPX Entry Point with ESM" section.
  </action>
  <verify>
```bash
chmod +x bin/install.js
node bin/install.js --version
node bin/install.js --help
```

Version shows "2.0.0", help shows flags, no errors.
  </verify>
  <done>Entry point executable, shows version and help, handles basic flags</done>
</task>

<task name="create-file-operations-module" type="auto">
  <files>bin/lib/io/file-operations.js</files>
  <action>
Create `bin/lib/io/file-operations.js` with fs-extra wrappers:

**Export these functions:**

```javascript
export async function copyDirectory(src, dest)
```
- Use `fs.copy(src, dest, { overwrite: true, errorOnExist: false, dereference: true })`
- Rationale: Handles symlinks, permissions, cross-platform edge cases

```javascript
export async function ensureDirectory(dirPath)
```
- Use `fs.ensureDir(dirPath)`
- Creates parent directories automatically

```javascript
export async function writeFile(filePath, content)
```
- Use `fs.outputFile(filePath, content, 'utf-8')`
- Creates parent directories automatically

```javascript
export async function checkSymlink(targetPath)
```
- Use `fs.lstat()` to detect symlinks (don't follow)
- Return true if symlink, false otherwise
- Log warning with chalk.yellow if symlink detected: `⚠ Warning: ${targetPath} is a symlink to ${target}`

**Error handling:**
- Let errors propagate up (caller handles with error-handler.js)
- No try/catch in these functions

Reference code example from RESEARCH.md "File Operations with fs-extra" section.
  </action>
  <verify>
Create test file in `/tmp/gsd-test-file-ops/`:

```bash
TEST_DIR="/tmp/gsd-test-file-ops-$(date +%s)"
mkdir -p "$TEST_DIR"

# Create test script that imports and uses functions
node -e "
import { ensureDirectory, writeFile } from './bin/lib/io/file-operations.js';
await ensureDirectory('${TEST_DIR}/test-dir/nested');
await writeFile('${TEST_DIR}/test-dir/nested/test.txt', 'content');
console.log('OK');
"

# Verify file exists
cat "${TEST_DIR}/test-dir/nested/test.txt"
```

Output: "content" and "OK"
  </verify>
  <done>File operations module exports working functions, test passes</done>
</task>

<task name="create-path-resolver-module" type="auto">
  <files>bin/lib/paths/path-resolver.js</files>
  <action>
Create `bin/lib/paths/path-resolver.js` with cross-platform path utilities:

**Export these functions:**

```javascript
export function resolvePlatformPath(platform, scope = 'global')
```
- Parameters: platform ('claude'), scope ('global' or 'local')
- Returns absolute path for installation target
- For Phase 1: Only support 'claude' platform
  - global: `path.join(os.homedir(), '.claude', 'skills', 'gsd')`
  - local: `path.join(process.cwd(), '.claude', 'skills', 'gsd')`
- Throw error for non-Claude platforms with message: "Platform {platform} not supported in Phase 1"

```javascript
export function resolveSharedPath(platform, scope = 'global')
```
- Returns path for shared `get-shit-done/` directory
- global: `path.join(os.homedir(), '.claude', 'get-shit-done')`
- local: `path.join(process.cwd(), '.claude', 'get-shit-done')`

```javascript
export function normalizePath(inputPath)
```
- Use `path.resolve(inputPath)` to normalize to absolute path

```javascript
export function isPathSafe(basePath, targetPath)
```
- Check if targetPath is within basePath (basic traversal check)
- Use `path.resolve()` for both, check if target starts with base
- Return boolean

**Key constraints from RESEARCH.md:**
- ALWAYS use `os.homedir()` for home directory (never `process.env.HOME` or `~`)
- ALWAYS use `path.join()` for path construction (never string concatenation)
- All functions pure (no side effects, no file I/O)

Reference code example from RESEARCH.md "Path Resolution Cross-Platform" section.
  </action>
  <verify>
```bash
node -e "
import { resolvePlatformPath, resolveSharedPath } from './bin/lib/paths/path-resolver.js';
const home = process.env.HOME || process.env.USERPROFILE;
const skillPath = resolvePlatformPath('claude', 'global');
const sharedPath = resolveSharedPath('claude', 'global');
console.log('Skill path:', skillPath);
console.log('Shared path:', sharedPath);
console.log('Contains home:', skillPath.includes('.claude'));
"
```

Output contains `.claude` paths, no errors
  </verify>
  <done>Path resolver module working, returns correct platform paths</done>
</task>

<task name="create-template-renderer-module" type="auto">
  <files>bin/lib/rendering/template-renderer.js</files>
  <action>
Create `bin/lib/rendering/template-renderer.js` with simple variable replacement:

**Export these functions:**

```javascript
export function renderTemplate(content, variables)
```
- Match `{{UPPERCASE_VARIABLE}}` pattern using regex: `/\{\{([A-Z_]+)\}\}/g`
- Replace with variable value or `[MISSING:VARIABLE_NAME]` if not found
- Use single-pass replacement with callback function (prevents double replacement)
- Return rendered string

```javascript
export function validateTemplate(content)
```
- Check balanced braces (count `{{` vs `}}`)
- Check for lowercase variable names (invalid, must be uppercase)
- Return array of error strings (empty if valid)

```javascript
export function getDefaultVariables()
```
- Return object with default variables:
  ```javascript
  {
    PLATFORM_ROOT: '.claude/',
    PLATFORM_NAME: 'claude',
    COMMAND_PREFIX: '/gsd-',
    VERSION: '2.0.0',
    INSTALL_DATE: new Date().toISOString(),
    USER: os.userInfo().username
  }
  ```

**Key patterns from RESEARCH.md:**
- Single-pass replacement using regex callback
- Uppercase-only variables (enforce in validation)
- Missing variables become `[MISSING:NAME]` for visibility

Reference code example from RESEARCH.md "Template Rendering (Custom)" section.
  </action>
  <verify>
```bash
node -e "
import { renderTemplate, validateTemplate, getDefaultVariables } from './bin/lib/rendering/template-renderer.js';

const template = 'Install to {{PLATFORM_ROOT}} with {{COMMAND_PREFIX}}cmd';
const vars = getDefaultVariables();
const rendered = renderTemplate(template, vars);
console.log('Rendered:', rendered);

const errors = validateTemplate('{{VALID}} and {{invalid}}');
console.log('Validation errors:', errors.length > 0 ? 'detected' : 'none');
"
```

Rendered output contains `.claude/` and `/gsd-`, validation detects lowercase variable
  </verify>
  <done>Template renderer working, validates templates, replaces variables correctly</done>
</task>

<task name="create-error-handler-module" type="auto">
  <files>bin/lib/errors/error-handler.js</files>
  <action>
Create `bin/lib/errors/error-handler.js` with error formatting:

**Export these functions:**

```javascript
export function formatError(error)
```
- Format error with chalk colors (red for error, yellow for fix)
- Check `error.code` for common filesystem errors:
  - `EACCES`: "Permission denied to write {path}\n\nFix: Check directory permissions"
  - `ENOSPC`: "No space left on device\n\nFix: Free up disk space and try again"
  - `ENOENT`: "File or directory not found: {path}\n\nFix: Ensure parent directory exists"
- Return formatted string with `chalk.red('✗')` prefix
- Don't include stack traces in formatted output

```javascript
export function exitWithError(error)
```
- Call `formatError(error)`
- Print to stderr: `console.error(formattedMessage)`
- Exit with code 1: `process.exit(1)`

**Key patterns from RESEARCH.md:**
- Specific error codes get specific fixes
- Colors: red for errors, yellow for fixes
- Always exit with code 1 on error
- No stack traces in user-facing output

Reference code example from RESEARCH.md "Error Handling with Specific Fixes" section.
  </action>
  <verify>
```bash
node -e "
import { formatError } from './bin/lib/errors/error-handler.js';

const err = new Error('Write failed');
err.code = 'EACCES';
err.path = '/test/path';

const formatted = formatError(err);
console.log('Has error symbol:', formatted.includes('✗'));
console.log('Has fix:', formatted.includes('Fix:'));
"
```

Output: Both "Has error symbol: true" and "Has fix: true"
  </verify>
  <done>Error handler formats errors with codes and actionable fixes</done>
</task>

<task name="wire-entry-point-to-modules" type="auto">
  <files>bin/install.js</files>
  <action>
Update `bin/install.js` to import and use error handler:

1. Add import: `import { exitWithError } from './lib/errors/error-handler.js';`
2. Update catch block in action handler:
   ```javascript
   .action(async (options) => {
     try {
       await install(options);
       process.exit(0);
     } catch (error) {
       exitWithError(error);
     }
   });
   ```

3. Keep install function as placeholder for now (Plan 2 implements it)

This wires the entry point to use consistent error formatting.
  </action>
  <verify>
Trigger an error and check formatting:

```bash
node bin/install.js --claude 2>&1 | head -5
```

Should see formatted output (not raw stack trace)
  </verify>
  <done>Entry point uses error handler for consistent error formatting</done>
</task>

## Verification

**Must work:**
1. `npx . --version` shows "2.0.0"
2. `npx . --help` shows available flags
3. All modules under `bin/lib/` can be imported without errors
4. Template renderer correctly replaces `{{PLATFORM_ROOT}}` → `.claude/`
5. Path resolver returns correct paths with `.claude/` for Claude platform
6. Error handler formats EACCES errors with "Fix:" guidance

**Files exist:**
- `bin/install.js` (executable, has shebang)
- `bin/lib/io/file-operations.js`
- `bin/lib/paths/path-resolver.js`
- `bin/lib/rendering/template-renderer.js`
- `bin/lib/errors/error-handler.js`

**No modification:**
- Source files in `.github/`, `.claude/`, `.codex/`, `get-shit-done/` unchanged
- All tests executed in `/tmp` only

## Success Criteria

Foundation complete when:
- ✅ User runs `npx . --version` → sees "2.0.0"
- ✅ User runs `npx . --help` → sees flag descriptions
- ✅ Core modules exist and export clean APIs
- ✅ Template renderer replaces variables correctly
- ✅ Path operations never use string concatenation
- ✅ Error handler provides actionable fixes for common errors
- ✅ All code follows ESM conventions (`.js` extensions, import.meta.url)
- ✅ No source files modified during development/testing

## Output

**Deliverables:**
- Working NPX entry point with Commander CLI
- 5 core modules under `bin/lib/` with domain organization
- Dependencies installed (fs-extra, chalk, commander)
- Clean error handling with user-facing messages
- Foundation ready for Plan 2 (templates and installation logic)

**Next:** Plan 2 implements template copying, conversion, and installation orchestrator.
