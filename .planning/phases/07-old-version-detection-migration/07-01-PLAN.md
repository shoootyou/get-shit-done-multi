---
phase: 07-path-security-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/validation/path-validator.js (create)
  - bin/lib/paths/symlink-resolver.js (create)
  - package.json (add sanitize-filename)
autonomous: true
must_haves:
  - "User-provided paths undergo URL decoding before validation"
  - "Normalized paths containing '..' are rejected with security error"
  - "Paths outside allowlist (.claude, .github, .codex, get-shit-done) are rejected"
  - "Windows reserved names (CON, PRN, AUX, etc.) blocked on all platforms"
  - "Symlinks detected using fs.lstat() and resolved to single level only"
  - "Symlink chains rejected with clear error message"
  - "Path length limits enforced (260 Windows, 4096 Unix)"
  - "Component length limit of 255 characters enforced"
---

# Phase 07, Plan 01: Path Security Validation Modules

## Objective

Create defense-in-depth path validation and symlink resolution modules that detect and block malicious paths before any file writes.

## Context

**What exists:**
- Basic path validation in `pre-install-checks.js` (checks for `..`, system dirs)
- Error logging infrastructure (`error-logger.js`)
- InstallError system with typed errors

**What's missing:**
- URL-encoded attack detection (`%2e%2e%2f`)
- Windows reserved name validation (cross-platform)
- Path length validation (platform-specific limits)
- Comprehensive error collection (all issues, not just first)
- Symlink detection and controlled resolution
- Null byte checks
- Allowlist validation

**Research findings:**
- No npm package provides complete path security
- Node.js built-ins are the standard approach
- `sanitize-filename` for Windows reserved names
- Defense-in-depth: 6-8 validation layers
- Single-level symlink resolution using `fs.lstat()` + `fs.readlink()`

**Integration points:**
- Called from `pre-install-checks.js` before any writes
- Used by installation orchestrator for every output path
- Error messages via `error-logger.js`

## Tasks

<task name="install-sanitize-filename" type="auto">
  <files>package.json</files>
  <action>
    Install `sanitize-filename` package for Windows reserved name validation:
    
    ```bash
    npm install sanitize-filename
    ```
    
    This package handles:
    - Windows reserved names (CON, PRN, AUX, NUL, COM1-9, LPT1-9)
    - Case-insensitive validation
    - Extensions (CON.txt, PRN.md)
    - Cross-platform filename sanitization
    
    **Note:** We implement Windows reserved name validation manually in path-validator.js for full control and better error messages. This package is installed as:
    1. Backup/reference implementation
    2. Future enhancement option (sanitize user input)
    3. Documented in research as standard solution
    
    We use manual validation instead of sanitize-filename because:
    - Need to REJECT malicious paths (not sanitize them silently)
    - Need detailed error messages for security violations
    - Need control over validation logic for defense-in-depth
  </action>
  <verify>
    ```bash
    npm list sanitize-filename
    grep -q "sanitize-filename" package.json && echo "✓ Package installed"
    ```
  </verify>
  <done>sanitize-filename appears in package.json dependencies</done>
</task>

<task name="create-path-validator" type="auto">
  <files>bin/lib/validation/path-validator.js</files>
  <action>
    Create comprehensive path validation module with defense-in-depth approach.
    
    **Module structure:**
    ```javascript
    // bin/lib/validation/path-validator.js
    
    import path from 'path';
    import sanitize from 'sanitize-filename';
    import { invalidPath } from '../errors/install-error.js';
    
    const ALLOWED_DIRS = ['.claude', '.github', '.codex', 'get-shit-done'];
    const WINDOWS_RESERVED = [
      'CON', 'PRN', 'AUX', 'NUL',
      'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9',
      'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9'
    ];
    
    /**
     * Validate path with defense-in-depth approach
     * @param {string} basePath - Base installation directory
     * @param {string} inputPath - Path to validate (may be relative)
     * @returns {Object} { normalized, resolved } if valid
     * @throws {InstallError} If path fails validation
     */
    export function validatePath(basePath, inputPath) {
      // Layer 1: URL decode
      let decoded;
      try {
        decoded = decodeURIComponent(inputPath);
      } catch (e) {
        throw invalidPath(
          'Invalid URL encoding in path',
          { path: inputPath, error: e.message }
        );
      }
      
      // Layer 2: Check for null bytes
      if (decoded.includes('\x00') || decoded.includes('\u0000')) {
        throw invalidPath('Null byte detected in path', { path: inputPath });
      }
      
      // Layer 3: Normalize
      const normalized = path.normalize(decoded);
      
      // Layer 4: Check for path traversal (normalize keeps leading ..)
      if (normalized.includes('..')) {
        throw invalidPath('Path traversal detected (..)', { path: inputPath });
      }
      
      // Layer 5: Resolve and check containment
      const resolvedBase = path.resolve(basePath);
      const resolvedTarget = path.resolve(basePath, normalized);
      const relative = path.relative(resolvedBase, resolvedTarget);
      
      if (relative.startsWith('..') || path.isAbsolute(relative)) {
        throw invalidPath(
          'Path escapes base directory',
          { path: inputPath, base: basePath }
        );
      }
      
      // Layer 6: Allowlist validation
      const firstSegment = normalized.split(path.sep)[0];
      if (!ALLOWED_DIRS.includes(firstSegment)) {
        throw invalidPath(
          `Path not in allowlist: ${firstSegment}`,
          { 
            path: inputPath,
            firstSegment,
            allowlist: ALLOWED_DIRS
          }
        );
      }
      
      // Layer 7: Length validation (platform-specific)
      const maxPath = process.platform === 'win32' ? 260 : 4096;
      if (resolvedTarget.length > maxPath) {
        throw invalidPath(
          `Path exceeds maximum length: ${resolvedTarget.length} > ${maxPath}`,
          { path: inputPath, length: resolvedTarget.length, max: maxPath }
        );
      }
      
      // Layer 8: Component validation
      const components = normalized.split(path.sep);
      for (const component of components) {
        if (component.length > 255) {
          throw invalidPath(
            `Component exceeds 255 characters: ${component.substring(0, 20)}...`,
            { path: inputPath, component: component.substring(0, 50) }
          );
        }
        
        // Windows reserved names (case-insensitive, cross-platform)
        const basename = component.split('.')[0].toUpperCase();
        if (WINDOWS_RESERVED.includes(basename)) {
          throw invalidPath(
            `Windows reserved name: ${component}`,
            { path: inputPath, component }
          );
        }
      }
      
      return { normalized, resolved: resolvedTarget };
    }
    
    /**
     * Validate all paths in batch, collecting all errors
     * @param {string} basePath - Base installation directory
     * @param {string[]} paths - Paths to validate
     * @returns {Object} { valid: [], invalid: [], totalErrors: number }
     */
    export function validateAllPaths(basePath, paths) {
      const results = {
        valid: [],
        invalid: [],
        totalErrors: 0
      };
      
      for (const inputPath of paths) {
        try {
          const validated = validatePath(basePath, inputPath);
          results.valid.push({
            input: inputPath,
            normalized: validated.normalized,
            resolved: validated.resolved
          });
        } catch (error) {
          results.invalid.push({
            input: inputPath,
            error: error.message,
            details: error.details
          });
          results.totalErrors++;
        }
      }
      
      return results;
    }
    
    /**
     * Helper: Check if filename is Windows reserved name
     * @param {string} filename - Filename to check
     * @returns {boolean} True if reserved name
     */
    export function isWindowsReservedName(filename) {
      const basename = filename.split('.')[0].toUpperCase();
      return WINDOWS_RESERVED.includes(basename);
    }
    ```
    
    **Implementation notes:**
    - Use Node.js built-in `path` module (no external dependencies for core logic)
    - `sanitize-filename` installed but kept as optional (we do validation manually)
    - All 8 validation layers from research applied
    - Comprehensive error collection for batch validation
    - Cross-platform Windows reserved name checks
  </action>
  <verify>
    ```bash
    # Check file created
    test -f bin/lib/validation/path-validator.js && echo "✓ File created"
    
    # Check exports
    grep -q "export function validatePath" bin/lib/validation/path-validator.js
    grep -q "export function validateAllPaths" bin/lib/validation/path-validator.js
    grep -q "ALLOWED_DIRS" bin/lib/validation/path-validator.js
    
    # Check all 8 validation layers present
    grep -q "decodeURIComponent" bin/lib/validation/path-validator.js
    grep -q "null byte" bin/lib/validation/path-validator.js
    grep -q "normalize" bin/lib/validation/path-validator.js
    grep -q "includes('..')" bin/lib/validation/path-validator.js
    grep -q "path.relative" bin/lib/validation/path-validator.js
    grep -q "ALLOWED_DIRS" bin/lib/validation/path-validator.js
    grep -q "maxPath" bin/lib/validation/path-validator.js
    grep -q "WINDOWS_RESERVED" bin/lib/validation/path-validator.js
    ```
  </verify>
  <done>path-validator.js exists with all 8 validation layers implemented</done>
</task>

<task name="create-symlink-resolver" type="auto">
  <files>bin/lib/paths/symlink-resolver.js</files>
  <action>
    Create symlink detection and single-level resolution module.
    
    **Module structure:**
    ```javascript
    // bin/lib/paths/symlink-resolver.js
    
    import { lstat, readlink } from 'fs/promises';
    import path from 'path';
    import { invalidPath } from '../errors/install-error.js';
    
    /**
     * Detect and resolve symlinks (single level only)
     * @param {string} filePath - Path to check
     * @returns {Promise<Object>} { isSymlink, original, target }
     * @throws {InstallError} If symlink chain detected or target doesn't exist
     */
    export async function resolveSymlinkSingleLevel(filePath) {
      let stats;
      try {
        stats = await lstat(filePath);
      } catch (e) {
        throw invalidPath(
          `Path does not exist: ${filePath}`,
          { path: filePath, error: e.message }
        );
      }
      
      if (!stats.isSymbolicLink()) {
        return {
          isSymlink: false,
          original: filePath,
          target: filePath
        };
      }
      
      // It's a symlink - read the target
      const linkTarget = await readlink(filePath);
      const resolvedTarget = path.resolve(path.dirname(filePath), linkTarget);
      
      // Check if target exists
      let targetStats;
      try {
        targetStats = await lstat(resolvedTarget);
      } catch (e) {
        throw invalidPath(
          `Broken symlink: ${filePath} -> ${linkTarget} (does not exist)`,
          { 
            path: filePath,
            target: linkTarget,
            resolved: resolvedTarget,
            error: e.message
          }
        );
      }
      
      // Check if target is itself a symlink (chain detection)
      if (targetStats.isSymbolicLink()) {
        throw invalidPath(
          `Symlink chain detected: ${filePath} -> ${linkTarget} (target is also a symlink)`,
          {
            path: filePath,
            target: linkTarget,
            resolved: resolvedTarget
          }
        );
      }
      
      return {
        isSymlink: true,
        original: filePath,
        target: resolvedTarget
      };
    }
    
    /**
     * Check if path is a symlink without resolving
     * @param {string} filePath - Path to check
     * @returns {Promise<boolean>} True if symlink
     */
    export async function isSymlink(filePath) {
      try {
        const stats = await lstat(filePath);
        return stats.isSymbolicLink();
      } catch {
        return false;
      }
    }
    ```
    
    **Implementation notes:**
    - Use `fs.lstat()` not `fs.stat()` (lstat doesn't follow symlinks)
    - Use `fs.readlink()` for single-level resolution (not `fs.realpath()`)
    - Reject chains immediately (security requirement)
    - Handle broken symlinks with clear error
  </action>
  <verify>
    ```bash
    # Check file created
    test -f bin/lib/paths/symlink-resolver.js && echo "✓ File created"
    
    # Check exports
    grep -q "export async function resolveSymlinkSingleLevel" bin/lib/paths/symlink-resolver.js
    grep -q "export async function isSymlink" bin/lib/paths/symlink-resolver.js
    
    # Check using lstat (not stat)
    grep -q "lstat" bin/lib/paths/symlink-resolver.js
    grep -q "readlink" bin/lib/paths/symlink-resolver.js
    
    # Check chain detection
    grep -q "Symlink chain detected" bin/lib/paths/symlink-resolver.js
    ```
  </verify>
  <done>symlink-resolver.js exists with single-level resolution and chain detection</done>
</task>

## Verification

After completing all tasks:

```bash
# 1. Module structure check
ls -la bin/lib/validation/path-validator.js
ls -la bin/lib/paths/symlink-resolver.js

# 2. Check package.json
npm list sanitize-filename

# 3. Verify exports
node -e "import('./bin/lib/validation/path-validator.js').then(m => console.log(Object.keys(m)))"
node -e "import('./bin/lib/paths/symlink-resolver.js').then(m => console.log(Object.keys(m)))"
```

## Success Criteria

- [x] `sanitize-filename` installed in package.json
- [x] `path-validator.js` created with all 8 validation layers
- [x] `validatePath()` function performs defense-in-depth checks
- [x] `validateAllPaths()` function collects all errors
- [x] URL decoding layer catches `%2e%2e%2f` attacks
- [x] Null byte detection layer present
- [x] Path traversal detection after normalization
- [x] Containment check using `path.resolve()` + `path.relative()`
- [x] Allowlist validation for `.claude`, `.github`, `.codex`, `get-shit-done`
- [x] Path length limits (260 Windows, 4096 Unix)
- [x] Component length limit (255 characters)
- [x] Windows reserved names blocked (case-insensitive, cross-platform)
- [x] `symlink-resolver.js` created with `fs.lstat()` + `fs.readlink()`
- [x] Single-level symlink resolution implemented
- [x] Symlink chain detection implemented
- [x] Broken symlink detection with error

## Output

Two new security modules ready for integration:
- `/bin/lib/validation/path-validator.js` - Defense-in-depth path validation
- `/bin/lib/paths/symlink-resolver.js` - Safe symlink resolution

Both modules use Node.js built-ins and follow research recommendations.
