---
phase: 03-multi-platform-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/platforms/base-adapter.js
  - bin/lib/platforms/registry.js
  - bin/lib/platforms/detector.js
  - bin/lib/platforms/binary-detector.js
autonomous: true
must_haves:
  - truth: "Base adapter interface defines required methods for all platforms"
    observable: "PlatformAdapter class exists with abstract methods (getFileExtension, getTargetDir, getCommandPrefix, transformTools, transformFrontmatter, getPathReference)"
  - truth: "Registry provides singleton adapter lookup"
    observable: "AdapterRegistry class with register(), get(), has(), getSupportedPlatforms() methods. Singleton instance exported as adapterRegistry"
  - truth: "Detector identifies GSD installations by checking manifest files"
    observable: "detectInstallations() returns {claude: {global, local}, copilot: {global, local}, codex: {global, local}} by checking .gsd-install-manifest.json existence"
  - truth: "Binary detector checks CLI availability for recommendations"
    observable: "detectBinaries() returns {claude, copilot, codex} boolean flags by running which/where commands with 2-second timeout"
  - key_link: "Base adapter → concrete adapters (Wave 2 depends on this)"
  - key_link: "Registry → orchestrator (Wave 3 will import adapterRegistry)"
  - key_link: "Detectors → CLI (Wave 3 will use for platform selection prompts)"
---

# Plan 03-01: Platform Foundation (Base Adapter, Registry, Detection)

## Objective
Create the foundational platform abstraction layer: base adapter interface, adapter registry for lookup, GSD installation detector, and CLI binary detector.

## Context

**Phase Progress:** Starting Phase 3 (Multi-Platform Support)

**Prior Work:**
- Phase 2 established core modules: file-operations, path-resolver, template-renderer, progress, logger
- Templates exist in /templates/ with {{PLATFORM_ROOT}}, {{COMMAND_PREFIX}}, {{VERSION}}, {{PLATFORM_NAME}} variables
- Basic installer works for single platform (Claude)

**This Plan Creates:**
- Base adapter interface (abstract class with required methods)
- Registry pattern for adapter lookup
- GSD detection via filesystem paths (for validation and version display)
- Binary detection via which/where commands (for recommendations only)

**Why This First:**
- Base adapter must exist before concrete adapters (Wave 2)
- Registry must exist before orchestrator integration (Wave 3)
- Detectors used in CLI prompts (Wave 3)
- All four modules are independent (can be built in parallel by tasks)

**Architectural Rule:**
Per PLATFORM-02 and ARCHITECTURE-DECISION.md: Each platform adapter will be ISOLATED. NO inheritance between ClaudeAdapter, CopilotAdapter, CodexAdapter. Code duplication is ACCEPTABLE and PREFERRED over coupling.

## Tasks

<task name="create-base-adapter" type="auto">
  <files>bin/lib/platforms/base-adapter.js</files>
  <action>
Create PlatformAdapter base class defining the adapter interface:

```javascript
// bin/lib/platforms/base-adapter.js
/**
 * Base adapter interface for platform-specific transformations
 * Each platform (Claude, Copilot, Codex) extends this class
 */
export class PlatformAdapter {
  constructor(platformName) {
    if (!platformName) {
      throw new Error('Platform name is required');
    }
    this.platformName = platformName;
  }
  
  /**
   * Get file extension for agents on this platform
   * @returns {string} File extension (e.g., '.md' or '.agent.md')
   */
  getFileExtension() {
    throw new Error(`${this.platformName}: getFileExtension() must be implemented`);
  }
  
  /**
   * Get target installation directory
   * @param {boolean} isGlobal - Global vs local installation
   * @returns {string} Target directory path
   */
  getTargetDir(isGlobal) {
    throw new Error(`${this.platformName}: getTargetDir() must be implemented`);
  }
  
  /**
   * Get command prefix for this platform
   * @returns {string} Command prefix (e.g., '/gsd-' or '$gsd-')
   */
  getCommandPrefix() {
    throw new Error(`${this.platformName}: getCommandPrefix() must be implemented`);
  }
  
  /**
   * Transform tool names for this platform
   * @param {string} tools - Comma-separated tools from template (e.g., "Read, Write, Bash")
   * @returns {string|Array} Platform-specific tool format
   */
  transformTools(tools) {
    throw new Error(`${this.platformName}: transformTools() must be implemented`);
  }
  
  /**
   * Transform frontmatter for this platform
   * @param {Object} data - Frontmatter object from template
   * @returns {Object} Platform-specific frontmatter
   */
  transformFrontmatter(data) {
    throw new Error(`${this.platformName}: transformFrontmatter() must be implemented`);
  }
  
  /**
   * Get path reference prefix for this platform
   * @returns {string} Path prefix (e.g., '.claude', '.github', '.codex')
   */
  getPathReference() {
    throw new Error(`${this.platformName}: getPathReference() must be implemented`);
  }
}
```

Module follows existing project patterns:
- ESM imports/exports
- JSDoc comments for public methods
- Error messages include platform name for debugging
- No external dependencies (pure JavaScript)
  </action>
  <verify>
cat bin/lib/platforms/base-adapter.js
node -e "import('./bin/lib/platforms/base-adapter.js').then(m => console.log('PlatformAdapter:', typeof m.PlatformAdapter))"
  </verify>
  <done>
Base adapter interface exists with 6 abstract methods. Attempting to call methods on base class throws descriptive errors with platform name.
  </done>
</task>

<task name="create-registry" type="auto">
  <files>bin/lib/platforms/registry.js</files>
  <action>
Create AdapterRegistry class for platform adapter lookup:

```javascript
// bin/lib/platforms/registry.js
/**
 * Registry for platform adapters
 * Provides singleton instance for adapter lookup
 */
class AdapterRegistry {
  constructor() {
    this.adapters = new Map();
  }
  
  /**
   * Register a platform adapter
   * @param {string} platform - Platform name ('claude', 'copilot', 'codex')
   * @param {PlatformAdapter} adapter - Adapter instance
   */
  register(platform, adapter) {
    if (this.adapters.has(platform)) {
      throw new Error(`Platform already registered: ${platform}`);
    }
    this.adapters.set(platform, adapter);
  }
  
  /**
   * Get adapter for platform
   * @param {string} platform - Platform name
   * @returns {PlatformAdapter}
   */
  get(platform) {
    if (!this.adapters.has(platform)) {
      const supported = this.getSupportedPlatforms().join(', ');
      throw new Error(`Unknown platform: ${platform}. Supported: ${supported}`);
    }
    return this.adapters.get(platform);
  }
  
  /**
   * Check if platform is registered
   * @param {string} platform - Platform name
   * @returns {boolean}
   */
  has(platform) {
    return this.adapters.has(platform);
  }
  
  /**
   * Get all supported platform names
   * @returns {string[]}
   */
  getSupportedPlatforms() {
    return Array.from(this.adapters.keys());
  }
}

// Singleton instance
// Wave 2 will import and register adapters
// Wave 3 will use for adapter lookup
export const adapterRegistry = new AdapterRegistry();
```

Registry uses Map for efficient key-value lookup. Singleton pattern ensures single registry instance across all modules.
  </action>
  <verify>
cat bin/lib/platforms/registry.js
node -e "import('./bin/lib/platforms/registry.js').then(m => { console.log('Registry:', m.adapterRegistry.constructor.name); console.log('Methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(m.adapterRegistry)).filter(n => n !== 'constructor')); })"
  </verify>
  <done>
AdapterRegistry class exists with register(), get(), has(), getSupportedPlatforms() methods. Singleton instance exported as adapterRegistry. Attempting to get unregistered platform throws descriptive error with supported platforms list.
  </done>
</task>

<task name="create-gsd-detector" type="auto">
  <files>bin/lib/platforms/detector.js</files>
  <action>
Create GSD installation detector using filesystem paths:

```javascript
// bin/lib/platforms/detector.js
import { pathExists } from '../io/file-operations.js';
import { homedir } from 'os';
import { join } from 'path';

/**
 * Detect GSD installations by checking for manifest files
 * @returns {Promise<Object>} Detection results per platform
 */
export async function detectInstallations() {
  const results = {
    claude: { global: false, local: false, version: null },
    copilot: { global: false, local: false, version: null },
    codex: { global: false, local: false, version: null }
  };
  
  const home = homedir();
  
  // Check global installations
  results.claude.global = await isGSDInstalled(join(home, '.claude'));
  results.copilot.global = await isGSDInstalled(join(home, '.copilot'));
  results.codex.global = await isGSDInstalled(join(home, '.codex'));
  
  // Check local installations (current directory)
  results.claude.local = await isGSDInstalled('.claude');
  results.copilot.local = await isGSDInstalled('.github');
  results.codex.local = await isGSDInstalled('.codex');
  
  // TODO: Read version from manifest (Phase 6 - VERSION-02)
  // For now, just detect presence
  
  return results;
}

/**
 * Check if GSD is installed in a directory
 * @param {string} dir - Directory to check
 * @returns {Promise<boolean>}
 */
async function isGSDInstalled(dir) {
  // GSD is installed if manifest exists
  const manifestPath = join(dir, 'get-shit-done', '.gsd-install-manifest.json');
  return await pathExists(manifestPath);
}

/**
 * Get installed platforms
 * @returns {Promise<string[]>} Array of platform names
 */
export async function getInstalledPlatforms() {
  const detections = await detectInstallations();
  const installed = [];
  
  for (const [platform, locations] of Object.entries(detections)) {
    if (locations.global || locations.local) {
      installed.push(platform);
    }
  }
  
  return installed;
}
```

Uses existing pathExists() from file-operations module. Checks for .gsd-install-manifest.json in platform-specific paths per PLATFORM-01.
  </action>
  <verify>
cat bin/lib/platforms/detector.js
node -e "import('./bin/lib/platforms/detector.js').then(async m => { const r = await m.detectInstallations(); console.log('Detection:', JSON.stringify(r, null, 2)); })"
  </verify>
  <done>
detector.js exports detectInstallations() and getInstalledPlatforms(). Detection checks all 6 paths (3 platforms × 2 scopes). Returns structured object with boolean flags per platform/scope.
  </done>
</task>

<task name="create-binary-detector" type="auto">
  <files>bin/lib/platforms/binary-detector.js</files>
  <action>
Create CLI binary detector for recommendations:

```javascript
// bin/lib/platforms/binary-detector.js
import { exec } from 'child_process';
import { promisify } from 'util';
import { platform } from 'os';

const execAsync = promisify(exec);

/**
 * Check if a command exists in PATH
 * @param {string} command - Command name
 * @returns {Promise<boolean>}
 */
async function commandExists(command) {
  const isWindows = platform() === 'win32';
  const checkCmd = isWindows ? `where ${command}` : `which ${command}`;
  
  try {
    // 2-second timeout per RESEARCH-CLARIFICATIONS Q3
    await execAsync(checkCmd, { timeout: 2000 });
    return true;
  } catch {
    return false;
  }
}

/**
 * Detect available platform CLI binaries
 * @returns {Promise<Object>} Binary detection results
 */
export async function detectBinaries() {
  return {
    claude: await commandExists('claude'),
    copilot: await commandExists('copilot'),
    codex: await commandExists('codex')
  };
}

/**
 * Get recommended platforms based on installed binaries
 * @returns {Promise<string[]>} Array of platform names
 */
export async function getRecommendedPlatforms() {
  const binaries = await detectBinaries();
  return Object.entries(binaries)
    .filter(([_, exists]) => exists)
    .map(([platform, _]) => platform);
}
```

Binary detection is for RECOMMENDATIONS ONLY per PLATFORM-01B. Actual installation validation uses detectInstallations() from detector.js.

Uses 2-second timeout to prevent hanging if binary doesn't exist (per RESEARCH-CLARIFICATIONS.md Q3).
  </action>
  <verify>
cat bin/lib/platforms/binary-detector.js
node -e "import('./bin/lib/platforms/binary-detector.js').then(async m => { const b = await m.detectBinaries(); console.log('Binaries:', JSON.stringify(b, null, 2)); })"
  </verify>
  <done>
binary-detector.js exports detectBinaries() and getRecommendedPlatforms(). Detection uses which/where with 2-second timeout. Cross-platform compatible (Windows vs Unix).
  </done>
</task>

## Verification

After all tasks complete:

```bash
# Verify directory structure
ls -la bin/lib/platforms/

# Test base adapter error handling
node -e "
import('./bin/lib/platforms/base-adapter.js').then(m => {
  const adapter = new m.PlatformAdapter('test');
  try {
    adapter.getFileExtension();
  } catch (e) {
    console.log('✓ Base adapter throws:', e.message);
  }
});
"

# Test registry operations
node -e "
import('./bin/lib/platforms/registry.js').then(m => {
  console.log('✓ Registry singleton:', m.adapterRegistry.constructor.name);
  console.log('✓ Supported platforms (empty):', m.adapterRegistry.getSupportedPlatforms());
  try {
    m.adapterRegistry.get('nonexistent');
  } catch (e) {
    console.log('✓ Unknown platform error:', e.message);
  }
});
"

# Test detection modules
node -e "
import('./bin/lib/platforms/detector.js').then(async m => {
  const installations = await m.detectInstallations();
  console.log('✓ GSD detection:', Object.keys(installations));
});
"

node -e "
import('./bin/lib/platforms/binary-detector.js').then(async m => {
  const binaries = await m.detectBinaries();
  console.log('✓ Binary detection:', Object.keys(binaries));
});
"
```

## Success Criteria

- [ ] bin/lib/platforms/ directory contains 4 files: base-adapter.js, registry.js, detector.js, binary-detector.js
- [ ] PlatformAdapter class has 6 abstract methods that throw descriptive errors
- [ ] AdapterRegistry singleton instance exported and usable
- [ ] detectInstallations() checks 6 paths and returns structured results
- [ ] detectBinaries() checks 3 CLI binaries with timeout handling
- [ ] All modules use ESM imports/exports
- [ ] All modules follow existing project conventions (JSDoc, error handling)
- [ ] No test failures when importing and calling exported functions

## Output

Foundation modules for Wave 2 (concrete adapters) and Wave 3 (orchestrator integration).

Git commit:
```
feat(platform): add base adapter, registry, and detection modules

- PlatformAdapter base class with 6 abstract methods
- AdapterRegistry singleton for adapter lookup
- detectInstallations() for GSD path detection
- detectBinaries() for CLI binary recommendations

Per PLATFORM-01, PLATFORM-01B, PLATFORM-02 requirements
Ready for Wave 2: concrete platform adapters
```
