---
phase: 01-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified: [bin/install.js]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Developer upgrades GSD and `.planning/` directory is preserved"
    - "Installation preserves user customizations during version changes"
    - "Upgrade operations are atomic with rollback capability"
  artifacts:
    - path: "bin/install.js"
      provides: "Upgrade module integration"
      min_lines: 950
      imports: ["preserveUserData", "restoreUserData"]
      calls: ["preserveUserData", "restoreUserData"]
  key_links:
    - from: "bin/install.js"
      to: "bin/lib/upgrade.js"
      via: "require('./lib/upgrade')"
      pattern: "require\\(\\.\/lib\/upgrade\\)"
    - from: "install()"
      to: "preserveUserData()"
      via: "function call before file operations"
      pattern: "preserveUserData\\("
    - from: "install()"
      to: "restoreUserData()"
      via: "function call after file operations"
      pattern: "restoreUserData\\("
    - from: "installCopilot()"
      to: "preserveUserData()"
      via: "function call before file operations"
      pattern: "preserveUserData\\("
    - from: "installCopilot()"
      to: "restoreUserData()"
      via: "function call after file operations"
      pattern: "restoreUserData\\("
    - from: "installCodex()"
      to: "preserveUserData()"
      via: "function call before file operations"
      pattern: "preserveUserData\\("
    - from: "installCodex()"
      to: "restoreUserData()"
      via: "function call after file operations"
      pattern: "restoreUserData\\("
---

<objective>
Wire the upgrade module into the installation flow to enable data preservation during version upgrades

**Purpose:** Close the critical gap preventing Phase 1 goal achievement. The upgrade.js module exists with complete implementation but is not connected to install.js, meaning upgrades will delete user data. This plan integrates the upgrade module into all three installation functions (Claude, Copilot, Codex) to preserve the `.planning/` directory and user customizations during version upgrades.

**Output:** 
- Upgrade module imported and integrated into install.js
- All installation functions preserve user data before overwriting
- All installation functions restore user data after copying files
- INSTALL-05 and INSTALL-06 requirements satisfied
</objective>

<execution_context>
@.github/skills/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bin/install.js
@bin/lib/upgrade.js
@bin/lib/paths.js

## Verification Context
@.planning/phases/01-foundation/01-VERIFICATION.md

## Prior Work
The upgrade module was created in 01-02 but explicitly deferred integration:
@.planning/phases/01-foundation/01-02-SUMMARY.md

**Key Finding from VERIFICATION.md:**
- upgrade.js exports preserveUserData(), restoreUserData(), cleanOrphanedFiles()
- But install.js never imports or calls these functions
- Result: Upgrades will delete user data (blocks INSTALL-05 and INSTALL-06)

**What needs integration:**
1. Import upgrade module in install.js
2. Call preserveUserData() before overwriting directories in install(), installCopilot(), installCodex()
3. Call restoreUserData() after file copying completes
4. Preserve .planning directory and user-data directories
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate upgrade module into installation functions</name>
  <files>bin/install.js</files>
  <action>
Import the upgrade module and wire preserve/restore calls into all three installation functions.

**1. Import upgrade module (at top of file with other requires):**
```javascript
const { preserveUserData, restoreUserData } = require('./lib/upgrade');
```

**2. Wire into install() function (Claude Code installation):**
- Find the install() function (around line 88)
- At the START of the function (before any file operations), add:
```javascript
// Preserve user data before upgrade
const backupDir = preserveUserData(installPath);
```
- At the END of the function (after all fs.copyFileSync calls, before success message), add:
```javascript
// Restore user data after upgrade
if (backupDir) {
  restoreUserData(backupDir, installPath);
}
```

**3. Wire into installCopilot() function:**
- Find the installCopilot(isGlobal) function (around line 489)
- At the START of the function (before any file operations), add:
```javascript
// Preserve user data before upgrade
const backupDir = preserveUserData(installPath);
```
- At the END of the function (after all file copying, before success message), add:
```javascript
// Restore user data after upgrade
if (backupDir) {
  restoreUserData(backupDir, installPath);
}
```

**4. Wire into installCodex() function:**
- Find the installCodex(isGlobal) function (around line 672)
- At the START of the function (before any file operations), add:
```javascript
// Preserve user data before upgrade
const backupDir = preserveUserData(installPath);
```
- At the END of the function (after all file copying, before success message), add:
```javascript
// Restore user data after upgrade
if (backupDir) {
  restoreUserData(backupDir, installPath);
}
```

**Integration pattern:**
- Call preserveUserData() returns backup directory path or null
- If null, no existing installation found (fresh install)
- If backupDir exists, restoreUserData() brings back .planning directory
- Both functions handle errors gracefully (log but don't throw)

**Verification points:**
- upgrade module imported at top of file
- preserveUserData() called at START of each install function
- restoreUserData() called at END of each install function
- All three CLI installation paths covered (Claude, Copilot, Codex)
</action>
  <verify>
Run grep to confirm all integrations:
```bash
# Verify import exists
grep -n "require('./lib/upgrade')" bin/install.js

# Verify preserveUserData calls (should find 3: one per install function)
grep -n "preserveUserData" bin/install.js

# Verify restoreUserData calls (should find 3: one per install function)
grep -n "restoreUserData" bin/install.js
```

Run Node.js script to test upgrade module is accessible:
```bash
node -e "const { preserveUserData, restoreUserData } = require('./bin/lib/upgrade'); console.log('Upgrade module loaded:', typeof preserveUserData === 'function', typeof restoreUserData === 'function');"
```
</verify>
  <done>
- upgrade module imported in install.js (grep finds require statement)
- preserveUserData() called in install(), installCopilot(), installCodex() (grep finds 3 calls)
- restoreUserData() called in install(), installCopilot(), installCodex() (grep finds 3 calls)
- Node.js can load and access upgrade functions
- All wiring follows pattern: preserve at start, restore at end
  </done>
</task>

</tasks>

<verification>
After task completion, verify the gap is closed:

**1. Code integration verification:**
```bash
# Confirm import statement
grep "require('./lib/upgrade')" bin/install.js

# Count preserve/restore calls (should be 3 each)
grep -c "preserveUserData" bin/install.js
grep -c "restoreUserData" bin/install.js

# Verify calls are in all three install functions
grep -B5 "preserveUserData" bin/install.js | grep "function"
```

**2. Module accessibility test:**
```bash
node -e "
const { preserveUserData, restoreUserData } = require('./bin/lib/upgrade');
console.log('✓ preserveUserData is function:', typeof preserveUserData === 'function');
console.log('✓ restoreUserData is function:', typeof restoreUserData === 'function');
"
```

**3. Confirm key_links from must_haves:**
- install.js → upgrade.js link exists (require statement)
- Each install function → preserveUserData (called before file ops)
- Each install function → restoreUserData (called after file ops)

**Expected outcome:**
- All greps succeed with expected counts
- Node.js successfully loads upgrade functions
- Gap from VERIFICATION.md is closed
</verification>

<success_criteria>
**Gap closure complete when:**

1. **Wiring verified:**
   - upgrade module imported in install.js
   - preserveUserData() called in all 3 install functions
   - restoreUserData() called in all 3 install functions
   - Calls positioned correctly (preserve before ops, restore after ops)

2. **Requirements unblocked:**
   - INSTALL-05 (preserve customizations) now achievable
   - INSTALL-06 (handle version upgrades) now achievable
   - Phase 1 goal (install with version safety) now achievable

3. **Observable truth achieved:**
   - "Developer upgrades GSD and `.planning/` directory is preserved" is now TRUE
   - Upgrade module no longer orphaned
   - All key_links from VERIFICATION.md now exist

4. **Code quality:**
   - Integration follows atomic pattern (preserve → operations → restore)
   - Error handling preserved (upgrade functions handle errors gracefully)
   - No new anti-patterns introduced

**Measurable outcomes:**
- `grep -c "preserveUserData" bin/install.js` returns 3
- `grep -c "restoreUserData" bin/install.js` returns 3
- `grep "require('./lib/upgrade')" bin/install.js` finds import
- All verification commands pass without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md` documenting:
- Upgrade module integration (import + 6 function calls)
- Gap closure (VERIFICATION.md gap resolved)
- Requirements unblocked (INSTALL-05, INSTALL-06)
- Next steps (Phase 1 complete, ready for verification re-run)
</output>
