---
phase: 05-atomic-transactions
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - bin/lib/validation/manifest-generator.js
  - bin/lib/installer/orchestrator.js
  - bin/lib/cli/installation-core.js
autonomous: true
must_haves:
  truths:
    - Manifest generated after successful installation only
    - Manifest includes complete file list from post-installation scan
    - Failed installations leave no manifest (consistent with no rollback)
    - Pre-installation validation runs before any file writes
    - Installation errors logged to .gsd-error.log in target directory
  artifacts:
    - bin/lib/validation/manifest-generator.js exists with generation functions
    - orchestrator.js calls runPreInstallationChecks before installation
    - orchestrator.js calls generateAndWriteManifest after success
    - installation-core.js wraps install() with error logging
  wiring:
    - runPreInstallationChecks called at line ~54 in orchestrator.js
    - generateAndWriteManifest replaces stub generateManifest (lines 296-311)
    - Error logging wrapper in installation-core.js catches all install errors
    - Manifest path: {targetDir}/get-shit-done/.gsd-install-manifest.json
  key_links:
    - Validation module (Wave 1) → orchestrator integration (Wave 2)
    - Manifest generator → orchestrator success path
    - Error logger → installation-core error handler
---

# Phase 5 Plan 2: Manifest Generation & Orchestrator Integration

## Objective

Complete Phase 5 by creating manifest generation module and integrating both validation and manifest into the installation orchestrator. This ensures validation runs **before** any writes and manifest is written **after** all operations succeed.

## Context

**Phase 5 scope:** Pre-installation validation + manifest generation (NO rollback)

**Current state:**
- Wave 1 complete: Validation module exists (`pre-install-checks.js`, `error-logger.js`)
- `orchestrator.js` line 54: After template validation, before installation phases
- `orchestrator.js` lines 296-311: Stub `generateManifest()` function exists
- `bin/lib/cli/installation-core.js`: Entry point that calls orchestrator

**From CONTEXT.md decisions:**
- Manifest write timing: At end, after successful installation only (decision 3.1)
- Manifest content: No checksums, no schema version (decisions 3.2, 3.3)
- File collection strategy: Post-installation scan (simplest)
- Error logging: Save to target directory in .gsd-error.log (decision 4.2)

**From RESEARCH.md findings:**
- Post-installation scan simpler than tracking during install
- Directory walk ~10ms for typical installation
- Integration points identified: orchestrator.js lines 27, 296-311

**Wave 1 deliverables (dependencies):**
- `runPreInstallationChecks()` - Pre-install validation orchestrator
- `logInstallationError()` - Error logging to file
- `formatValidationError()` and `formatRuntimeError()` - User-friendly messages

## Tasks

<task id="1" type="auto">
Create manifest generation module with file collection

**File:** `bin/lib/validation/manifest-generator.js`

**Action:**

Create new file with these exports:

```javascript
import { readdir, writeFile } from 'fs/promises';
import { join, relative } from 'path';
import { ensureDirectory } from '../io/file-operations.js';

/**
 * Generate and write installation manifest
 * Called ONLY after successful installation (context decision 3.1)
 * 
 * @param {string} targetDir - Installation target directory
 * @param {string} gsdVersion - GSD version (e.g., "2.0.0")
 * @param {string} platform - Platform name (claude/copilot/codex)
 * @param {boolean} isGlobal - Global vs local installation
 */
export async function generateAndWriteManifest(targetDir, gsdVersion, platform, isGlobal) {
  // Collect all installed files (post-installation scan)
  const files = await collectInstalledFiles(targetDir);
  
  // Build manifest object (context decision 3.3 structure)
  const manifest = {
    gsd_version: gsdVersion,
    platform: platform,
    scope: isGlobal ? 'global' : 'local',
    installed_at: new Date().toISOString(),
    files: files
  };
  
  // Write to target directory
  const manifestPath = join(targetDir, 'get-shit-done', '.gsd-install-manifest.json');
  await ensureDirectory(join(targetDir, 'get-shit-done'));
  await writeFile(manifestPath, JSON.stringify(manifest, null, 2), 'utf8');
}

/**
 * Recursively collect all files in directory
 * Returns relative paths sorted alphabetically
 * 
 * @param {string} targetDir - Directory to scan
 * @returns {Promise<string[]>} Array of relative file paths
 */
export async function collectInstalledFiles(targetDir) {
  const files = [];
  
  async function walkDirectory(currentPath, basePath) {
    const entries = await readdir(currentPath, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = join(currentPath, entry.name);
      const relativePath = relative(basePath, fullPath);
      
      if (entry.isDirectory()) {
        await walkDirectory(fullPath, basePath);
      } else if (entry.isFile()) {
        files.push(relativePath);
      }
    }
  }
  
  await walkDirectory(targetDir, targetDir);
  return files.sort(); // Deterministic output
}
```

**Verify:**
- Two exports: generateAndWriteManifest, collectInstalledFiles
- Post-installation scan (not tracking during install)
- Manifest structure matches context decision 3.3
- No checksums, no schema version per decisions 3.2, 3.3

**Done:** Manifest generation module exists
</task>

<task id="2" type="auto">
Integrate pre-installation validation into orchestrator

**File:** `bin/lib/installer/orchestrator.js`

**Action:**

1. Add import at top of file (after existing imports):

```javascript
import { runPreInstallationChecks } from '../validation/pre-install-checks.js';
```

2. Insert validation call at line ~54 (after line 36 where templatesDir is set, before line 54 validateTemplates):

```javascript
// === NEW: Pre-installation validation gate (Phase 5) ===
const validationResults = await runPreInstallationChecks(
  targetDir,
  templatesDir,
  isGlobal,
  platform
);

// Use validation results to enhance existing installation detection
const { existingInstall } = validationResults;
```

3. Update existing installation detection logic (lines 56-67) to use validationResults:

```javascript
// Check for existing installation (validation already detected it)
if (existingInstall) {
  if (!isVerbose) {
    logger.warn(`Existing installation detected (v${existingInstall.version})`, 2);
    logger.warn('Installation will overwrite existing files', 2);
  } else {
    logger.warnSubtitle('Warnings');
    logger.listItem(`Existing installation detected (v${existingInstall.version})`, 2);
    logger.listItem('Installation will overwrite existing files', 2);
  }
} else if (isVerbose) {
  logger.infoSubtitle('Info');
  logger.listItem('No existing installation found', 2);
}
```

**Note:** This replaces the duplicate manifest check (lines 57-58) with validation results.

**Verify:**
- Validation runs before validateTemplates() call
- Existing installation info used from validation results
- No duplicate manifest reading

**Done:** Pre-installation validation integrated into orchestrator
</task>

<task id="3" type="auto">
Replace stub manifest generation with full implementation

**File:** `bin/lib/installer/orchestrator.js`

**Action:**

1. Add import at top of file:

```javascript
import { generateAndWriteManifest } from '../validation/manifest-generator.js';
```

2. Replace existing generateManifest() function (lines 296-311) with call to new module:

Delete lines 296-311 (entire function).

3. Update manifest generation call in install() function (find where generateManifest is called, around line 113):

Replace:
```javascript
await generateManifest(targetDir, stats, isGlobal, platform);
```

With:
```javascript
// Generate manifest after successful installation (Phase 5)
await generateAndWriteManifest(targetDir, appVersion, platform, isGlobal);
```

**Note:** Function signature changed - now takes appVersion instead of stats.

**Verify:**
- Old generateManifest stub deleted
- New generateAndWriteManifest called with correct parameters
- Called after all installation phases complete (skills, agents, shared)

**Done:** Manifest generation uses full implementation with file list
</task>

<task id="4" type="auto">
Add error logging wrapper to installation entry point

**File:** `bin/lib/cli/installation-core.js`

**Action:**

1. Add imports at top of file:

```javascript
import { logInstallationError, formatValidationError, formatRuntimeError } from '../validation/error-logger.js';
```

2. Find the function that calls `install()` (likely `runNonInteractive` or similar). Wrap the install call with error handling:

Before:
```javascript
const stats = await install(appVersion, installOptions);
// ... success handling
```

After:
```javascript
let stats;
try {
  stats = await install(appVersion, installOptions);
} catch (error) {
  // Determine current phase from error context (if available)
  const phase = error.phase || 'Unknown';
  
  // Log error to file (Phase 5 - decision 4.2)
  await logInstallationError(error, {
    platform: options.platform || installOptions.platform,
    scope: installOptions.isGlobal ? 'global' : 'local',
    phase: phase,
    targetDir: installOptions.targetDir || resolvedTargetDir
  });
  
  // Display user-friendly message (Phase 5 - decisions 2.4, 4.4)
  if (error.name === 'InstallError' && [3, 4, 5].includes(error.code)) {
    // Validation errors: show technical + friendly
    console.error('\n' + formatValidationError(error));
  } else {
    // Runtime errors: show friendly only
    console.error('\n' + formatRuntimeError(error, installOptions.targetDir));
  }
  
  // Re-throw to maintain exit code behavior
  throw error;
}

// ... success handling continues with stats
```

**Note:** Adapt to actual function structure in installation-core.js. If multiple entry points (interactive, non-interactive), wrap both.

**Verify:**
- All install() calls wrapped with try-catch
- Validation errors (codes 3, 4, 5) use formatValidationError
- Runtime errors use formatRuntimeError
- Error logged to .gsd-error.log before displaying
- Original error re-thrown to maintain exit code

**Done:** Installation errors logged and displayed with user-friendly messages
</task>

<task id="5" type="auto">
Create unit tests for manifest generation

**File:** `tests/validation/manifest-generator.test.js`

**Action:**

Create test file:

```javascript
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { readFile, writeFile, mkdir, rm } from 'fs/promises';
import { join } from 'path';
import { mkdtemp } from 'fs/promises';
import { tmpdir } from 'os';
import {
  generateAndWriteManifest,
  collectInstalledFiles
} from '../../bin/lib/validation/manifest-generator.js';

describe('Manifest Generation', () => {
  let testDir;
  
  beforeEach(async () => {
    testDir = await mkdtemp(join(tmpdir(), 'gsd-manifest-test-'));
  });
  
  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });
  
  describe('collectInstalledFiles', () => {
    test('collects all files in directory', async () => {
      // Create test structure
      await mkdir(join(testDir, 'skills', 'gsd-test'), { recursive: true });
      await writeFile(join(testDir, 'skills', 'gsd-test', 'SKILL.md'), 'test');
      await writeFile(join(testDir, 'skills', 'gsd-test', 'version.json'), '{}');
      await mkdir(join(testDir, 'agents'), { recursive: true });
      await writeFile(join(testDir, 'agents', 'gsd-test.agent.md'), 'test');
      
      const files = await collectInstalledFiles(testDir);
      
      expect(files).toContain('skills/gsd-test/SKILL.md');
      expect(files).toContain('skills/gsd-test/version.json');
      expect(files).toContain('agents/gsd-test.agent.md');
      expect(files).toHaveLength(3);
    });
    
    test('returns sorted file list', async () => {
      await writeFile(join(testDir, 'z-file.txt'), 'z');
      await writeFile(join(testDir, 'a-file.txt'), 'a');
      await writeFile(join(testDir, 'm-file.txt'), 'm');
      
      const files = await collectInstalledFiles(testDir);
      
      expect(files).toEqual(['a-file.txt', 'm-file.txt', 'z-file.txt']);
    });
    
    test('excludes directories from file list', async () => {
      await mkdir(join(testDir, 'subdir'), { recursive: true });
      await writeFile(join(testDir, 'file.txt'), 'test');
      
      const files = await collectInstalledFiles(testDir);
      
      expect(files).toContain('file.txt');
      expect(files).not.toContain('subdir');
      expect(files).toHaveLength(1);
    });
  });
  
  describe('generateAndWriteManifest', () => {
    test('creates manifest with required fields', async () => {
      await mkdir(join(testDir, 'get-shit-done'), { recursive: true });
      await writeFile(join(testDir, 'test.txt'), 'test');
      
      await generateAndWriteManifest(testDir, '2.0.0', 'claude', true);
      
      const manifestPath = join(testDir, 'get-shit-done', '.gsd-install-manifest.json');
      const content = await readFile(manifestPath, 'utf8');
      const manifest = JSON.parse(content);
      
      expect(manifest).toHaveProperty('gsd_version', '2.0.0');
      expect(manifest).toHaveProperty('platform', 'claude');
      expect(manifest).toHaveProperty('scope', 'global');
      expect(manifest).toHaveProperty('installed_at');
      expect(manifest).toHaveProperty('files');
      expect(Array.isArray(manifest.files)).toBe(true);
    });
    
    test('includes all files including manifest itself', async () => {
      await mkdir(join(testDir, 'skills'), { recursive: true });
      await writeFile(join(testDir, 'skills', 'test.md'), 'test');
      
      await generateAndWriteManifest(testDir, '2.0.0', 'claude', true);
      
      const manifestPath = join(testDir, 'get-shit-done', '.gsd-install-manifest.json');
      const manifest = JSON.parse(await readFile(manifestPath, 'utf8'));
      
      expect(manifest.files).toContain('skills/test.md');
      expect(manifest.files).toContain('get-shit-done/.gsd-install-manifest.json');
    });
    
    test('sets scope to local when isGlobal is false', async () => {
      await mkdir(join(testDir, 'get-shit-done'), { recursive: true });
      
      await generateAndWriteManifest(testDir, '2.0.0', 'copilot', false);
      
      const manifestPath = join(testDir, 'get-shit-done', '.gsd-install-manifest.json');
      const manifest = JSON.parse(await readFile(manifestPath, 'utf8'));
      
      expect(manifest.scope).toBe('local');
    });
    
    test('installed_at is valid ISO timestamp', async () => {
      await mkdir(join(testDir, 'get-shit-done'), { recursive: true });
      
      await generateAndWriteManifest(testDir, '2.0.0', 'codex', true);
      
      const manifestPath = join(testDir, 'get-shit-done', '.gsd-install-manifest.json');
      const manifest = JSON.parse(await readFile(manifestPath, 'utf8'));
      
      const timestamp = new Date(manifest.installed_at);
      expect(timestamp.toISOString()).toBe(manifest.installed_at);
      expect(timestamp.getTime()).toBeGreaterThan(Date.now() - 5000); // Within last 5 seconds
    });
  });
});
```

**Verify:**
- Tests cover collectInstalledFiles and generateAndWriteManifest
- Tests verify manifest structure matches context decision 3.3
- Tests use temp directories and clean up
- All tests pass

**Done:** Manifest generation module has unit tests
</task>

<task id="6" type="auto">
Create integration test for full validation + manifest flow

**File:** `tests/integration/validation-flow.test.js`

**Action:**

Create integration test:

```javascript
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { readFile, writeFile, mkdir, rm, chmod } from 'fs/promises';
import { join } from 'path';
import { mkdtemp } from 'fs/promises';
import { tmpdir } from 'os';
import { install } from '../../bin/lib/installer/orchestrator.js';
import { ClaudeAdapter } from '../../bin/lib/platforms/claude-adapter.js';

describe('Phase 5 Integration: Validation + Manifest', () => {
  let testDir;
  let templatesDir;
  
  beforeEach(async () => {
    testDir = await mkdtemp(join(tmpdir(), 'gsd-integration-'));
    templatesDir = await mkdtemp(join(tmpdir(), 'gsd-templates-'));
    
    // Create minimal template structure
    await mkdir(join(templatesDir, 'skills', 'gsd-test'), { recursive: true });
    await writeFile(
      join(templatesDir, 'skills', 'gsd-test', 'SKILL.md'),
      '---\nname: test\n---\nTest skill',
      'utf8'
    );
    await writeFile(
      join(templatesDir, 'skills', 'gsd-test', 'version.json'),
      '{"skill_version": "1.0.0"}',
      'utf8'
    );
    await mkdir(join(templatesDir, 'agents'), { recursive: true });
    await mkdir(join(templatesDir, 'get-shit-done'), { recursive: true });
  });
  
  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
    await rm(templatesDir, { recursive: true, force: true });
  });
  
  test('successful installation generates manifest', async () => {
    const adapter = new ClaudeAdapter();
    
    const stats = await install('2.0.0', {
      platform: 'claude',
      adapter: adapter,
      isGlobal: false,
      isVerbose: false,
      scriptDir: templatesDir,
      targetDir: testDir
    });
    
    // Check manifest was created
    const manifestPath = join(testDir, 'get-shit-done', '.gsd-install-manifest.json');
    const content = await readFile(manifestPath, 'utf8');
    const manifest = JSON.parse(content);
    
    expect(manifest.gsd_version).toBe('2.0.0');
    expect(manifest.platform).toBe('claude');
    expect(manifest.scope).toBe('local');
    expect(manifest.files).toBeInstanceOf(Array);
    expect(manifest.files.length).toBeGreaterThan(0);
  });
  
  test('validation fails on read-only directory', async () => {
    await chmod(testDir, 0o444); // Read-only
    
    const adapter = new ClaudeAdapter();
    
    await expect(
      install('2.0.0', {
        platform: 'claude',
        adapter: adapter,
        isGlobal: false,
        isVerbose: false,
        scriptDir: templatesDir,
        targetDir: testDir
      })
    ).rejects.toThrow(/permission/i);
    
    await chmod(testDir, 0o755); // Restore for cleanup
    
    // Check no manifest was created (failed before installation)
    const manifestPath = join(testDir, 'get-shit-done', '.gsd-install-manifest.json');
    await expect(readFile(manifestPath)).rejects.toThrow();
  });
  
  test('validation detects existing installation', async () => {
    // Create existing installation manifest
    await mkdir(join(testDir, 'get-shit-done'), { recursive: true });
    const existingManifest = {
      gsd_version: '1.9.0',
      platform: 'claude',
      scope: 'local',
      installed_at: '2026-01-01T00:00:00.000Z',
      files: []
    };
    await writeFile(
      join(testDir, 'get-shit-done', '.gsd-install-manifest.json'),
      JSON.stringify(existingManifest),
      'utf8'
    );
    
    const adapter = new ClaudeAdapter();
    
    // Should succeed and overwrite
    const stats = await install('2.0.0', {
      platform: 'claude',
      adapter: adapter,
      isGlobal: false,
      isVerbose: false,
      scriptDir: templatesDir,
      targetDir: testDir
    });
    
    // Check manifest was updated
    const manifestPath = join(testDir, 'get-shit-done', '.gsd-install-manifest.json');
    const content = await readFile(manifestPath, 'utf8');
    const manifest = JSON.parse(content);
    
    expect(manifest.gsd_version).toBe('2.0.0'); // Updated
  });
});
```

**Verify:**
- Integration test covers full install() flow
- Tests validation failure before installation
- Tests manifest generation after success
- Tests existing installation detection
- Uses real adapter and orchestrator

**Done:** Integration tests verify validation + manifest flow
</task>

## Verification

After implementation, verify:

1. **Manifest module works:**
   ```bash
   node -e "import('./bin/lib/validation/manifest-generator.js').then(m => console.log(Object.keys(m)))"
   ```
   Should output: `generateAndWriteManifest, collectInstalledFiles`

2. **Orchestrator integration:**
   ```bash
   grep -n "runPreInstallationChecks" bin/lib/installer/orchestrator.js
   grep -n "generateAndWriteManifest" bin/lib/installer/orchestrator.js
   ```
   Should show import and call sites

3. **Unit tests pass:**
   ```bash
   npm test -- tests/validation/manifest-generator.test.js
   ```

4. **Integration test passes:**
   ```bash
   npm test -- tests/integration/validation-flow.test.js
   ```

5. **End-to-end smoke test:**
   ```bash
   npm link
   mkdir -p /tmp/gsd-e2e-test
   cd /tmp/gsd-e2e-test
   npx get-shit-done-multi --claude --local --yes
   ```
   
   Expected:
   - Pre-installation checks run (no errors)
   - Installation completes successfully
   - Manifest exists at `.claude/get-shit-done/.gsd-install-manifest.json`
   - Manifest contains file list

6. **Validation failure test:**
   ```bash
   mkdir -p /tmp/gsd-readonly-test
   chmod 444 /tmp/gsd-readonly-test
   cd /tmp/gsd-readonly-test
   npx get-shit-done-multi --claude --local --yes
   ```
   
   Expected:
   - Validation fails with clear error message
   - Error log written to `/tmp/gsd-readonly-test/.gsd-error.log`
   - No partial installation (no manifest, no files)

## Success Criteria

- [ ] `bin/lib/validation/manifest-generator.js` exists with 2 exported functions
- [ ] Manifest structure matches context decision 3.3 (gsd_version, platform, scope, installed_at, files)
- [ ] orchestrator.js calls runPreInstallationChecks before validateTemplates
- [ ] orchestrator.js calls generateAndWriteManifest after all phases complete
- [ ] installation-core.js wraps install() with error logging
- [ ] Validation errors (codes 3, 4, 5) show technical + friendly messages
- [ ] Runtime errors show friendly only + log file path
- [ ] Unit tests pass for manifest generation
- [ ] Integration tests pass for full flow
- [ ] End-to-end test creates manifest with complete file list
- [ ] Validation failure prevents installation and shows clear guidance
- [ ] Error log written to {targetDir}/.gsd-error.log on failure
- [ ] No manifest written on failed installation

## Output

**New files created:**
- `bin/lib/validation/manifest-generator.js` (~80 lines)
- `tests/validation/manifest-generator.test.js` (~120 lines)
- `tests/integration/validation-flow.test.js` (~130 lines)

**Modified files:**
- `bin/lib/installer/orchestrator.js` (+15 lines, -15 lines at generateManifest)
- `bin/lib/cli/installation-core.js` (+30 lines for error handling wrapper)

**Total:** ~360 lines of new code, orchestrator enhanced with validation and manifest

**Phase 5 complete:** Pre-installation validation prevents failures, manifest tracks successful installations, clear error messages guide users to resolution.
