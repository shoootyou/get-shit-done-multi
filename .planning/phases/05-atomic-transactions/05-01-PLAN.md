---
phase: 05-atomic-transactions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/validation/pre-install-checks.js
  - bin/lib/validation/error-logger.js
  - bin/lib/errors/install-error.js
autonomous: true
must_haves:
  truths:
    - Disk space check runs before any file writes
    - Permission test creates temporary file in target directory
    - Path validation blocks traversal attempts (../ patterns)
    - Existing installation detected via manifest file
    - Validation errors show both technical details and user guidance
  artifacts:
    - bin/lib/validation/pre-install-checks.js exists with exported functions
    - bin/lib/validation/error-logger.js exists with logging functions
    - Error classes support INSUFFICIENT_SPACE and PERMISSION_DENIED codes
  wiring:
    - Pre-install checks module exports runPreInstallationChecks()
    - Error logger exports logInstallationError() and formatValidationError()
    - All validation functions throw InstallError subclasses
---

# Phase 5 Plan 1: Pre-Installation Validation Module

## Objective

Create a standalone validation module that checks disk space, write permissions, path security, and existing installations **before any file writes occur**. This module prevents ~80% of installation failures by catching problems early.

## Context

**Phase 5 scope decision:** NO rollback mechanism. Focus is on **prevention** (validation before writes) and **clarity** (good error messages).

**Current state:**
- `bin/lib/installer/orchestrator.js` - Currently no pre-installation checks
- `bin/lib/errors/install-error.js` - Custom error classes exist
- `bin/lib/io/file-operations.js` - File operations with error handling

**From CONTEXT.md decisions:**
- Disk space: Exact template size + 10% buffer
- Permissions: Test actual write with temp file (not fs.access)
- Existing files: Always overwrite GSD files, no prompts
- Error messages: Both technical details + actionable guidance

**From RESEARCH.md findings:**
- Node.js 19+ provides `fs.statfs()` for disk space (cross-platform, native)
- Actual write test ~1-2ms overhead, more reliable than fs.access()
- Validation overhead target: <100ms total
- Multi-line text format for error logs (human-readable)

## Tasks

<task id="1" type="auto">
Create pre-installation validation module with all check functions

**File:** `bin/lib/validation/pre-install-checks.js`

**Action:**

Create new file with these exports:

```javascript
import { statfs } from 'fs';
import { promisify } from 'util';
import { readdir, stat, writeFile, unlink, readFile } from 'fs/promises';
import { join, normalize, resolve, relative } from 'path';
import { homedir } from 'os';
import { ensureDirectory, pathExists } from '../io/file-operations.js';
import { insufficientSpace, permissionDenied, invalidPath } from '../errors/install-error.js';

const statfsPromise = promisify(statfs);

/**
 * Run all pre-installation checks
 * @param {string} targetDir - Installation target directory
 * @param {string} templatesDir - Templates source directory
 * @param {boolean} isGlobal - Global vs local installation
 * @param {string} platform - Platform name
 * @throws {InstallError} If any validation fails
 * @returns {Promise<Object>} Validation results with existing installation info
 */
export async function runPreInstallationChecks(targetDir, templatesDir, isGlobal, platform) {
  // 1. Validate paths (security check)
  await validatePaths(targetDir, isGlobal);
  
  // 2. Calculate required space
  const templateSize = await calculateDirectorySize(templatesDir);
  
  // 3. Check disk space (with 10% buffer)
  await checkDiskSpace(targetDir, templateSize);
  
  // 4. Check write permissions (actual write test)
  await checkWritePermissions(targetDir);
  
  // 5. Detect existing installation (info only, doesn't fail)
  const existingInstall = await detectExistingInstallation(targetDir);
  
  return { existingInstall, templateSize };
}

/**
 * Check available disk space with 10% buffer
 */
export async function checkDiskSpace(targetDir, requiredBytes) {
  try {
    const stats = await statfsPromise(targetDir);
    const availableBytes = stats.bavail * stats.bsize;
    
    // Add 10% buffer (context decision)
    const requiredWithBuffer = Math.ceil(requiredBytes * 1.1);
    
    if (availableBytes < requiredWithBuffer) {
      throw insufficientSpace(
        'Insufficient disk space',
        {
          required: requiredWithBuffer,
          available: availableBytes,
          path: targetDir,
          requiredMB: (requiredWithBuffer / 1024 / 1024).toFixed(2),
          availableMB: (availableBytes / 1024 / 1024).toFixed(2)
        }
      );
    }
  } catch (error) {
    if (error.name === 'InstallError') throw error;
    
    // If statfs not available (Node < 19), log warning and continue
    console.warn('Warning: Could not check disk space (requires Node.js 19+)');
  }
}

/**
 * Test write permissions by actually writing a test file
 */
export async function checkWritePermissions(targetDir) {
  const testFile = join(targetDir, `.gsd-test-write-${Date.now()}`);
  
  try {
    // Ensure directory exists first
    await ensureDirectory(targetDir);
    
    // Test actual write
    await writeFile(testFile, 'test', 'utf8');
    
    // Cleanup
    await unlink(testFile);
  } catch (error) {
    // Try cleanup if file was partially created
    try {
      await unlink(testFile);
    } catch {}
    
    throw permissionDenied(
      `Cannot write to directory: ${targetDir}`,
      {
        path: targetDir,
        error: error.message,
        code: error.code
      }
    );
  }
}

/**
 * Validate paths for security (no traversal, correct scope)
 */
export async function validatePaths(targetDir, isGlobal) {
  // Normalize to resolve .. and . segments
  const normalized = normalize(targetDir);
  const resolved = resolve(normalized);
  
  // Check for traversal attempts
  if (normalized.includes('..')) {
    throw invalidPath(
      'Path traversal detected',
      { path: targetDir, reason: 'Contains ..' }
    );
  }
  
  // Validate scope matches path
  const home = homedir();
  if (isGlobal && !resolved.startsWith(home)) {
    throw invalidPath(
      'Global installation must be in home directory',
      { path: targetDir, home }
    );
  }
  
  // Block system directories
  const systemDirs = ['/etc', '/usr', '/bin', '/sbin', '/var', '/tmp'];
  if (systemDirs.some(dir => resolved.startsWith(dir))) {
    throw invalidPath(
      'Cannot install to system directories',
      { path: targetDir, blocked: true }
    );
  }
  
  return resolved;
}

/**
 * Detect existing installation and return info
 */
export async function detectExistingInstallation(targetDir) {
  const manifestPath = join(targetDir, 'get-shit-done', '.gsd-install-manifest.json');
  
  if (!await pathExists(manifestPath)) {
    return null;
  }
  
  try {
    const content = await readFile(manifestPath, 'utf8');
    const manifest = JSON.parse(content);
    
    return {
      version: manifest.gsd_version || manifest.version,
      platform: manifest.platform,
      scope: manifest.scope,
      installedAt: manifest.installed_at || manifest.installedAt,
      path: manifestPath
    };
  } catch (error) {
    // Manifest exists but is corrupted
    return {
      version: 'unknown',
      corrupted: true,
      path: manifestPath
    };
  }
}

/**
 * Calculate total size of directory recursively
 */
async function calculateDirectorySize(dirPath) {
  let totalSize = 0;
  
  async function walk(currentPath) {
    const entries = await readdir(currentPath, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = join(currentPath, entry.name);
      
      if (entry.isDirectory()) {
        await walk(fullPath);
      } else if (entry.isFile()) {
        const stats = await stat(fullPath);
        totalSize += stats.size;
      }
    }
  }
  
  await walk(dirPath);
  return totalSize;
}
```

**Verify:**
- All functions exported
- Uses Node.js native APIs (fs.statfs, fs/promises)
- Throws InstallError subclasses on failure
- Follows patterns from RESEARCH.md

**Done:** Pre-installation checks module exists with all validation functions
</task>

<task id="2" type="auto">
Create error logging and formatting module

**File:** `bin/lib/validation/error-logger.js`

**Action:**

Create new file with these exports:

```javascript
import { writeFile } from 'fs/promises';
import { join } from 'path';
import { ensureDirectory } from '../io/file-operations.js';

/**
 * Log installation error to file
 * @param {Error} error - Error object
 * @param {Object} context - Installation context
 * @param {string} context.platform - Platform name
 * @param {string} context.scope - 'global' or 'local'
 * @param {string} context.phase - Installation phase (Skills, Agents, Shared)
 * @param {string} context.targetDir - Target directory
 */
export async function logInstallationError(error, context) {
  const logPath = join(context.targetDir, '.gsd-error.log');
  const logContent = formatErrorLog(error, context);
  
  try {
    await ensureDirectory(context.targetDir);
    await writeFile(logPath, logContent, 'utf8');
  } catch (logError) {
    // If we can't write error log, at least warn
    console.error('Warning: Could not write error log:', logError.message);
  }
}

/**
 * Format error log content (structured text, human-readable)
 */
function formatErrorLog(error, context) {
  const lines = [
    'GSD Installation Error Log',
    `Generated: ${new Date().toISOString()}`,
    '',
    `ERROR: ${error.message}`,
    '',
    'Installation Details:',
    `  Platform: ${context.platform}`,
    `  Scope: ${context.scope}`,
    `  Phase: ${context.phase}`,
    `  Target: ${context.targetDir}`,
    ''
  ];
  
  // Add error details if available
  if (error.code) {
    lines.push('Error Details:');
    lines.push(`  Code: ${error.code}`);
    if (error.details) {
      Object.entries(error.details).forEach(([key, value]) => {
        lines.push(`  ${key}: ${value}`);
      });
    }
    lines.push('');
  }
  
  // Add stack trace
  if (error.stack) {
    lines.push('Stack Trace:');
    error.stack.split('\n').forEach(line => {
      lines.push(`  ${line}`);
    });
    lines.push('');
  }
  
  return lines.join('\n');
}

/**
 * Format user-friendly validation error message for terminal
 * Shows technical details + actionable guidance (context decision 2.4)
 */
export function formatValidationError(error) {
  const lines = [];
  
  lines.push(`✗ Validation failed: ${error.message}`);
  lines.push('');
  
  // Add specific guidance based on error type
  if (error.code === 5) { // INSUFFICIENT_SPACE
    const { requiredMB, availableMB, path } = error.details || {};
    if (requiredMB && availableMB) {
      lines.push('Details:');
      lines.push(`  Required: ${requiredMB} MB (including 10% buffer)`);
      lines.push(`  Available: ${availableMB} MB`);
      lines.push(`  Location: ${path}`);
      lines.push('');
      
      const needMB = (parseFloat(requiredMB) - parseFloat(availableMB)).toFixed(2);
      lines.push(`Fix: Free up at least ${needMB} MB and try again`);
    }
  } else if (error.code === 4) { // PERMISSION_DENIED
    const { path } = error.details || {};
    if (path) {
      lines.push('Details:');
      lines.push(`  Location: ${path}`);
      lines.push('');
      lines.push('Fix: Check directory permissions');
      lines.push(`Try: chmod +w ${path}`);
    }
  } else if (error.code === 3) { // INVALID_PATH
    const { path, reason } = error.details || {};
    if (path) {
      lines.push('Details:');
      lines.push(`  Path: ${path}`);
      if (reason) lines.push(`  Reason: ${reason}`);
      lines.push('');
      lines.push('Fix: Use a valid installation path');
    }
  }
  
  return lines.join('\n');
}

/**
 * Format runtime error message (user-friendly only, no technical details)
 * Contrast with validation errors which show both (context decision 4.4)
 */
export function formatRuntimeError(error, targetDir) {
  const lines = [];
  
  lines.push(`✗ Installation failed: ${error.message}`);
  lines.push('');
  
  if (error.code === 4) { // PERMISSION_DENIED
    const { path } = error.details || {};
    lines.push(`The installer couldn't write to ${path || targetDir}`);
    lines.push('');
    lines.push('Fix: Check directory permissions');
    lines.push(`Try: chmod +w ${path || targetDir}`);
  } else {
    lines.push('An unexpected error occurred during installation');
  }
  
  lines.push('');
  lines.push(`Details saved to: ${join(targetDir, '.gsd-error.log')}`);
  
  return lines.join('\n');
}
```

**Verify:**
- Three exported functions: logInstallationError, formatValidationError, formatRuntimeError
- Structured text format (not JSON) per RESEARCH.md
- Validation errors show both technical + friendly (decision 2.4)
- Runtime errors show friendly only (decision 4.4)

**Done:** Error logging module exists with formatting functions
</task>

<task id="3" type="auto">
Add new error codes to InstallError class

**File:** `bin/lib/errors/install-error.js`

**Action:**

Add these error factory functions if they don't exist:

```javascript
/**
 * Error code 5: Insufficient disk space
 */
export function insufficientSpace(message, details = {}) {
  const error = new InstallError(message, 5);
  error.details = details;
  return error;
}

/**
 * Error code 4: Permission denied
 */
export function permissionDenied(message, details = {}) {
  const error = new InstallError(message, 4);
  error.details = details;
  return error;
}

/**
 * Error code 3: Invalid path (traversal, system directory)
 */
export function invalidPath(message, details = {}) {
  const error = new InstallError(message, 3);
  error.details = details;
  return error;
}
```

Check existing file first - may already have permissionDenied. Add only missing ones.

**Verify:**
- Error codes are unique and consistent
- All three functions exported
- Details object supported

**Done:** InstallError supports INSUFFICIENT_SPACE, PERMISSION_DENIED, INVALID_PATH
</task>

<task id="4" type="auto">
Create unit tests for validation module

**File:** `tests/validation/pre-install-checks.test.js`

**Action:**

Create test file with these test cases:

```javascript
import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest';
import { statfs } from 'fs';
import { readFile, writeFile, mkdir, rm, chmod } from 'fs/promises';
import { join } from 'path';
import { mkdtemp } from 'fs/promises';
import { tmpdir } from 'os';
import {
  runPreInstallationChecks,
  checkDiskSpace,
  checkWritePermissions,
  validatePaths,
  detectExistingInstallation
} from '../../bin/lib/validation/pre-install-checks.js';

describe('Pre-Installation Checks', () => {
  let testDir;
  
  beforeEach(async () => {
    testDir = await mkdtemp(join(tmpdir(), 'gsd-test-'));
  });
  
  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });
  
  describe('checkDiskSpace', () => {
    test('passes with sufficient space', async () => {
      // Small requirement should pass on any dev machine
      await expect(
        checkDiskSpace(testDir, 1024)
      ).resolves.not.toThrow();
    });
    
    test('includes 10% buffer in calculation', async () => {
      // Mock statfs to return limited space
      const mockStatfs = vi.spyOn(await import('fs'), 'statfs');
      mockStatfs.mockImplementation((path, cb) => {
        // Return exactly 1.05MB (less than 1MB + 10% = 1.1MB)
        cb(null, { bavail: 270, bsize: 4096 });
      });
      
      await expect(
        checkDiskSpace(testDir, 1024 * 1024) // 1MB requires 1.1MB
      ).rejects.toThrow(/insufficient/i);
      
      mockStatfs.mockRestore();
    });
  });
  
  describe('checkWritePermissions', () => {
    test('succeeds on writable directory', async () => {
      await expect(
        checkWritePermissions(testDir)
      ).resolves.not.toThrow();
    });
    
    test('fails on read-only directory', async () => {
      await chmod(testDir, 0o444); // Read-only
      
      await expect(
        checkWritePermissions(testDir)
      ).rejects.toThrow(/permission/i);
      
      await chmod(testDir, 0o755); // Restore for cleanup
    });
    
    test('cleans up test file on success', async () => {
      await checkWritePermissions(testDir);
      
      const { readdir } = await import('fs/promises');
      const files = await readdir(testDir);
      expect(files.filter(f => f.startsWith('.gsd-test-write'))).toHaveLength(0);
    });
  });
  
  describe('validatePaths', () => {
    test('allows valid home directory path for global', async () => {
      const { homedir } = await import('os');
      const validPath = join(homedir(), '.claude');
      
      await expect(
        validatePaths(validPath, true)
      ).resolves.toBe(validPath);
    });
    
    test('blocks path traversal attempts', async () => {
      await expect(
        validatePaths('/home/user/../../../etc', true)
      ).rejects.toThrow(/traversal/i);
    });
    
    test('blocks system directories', async () => {
      await expect(
        validatePaths('/etc/gsd', true)
      ).rejects.toThrow(/system/i);
    });
  });
  
  describe('detectExistingInstallation', () => {
    test('returns null when no manifest exists', async () => {
      const result = await detectExistingInstallation(testDir);
      expect(result).toBeNull();
    });
    
    test('returns installation info when manifest exists', async () => {
      const manifestDir = join(testDir, 'get-shit-done');
      await mkdir(manifestDir, { recursive: true });
      
      const manifest = {
        gsd_version: '2.0.0',
        platform: 'claude',
        scope: 'global',
        installed_at: '2026-01-27T00:00:00.000Z'
      };
      
      await writeFile(
        join(manifestDir, '.gsd-install-manifest.json'),
        JSON.stringify(manifest),
        'utf8'
      );
      
      const result = await detectExistingInstallation(testDir);
      expect(result).toMatchObject({
        version: '2.0.0',
        platform: 'claude',
        scope: 'global'
      });
    });
    
    test('handles corrupted manifest gracefully', async () => {
      const manifestDir = join(testDir, 'get-shit-done');
      await mkdir(manifestDir, { recursive: true });
      
      await writeFile(
        join(manifestDir, '.gsd-install-manifest.json'),
        'invalid json',
        'utf8'
      );
      
      const result = await detectExistingInstallation(testDir);
      expect(result).toMatchObject({
        version: 'unknown',
        corrupted: true
      });
    });
  });
  
  describe('runPreInstallationChecks', () => {
    test('runs all checks successfully', async () => {
      const templatesDir = await mkdtemp(join(tmpdir(), 'gsd-templates-'));
      await writeFile(join(templatesDir, 'test.txt'), 'test', 'utf8');
      
      const result = await runPreInstallationChecks(
        testDir,
        templatesDir,
        false,
        'claude'
      );
      
      expect(result).toHaveProperty('existingInstall');
      expect(result).toHaveProperty('templateSize');
      expect(result.templateSize).toBeGreaterThan(0);
      
      await rm(templatesDir, { recursive: true });
    });
  });
});
```

**Verify:**
- Tests cover all validation functions
- Uses vitest (already in project)
- Tests clean up temp directories
- Covers success and failure cases

**Done:** Validation module has unit tests
</task>

## Verification

After implementation, verify:

1. **Module exports work:**
   ```bash
   node -e "import('./bin/lib/validation/pre-install-checks.js').then(m => console.log(Object.keys(m)))"
   ```
   Should output: `runPreInstallationChecks, checkDiskSpace, checkWritePermissions, validatePaths, detectExistingInstallation`

2. **Error logger exports work:**
   ```bash
   node -e "import('./bin/lib/validation/error-logger.js').then(m => console.log(Object.keys(m)))"
   ```
   Should output: `logInstallationError, formatValidationError, formatRuntimeError`

3. **Tests pass:**
   ```bash
   npm test -- tests/validation/pre-install-checks.test.js
   ```

4. **Type safety (if using JSDoc):**
   ```bash
   npx tsc --noEmit --allowJs --checkJs bin/lib/validation/*.js
   ```

5. **Manual smoke test:**
   ```bash
   node -e "
   import('./bin/lib/validation/pre-install-checks.js').then(async (m) => {
     await m.checkWritePermissions('/tmp');
     console.log('✓ Write test passed');
   });
   "
   ```

## Success Criteria

- [ ] `bin/lib/validation/pre-install-checks.js` exists with 5 exported functions
- [ ] `bin/lib/validation/error-logger.js` exists with 3 exported functions
- [ ] `bin/lib/errors/install-error.js` has insufficientSpace, permissionDenied, invalidPath
- [ ] Disk space check uses fs.statfs() with 10% buffer
- [ ] Permission check creates and deletes temp file
- [ ] Path validation blocks .. traversal and system directories
- [ ] Existing installation detection reads manifest file
- [ ] Error logging writes structured text to .gsd-error.log
- [ ] Validation errors show technical + friendly messages
- [ ] Runtime errors show friendly only
- [ ] Unit tests cover all validation functions
- [ ] All tests pass

## Output

**New files created:**
- `bin/lib/validation/pre-install-checks.js` (~200 lines)
- `bin/lib/validation/error-logger.js` (~120 lines)
- `tests/validation/pre-install-checks.test.js` (~150 lines)

**Modified files:**
- `bin/lib/errors/install-error.js` (add 3 error factories)

**Total:** ~470 lines of new code, fully tested and independent
