---
phase: 05.2-function-level-inventory-bin
plan: 01a
type: execute
wave: 1
depends_on: []
files_modified:
  - eval/*.txt
  - package.json
  - bin/lib/analysis/ast-parser.js
  - bin/lib/analysis/complexity.js
  - eval/stage_1/.gitkeep
autonomous: true
must_haves:
  - "Phase 5.1 test artifacts cleaned up (user confirmed deletion)"
  - "JavaScript files can be parsed with fallback strategy"
  - "Complexity levels correctly classified using thresholds"
  - "Parser failures gracefully recovered via fallback"
  - "Analysis output directory ready"
---

# Phase 05.2 Plan 01a: Cleanup & Foundation Setup

## Objective

Clean up Phase 5.1 test artifacts, install parsers (@babel/parser + acorn fallback), create directory structure, and build core analysis utilities (AST parser with fallback, complexity calculator with hardcoded thresholds).

## Context

**MANDATORY CLEANUP (per ROADMAP.md lines 282-284):**
Before starting Phase 5.2, delete all .txt artifacts from Phase 5.1 tests with user confirmation.

Phase 5.2 Stage 1 requires comprehensive function-level inventory of `bin/**` with adaptive depth analysis. Research identified 5 open questions that are now resolved and must be implemented as concrete code:

**Resolved Question 1 - Complexity Thresholds:**
- Simple: cyclomatic < 5
- Moderate: cyclomatic 5-9  
- Complex: cyclomatic >= 10
- **Implementation**: Hardcode as constants for now, make configurable later

**Resolved Question 5 - Parser Choice:**
- Primary: @babel/parser (most complete ES feature support)
- Fallback: acorn (if @babel/parser fails)
- **Implementation**: Try @babel/parser first, catch errors, try acorn, handle gracefully

This plan creates the foundation with cleanup and core utilities.

## Tasks

<task name="cleanup-phase-5.1-artifacts" type="auto">
  <files>eval/*.txt</files>
  <action>
    Find Phase 5.1 .txt test artifacts, confirm with user, then delete.
    
    ```bash
    # Find all .txt files in eval/
    echo "Searching for Phase 5.1 test artifacts..."
    TXT_FILES=$(find eval/ -name "*.txt" -type f 2>/dev/null)
    
    if [ -z "$TXT_FILES" ]; then
      echo "No .txt files found in eval/"
    else
      COUNT=$(echo "$TXT_FILES" | wc -l)
      echo "Found $COUNT .txt test artifact(s):"
      echo "$TXT_FILES"
      echo ""
      
      # Ask user for confirmation
      read -p "Delete these $COUNT Phase 5.1 test artifacts? (y/n): " CONFIRM
      
      if [ "$CONFIRM" = "y" ] || [ "$CONFIRM" = "Y" ]; then
        find eval/ -name "*.txt" -type f -delete
        echo "✓ Deleted $COUNT Phase 5.1 artifacts"
      else
        echo "⚠️  Deletion cancelled by user"
        exit 1
      fi
    fi
    ```
    
    Verify cleanup:
    ```bash
    # Verify no .txt files remain
    REMAINING=$(find eval/ -name "*.txt" -type f 2>/dev/null | wc -l)
    if [ "$REMAINING" -eq 0 ]; then
      echo "✓ Cleanup verified - no .txt files in eval/"
    else
      echo "⚠️  Warning: $REMAINING .txt files still present"
    fi
    ```
  </action>
  <verify>
    - No .txt files in eval/ directory
    - User confirmed deletion before removing files
    - Cleanup logged with count of files deleted
  </verify>
  <done>
    Phase 5.1 test artifacts cleaned up, eval/ directory ready for Phase 5.2
  </done>
</task>

<task name="install-parsers" type="auto">
  <files>package.json</files>
  <action>
    Install BOTH @babel/parser (primary) and acorn (fallback) as dev dependencies:
    
    ```bash
    npm install --save-dev @babel/parser acorn
    ```
    
    Verify both installed:
    ```bash
    npm list @babel/parser
    npm list acorn
    ```
  </action>
  <verify>
    - package.json includes "@babel/parser" in devDependencies
    - package.json includes "acorn" in devDependencies
    - Both show as installed in npm list
  </verify>
  <done>
    Both parsers installed and ready - @babel/parser as primary, acorn as fallback
  </done>
</task>

<task name="create-directory-structure" type="auto">
  <files>bin/lib/analysis/, eval/stage_1/</files>
  <action>
    Create directory structure for analysis infrastructure and output:
    
    ```bash
    mkdir -p bin/lib/analysis
    mkdir -p eval/stage_1
    touch eval/stage_1/.gitkeep
    ```
    
    Verify structure:
    ```bash
    ls -la bin/lib/analysis/
    ls -la eval/stage_1/
    ```
  </action>
  <verify>
    - bin/lib/analysis/ directory exists
    - eval/stage_1/ directory exists with .gitkeep
  </verify>
  <done>
    Directory structure created and ready for analysis utilities and output documents
  </done>
</task>

<task name="build-ast-parser-with-fallback" type="auto">
  <files>bin/lib/analysis/ast-parser.js</files>
  <action>
    Create AST parser utility implementing resolved Question 5 (primary + fallback strategy).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/ast-parser.js
    const fs = require('fs');

    // Resolved Question 5: @babel/parser primary, acorn fallback
    let babelParser;
    let acorn;
    
    try {
      babelParser = require('@babel/parser');
    } catch (e) {
      console.warn('⚠️  @babel/parser not available');
    }
    
    try {
      acorn = require('acorn');
    } catch (e) {
      console.warn('⚠️  acorn not available');
    }

    /**
     * Parse JavaScript file with fallback strategy
     * Resolved Question 5: Try @babel/parser first, then acorn, handle errors gracefully
     * @param {string} filePath - Path to JavaScript file
     * @returns {Object} AST
     */
    function parseFile(filePath) {
      const code = fs.readFileSync(filePath, 'utf8');
      
      // Try @babel/parser first (most complete)
      if (babelParser) {
        const parseOptions = [
          { sourceType: 'module' },       // ES modules
          { sourceType: 'script' },       // CommonJS
          { sourceType: 'unambiguous' }   // Auto-detect
        ];
        
        for (const options of parseOptions) {
          try {
            return babelParser.parse(code, {
              ...options,
              plugins: ['jsx'],  // Support JSX
              errorRecovery: true,  // Continue on errors
              ecmaVersion: 'latest'  // Latest ES features
            });
          } catch (err) {
            continue;  // Try next option
          }
        }
      }
      
      // Fallback to acorn
      if (acorn) {
        try {
          return acorn.parse(code, {
            ecmaVersion: 'latest',
            sourceType: 'module',
            locations: true  // Include loc info
          });
        } catch (err) {
          // Try as script
          try {
            return acorn.parse(code, {
              ecmaVersion: 'latest',
              sourceType: 'script',
              locations: true
            });
          } catch (err2) {
            throw new Error(`Failed to parse ${filePath} with both parsers: ${err2.message}`);
          }
        }
      }
      
      throw new Error(`No parser available for ${filePath}`);
    }

    /**
     * Extract all functions from a JavaScript file
     * @param {string} filePath - Path to JavaScript file
     * @returns {Array} Array of function objects with metadata
     */
    function extractFunctions(filePath) {
      const ast = parseFile(filePath);
      const functions = [];
      
      function visit(node, parent = null, depth = 0) {
        let functionInfo = null;
        
        // Handle different function types
        if (node.type === 'FunctionDeclaration') {
          functionInfo = {
            name: node.id?.name || `anonymous_function_${node.loc.start.line}`,
            type: 'declaration',
            params: node.params,
            body: node.body,
            loc: node.loc,
            isExported: parent?.type === 'ExportNamedDeclaration' || parent?.type === 'ExportDefaultDeclaration',
            depth: depth
          };
        } else if (node.type === 'FunctionExpression') {
          const name = node.id?.name || (parent?.type === 'VariableDeclarator' ? parent.id.name : `anonymous_${node.loc.start.line}`);
          functionInfo = {
            name,
            type: 'expression',
            params: node.params,
            body: node.body,
            loc: node.loc,
            isExported: false,  // Will check module.exports separately
            depth: depth
          };
        } else if (node.type === 'ArrowFunctionExpression') {
          const name = parent?.type === 'VariableDeclarator' ? parent.id.name : `arrow_${node.loc.start.line}`;
          functionInfo = {
            name,
            type: 'arrow',
            params: node.params,
            body: node.body,
            loc: node.loc,
            isExported: false,
            depth: depth
          };
        }
        
        if (functionInfo) {
          functions.push(functionInfo);
        }
        
        // Recursive traversal
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child, node, depth);
                }
              });
            } else if (node[key].type) {
              visit(node[key], node, depth);
            }
          }
        }
      }
      
      visit(ast, null, 0);
      return functions;
    }

    module.exports = {
      parseFile,
      extractFunctions
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const { extractFunctions } = require('./bin/lib/analysis/ast-parser.js');
    const funcs = extractFunctions('./bin/install.js');
    console.log('✓ Extracted', funcs.length, 'functions from install.js');
    console.log('  First function:', funcs[0]?.name);
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/ast-parser.js exists
    - Exports parseFile and extractFunctions
    - Test successfully parses install.js with either parser
    - Handles FunctionDeclaration, FunctionExpression, ArrowFunctionExpression
    - Fallback strategy works (try @babel/parser, then acorn)
  </verify>
  <done>
    AST parser with primary/fallback strategy implemented and tested
  </done>
</task>

<task name="build-complexity-calculator-with-thresholds" type="auto">
  <files>bin/lib/analysis/complexity.js</files>
  <action>
    Create complexity calculator implementing resolved Question 1 (hardcoded thresholds).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/complexity.js

    // Resolved Question 1: Hardcoded complexity thresholds (configurable via constants)
    const COMPLEXITY_THRESHOLDS = {
      SIMPLE: 5,      // cyclomatic < 5
      MODERATE: 10    // cyclomatic < 10
      // Complex is >= 10
    };

    /**
     * Calculate complexity metrics for a function node
     * Uses McCabe's cyclomatic complexity algorithm
     * @param {Object} functionNode - AST node for the function
     * @returns {Object} Complexity metrics
     */
    function calculateComplexity(functionNode) {
      let cyclomaticComplexity = 1; // Base complexity
      let maxNestingDepth = 0;
      let currentDepth = 0;
      
      function visit(node) {
        // Track nesting depth
        const depthIncreasingNodes = [
          'IfStatement',
          'ForStatement',
          'ForInStatement',
          'ForOfStatement',
          'WhileStatement',
          'DoWhileStatement',
          'SwitchStatement',
          'TryStatement'
        ];
        
        if (depthIncreasingNodes.includes(node.type)) {
          currentDepth++;
          maxNestingDepth = Math.max(maxNestingDepth, currentDepth);
        }
        
        // Count decision points (McCabe's algorithm)
        switch (node.type) {
          case 'IfStatement':
          case 'ConditionalExpression': // Ternary operator
          case 'ForStatement':
          case 'ForInStatement':
          case 'ForOfStatement':
          case 'WhileStatement':
          case 'DoWhileStatement':
            cyclomaticComplexity++;
            break;
          case 'SwitchCase':
            // Each case adds complexity (not default)
            if (node.test) {
              cyclomaticComplexity++;
            }
            break;
          case 'CatchClause':
            cyclomaticComplexity++;
            break;
          case 'LogicalExpression':
            // && and || add complexity
            if (node.operator === '&&' || node.operator === '||') {
              cyclomaticComplexity++;
            }
            break;
        }
        
        // Recursive traversal
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child);
                }
              });
            } else if (node[key].type) {
              visit(node[key]);
            }
          }
        }
        
        // Decrease depth when leaving nesting node
        if (depthIncreasingNodes.includes(node.type)) {
          currentDepth--;
        }
      }
      
      visit(functionNode.body);
      
      return {
        cyclomatic: cyclomaticComplexity,
        nesting_depth: maxNestingDepth,
        parameter_count: functionNode.params.length
      };
    }

    /**
     * Classify complexity level using hardcoded thresholds
     * Resolved Question 1: Simple < 5, Moderate 5-9, Complex >= 10
     * @param {number} cyclomatic - Cyclomatic complexity score
     * @returns {string} Classification (Simple/Moderate/Complex)
     */
    function classifyComplexity(cyclomatic) {
      if (cyclomatic < COMPLEXITY_THRESHOLDS.SIMPLE) return 'Simple';
      if (cyclomatic < COMPLEXITY_THRESHOLDS.MODERATE) return 'Moderate';
      return 'Complex';
    }

    /**
     * Get complexity thresholds for external use
     * @returns {Object} Threshold constants
     */
    function getThresholds() {
      return { ...COMPLEXITY_THRESHOLDS };
    }

    module.exports = {
      calculateComplexity,
      classifyComplexity,
      getThresholds,
      COMPLEXITY_THRESHOLDS  // Export for testing
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const { COMPLEXITY_THRESHOLDS, classifyComplexity } = require('./bin/lib/analysis/complexity.js');
    console.log('✓ Thresholds:', COMPLEXITY_THRESHOLDS);
    console.log('  Complexity 3:', classifyComplexity(3));
    console.log('  Complexity 7:', classifyComplexity(7));
    console.log('  Complexity 12:', classifyComplexity(12));
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/complexity.js exists
    - COMPLEXITY_THRESHOLDS constant defined (SIMPLE: 5, MODERATE: 10)
    - classifyComplexity uses hardcoded thresholds correctly
    - Test shows Simple < 5, Moderate 5-9, Complex >= 10
  </verify>
  <done>
    Complexity calculator with hardcoded thresholds (Simple < 5, Complex >= 10) implemented
  </done>
</task>

## Verification

After completing all tasks:

```bash
# Verify Phase 5.1 cleanup
find eval/ -name "*.txt" -type f | wc -l  # Should be 0

# Verify parsers installed
npm list @babel/parser
npm list acorn

# Verify directory structure
ls -la bin/lib/analysis/
ls -la eval/stage_1/

# Test foundation utilities
node -e "
const { extractFunctions } = require('./bin/lib/analysis/ast-parser.js');
const { calculateComplexity, COMPLEXITY_THRESHOLDS } = require('./bin/lib/analysis/complexity.js');

console.log('✓ Foundation utilities loaded successfully');
console.log('✓ Thresholds:', COMPLEXITY_THRESHOLDS);
"
```

## Success Criteria

- [x] Phase 5.1 test artifacts deleted (user confirmed)
- [x] @babel/parser AND acorn installed (primary + fallback)
- [x] eval/stage_1/ directory created and ready
- [x] bin/lib/analysis/ directory created
- [x] AST parser with fallback strategy working
- [x] Complexity calculator with hardcoded thresholds working
- [x] All foundation utilities tested and verified

## Output

**Created infrastructure:**
```
bin/lib/analysis/
├── ast-parser.js      # Question 5: @babel/parser + acorn fallback
└── complexity.js      # Question 1: hardcoded thresholds

eval/stage_1/
└── .gitkeep          # Ready for analysis documents
```

**Next:** Plan 01b will build advanced analysis utilities (side-effects, classifier, confidence, relationships).
