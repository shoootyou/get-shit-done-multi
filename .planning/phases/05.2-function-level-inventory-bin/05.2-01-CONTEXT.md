---
phase: 5.2
discussed: 2026-01-25T12:10:00Z
areas: [Analysis Depth & Granularity, User Confirmation Workflow, Analysis Document Structure, Cleanup & Preparation]
decisions_count: 15
---

# Phase 5.2 Context: Function-level Inventory of `bin/**`

## Essential Features

### Analysis Scope
- **Per-function analysis**: Every function in `bin/**` analyzed individually (not file-by-file)
- **Adaptive depth**: Complex functions get deep analysis, simple utilities get lighter treatment
- **Helper function handling**: Internal helpers documented within their parent function's analysis (not as separate entries)
- **Complexity metrics**: Include cyclomatic complexity, nesting depth, and parameter count for all functions
- **Side effects tracking**: Document I/O operations only (file read/write, network calls, console output)

### User Interaction Model
- **Investigation-first approach**: Complete initial investigation of all functions before asking clarification questions
- **Smart batching**: Simple/helper functions confirmed in batches, complex/exported functions confirmed individually
- **Progressive disclosure**: Present summary first, allow user to expand for full details
- **Ambiguous function handling**: Ask all three question types (purpose, categorization, relationships) for unclear functions
- **Uncertainty handling**: Make best-guess with confidence level, flag for user review

### Output Structure
- **Directory**: All analysis documents in `/eval/stage_1/`
- **Hybrid file organization**: 
  - One markdown file per source file for most functions
  - Complex/critical functions get their own dedicated files
- **YAML + Markdown mix**: 
  - YAML header with required metadata + complexity metrics + relationships + confidence
  - Markdown body with structured sections (Purpose, Inputs/Outputs, Dependencies, Side Effects) + freeform analysis
- **Relationship tracking**: Cross-references in markdown + YAML tags + separate dependency graph file

### Mandatory YAML Header Fields
```yaml
subject: function  # or module
name: <function-name>
source_file: <file-name>
source_location: <file-path>
function_count_in_file: <N>
analysis_stage: 1
last_updated: <ISO timestamp>
complexity:
  cyclomatic: <N>
  nesting_depth: <N>
  parameter_count: <N>
depends_on: [<function-list>]
called_by: [<function-list>]
confidence: <percentage>  # if < 100%
```

### Uncertainty Markers
Use all three methods:
1. **YAML confidence field**: `confidence: 60%` when interpretation is uncertain
2. **Uncertainty section**: Dedicated `## Uncertainties` section in markdown body
3. **Inline annotations**: Use ⚠️ or ❓ emoji markers in analysis text for specific uncertain points

## Technical Boundaries

### Analysis Depth Rules
- **Complex functions** (high cyclomatic complexity, deep nesting, many params):
  - Full signature + body understanding
  - Complete dependency tree
  - All call sites analyzed
  - All I/O side effects documented
  
- **Simple functions** (low complexity, minimal dependencies):
  - Signature + purpose
  - Direct dependencies only
  - Primary side effects
  
- **Helper functions**:
  - Analyzed in context of parent function
  - Not separate analysis documents
  - Documented in parent's "Internal Helpers" section

### Confirmation Workflow
1. **Initial investigation**: Analyze all functions in `bin/**` without interruption
2. **Batch simple functions**: Group straightforward functions, present for single confirmation
3. **Individual complex functions**: Present each complex function separately for detailed review
4. **Clarification questions**: After investigation, ask about ambiguous functions (purpose + categorization + relationships)
5. **Progressive disclosure**: Start with summary, expand on request

### Documentation Format
- **File naming**: 
  - Source file analysis: `eval/stage_1/<source-file>-analysis.md`
  - Complex function: `eval/stage_1/<function-name>.md`
  
- **Markdown structure**:
  ```markdown
  ---
  [YAML header]
  ---
  
  # Function: <name>
  
  ## Purpose
  [High-level what and why, with confidence markers if uncertain]
  
  ## Signature
  ```javascript
  function name(params) { ... }
  ```
  
  ## Inputs/Outputs
  - **Inputs**: [parameter descriptions]
  - **Returns**: [return value description]
  
  ## Dependencies
  - `functionName()` - [link to analysis]
  
  ## Side Effects
  - I/O operations documented here
  
  ## Complexity Analysis
  - Cyclomatic complexity: N
  - Nesting depth: N
  - Parameter count: N
  - Classification: [Simple/Moderate/Complex]
  
  ## Internal Helpers
  [If applicable, document helper functions here]
  
  ## Uncertainties
  [If confidence < 100%, document unclear aspects]
  ```

### Relationship Documentation
Create three types of relationship documentation:
1. **Cross-references**: Markdown links between function analyses
2. **YAML tags**: `depends_on` and `called_by` arrays in YAML header
3. **Dependency graph**: Separate `eval/stage_1/DEPENDENCY-GRAPH.md` showing all function relationships

## Scope Limits

### Out of Scope
- **File-by-file analysis**: Analysis is per-function, not per-file
- **Architecture recommendations**: Stage 1 is inventory only, no optimization proposals yet (that's Stage 2)
- **Code refactoring**: No changes to source code during analysis phase
- **Test file analysis**: Focus on `bin/**` only, exclude `__tests__/**`
- **External dependencies**: Only analyze project functions, not npm packages
- **Performance optimization**: Document complexity metrics but don't propose optimizations yet

### Explicitly Not Analyzed
- All state mutations (only I/O operations)
- Local variable assignments
- Property changes on local objects
- Internal function implementation details beyond complexity metrics

### Deferred to Stage 2
- Duplication identification
- Consolidation opportunities
- Rename suggestions
- Move proposals
- Merge candidates

## Open Questions

### For Research/Planning
1. **Batch sizing**: What threshold defines "simple" vs "complex" for batching? (cyclomatic complexity > 10? nesting depth > 3?)
2. **Call site analysis**: How to efficiently trace all call sites for each function? (grep? AST parsing?)
3. **Dependency graph generation**: Manual or automated? (Tools: madge, dependency-cruiser?)
4. **Confidence calculation**: What criteria determine confidence levels? (naming clarity? usage clarity? code clarity?)

### For Executor
1. How to handle functions with no clear category? (mark as "uncategorized", ask user)
2. Should anonymous functions be analyzed? (if exported or significant, yes)
3. How to name analysis files for files with special characters? (sanitize: `install.js` → `install-js-analysis.md`)
4. Order of analysis: alphabetical, by domain, or by dependency graph? (by domain for logical grouping)

## Success Criteria

Phase 5.2 is complete when:
- ✅ Phase 5.1 cleanup completed (archived to `.planning/history/v1.10.0-phase-5.1/`)
- ✅ Every function in `bin/**` has analysis document in `/eval/stage_1/`
- ✅ Adaptive depth applied (complex functions have deep analysis, simple have lightweight)
- ✅ Helper functions documented within parent function analyses
- ✅ All analyses include complexity metrics (cyclomatic, nesting, params)
- ✅ I/O side effects documented for all functions
- ✅ Smart batching used for user confirmations
- ✅ Progressive disclosure format used for all presentations
- ✅ Ambiguous functions clarified with all three question types
- ✅ Uncertainties marked using all three methods (YAML + section + inline)
- ✅ Hybrid file organization implemented (per-file + dedicated for complex)
- ✅ YAML headers include all required fields + complexity + relationships + confidence
- ✅ Markdown bodies use structured sections + freeform analysis mix
- ✅ All three relationship tracking methods implemented (cross-refs + YAML + graph)
- ✅ Dependency graph file created in `/eval/stage_1/DEPENDENCY-GRAPH.md`
- ✅ User confirmation obtained for all function interpretations

## Notes

### Pre-Cleanup Completed (2026-01-25)
- ✅ Archived 16 `.txt` files to `.planning/history/v1.10.0-phase-5.1/`
- ✅ Moved `PHASE-5.1-REPORT.md` to phase directory
- ✅ Moved `breaking-changes-fixed.md` to phase directory
- ✅ Moved `architecture-after.png` to phase directory
- Workspace root is now clean and ready for Phase 5.2 work

### Key Decisions Rationale
- **Adaptive depth**: Balances thoroughness with efficiency - complex functions need more scrutiny
- **Helper-in-context**: Reduces document count while keeping related code together
- **Smart batching**: Respects user time while ensuring accuracy for critical functions
- **Investigation-first**: Allows full context before asking questions, reduces back-and-forth
- **All three uncertainty markers**: Maximizes visibility - machine-readable (YAML) + human-readable (section + inline)
- **Hybrid organization**: Balances granularity (dedicated files for important functions) with manageability (grouped files for simple ones)

### Downstream Impact
This context will guide:
- **Phase 5.2 Planning**: Planner will break down into concrete execution tasks
- **Phase 5.2 Execution**: Executor will follow these rules for analysis and confirmation
- **Stage 2 (Phase 5.3)**: Consolidation phase will consume Stage 1 outputs
