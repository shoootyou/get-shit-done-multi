---
phase: 05.2-function-level-inventory-bin
plan: 03
type: execute
wave: 3
depends_on: [05.2-02]
files_modified:
  - eval/stage_1/DEPENDENCY-GRAPH.md
  - eval/stage_1/INVENTORY-SUMMARY.md
  - .planning/milestones/v1.10.0-ROADMAP.md
autonomous: true
must_haves:
  - "DEPENDENCY-GRAPH.md exists showing all function relationships"
  - "INVENTORY-SUMMARY.md provides complete overview of analysis results"
  - "All analysis documents verified complete with required fields"
  - "ROADMAP.md updated with Phase 5.2 completion status"
  - "Phase 5.2 ready for Stage 2 (consolidation) in Phase 5.3"
---

# Phase 05.2 Plan 03: Documentation Finalization

## Objective

Generate dependency graph visualization, create inventory summary document, verify all analysis documentation is complete, and update the roadmap to mark Phase 5.2 as ready for execution.

## Context

This is the final plan of Phase 5.2 (Stage 1: Function-level Inventory). After Plan 02 completed the analysis and generated all individual function documentation, we need to:

1. Create a comprehensive dependency graph showing how all functions relate
2. Generate a summary document providing overview and statistics
3. Verify all documentation meets requirements
4. Update roadmap to show Phase 5.2 completion

**From CONTEXT.md - Relationship Documentation:**
- Three types: cross-references (in individual docs), YAML tags (depends_on/called_by), dependency graph
- Dependency graph: Separate file showing all function relationships
- Graph should be human-readable markdown format

**Success criteria from CONTEXT.md:**
- Every function in bin/ has analysis document
- Dependency graph file created
- All three relationship tracking methods implemented
- User confirmation obtained for all interpretations (done in Plan 02)

This plan ties everything together and prepares for Stage 2 (consolidation) in Phase 5.3.

## Tasks

<task name="generate-dependency-graph" type="auto">
  <files>eval/stage_1/DEPENDENCY-GRAPH.md</files>
  <action>
    Create dependency graph document showing all function relationships.
    
    **Implementation approach:**
    - Read all analysis documents from eval/stage_1/
    - Parse YAML frontmatter to extract depends_on and called_by
    - Generate markdown graph with sections for each function
    - Include visual indicators for high-dependency functions
    
    **Create generator script:**
    ```javascript
    #!/usr/bin/env node
    // bin/scripts/generate-dependency-graph.js
    
    const fs = require('fs-extra');
    const path = require('path');
    const glob = require('glob');
    const matter = require('gray-matter');
    
    function generateDependencyGraph() {
      const analysisFiles = glob.sync('eval/stage_1/*.md', {
        ignore: ['**/DEPENDENCY-GRAPH.md', '**/INVENTORY-SUMMARY.md', '**/.gitkeep']
      });
      
      console.log(`Found ${analysisFiles.length} analysis documents`);
      
      const functions = [];
      
      // Parse all analysis documents
      for (const file of analysisFiles) {
        const content = fs.readFileSync(file, 'utf8');
        const parsed = matter(content);
        
        if (parsed.data.subject === 'function') {
          functions.push({
            name: parsed.data.name,
            sourceFile: parsed.data.source_file,
            dependsOn: parsed.data.depends_on || [],
            calledBy: parsed.data.called_by || [],
            complexity: parsed.data.complexity?.cyclomatic || 0
          });
        }
      }
      
      console.log(`Parsed ${functions.length} functions`);
      
      // Build graph sections
      const sections = [];
      
      sections.push('# Function Dependency Graph\n');
      sections.push('**Phase 5.2 - Stage 1: Function-level Inventory**\n');
      sections.push(`Generated: ${new Date().toISOString()}\n`);
      sections.push(`Total functions: ${functions.length}\n`);
      
      // Statistics
      const withDeps = functions.filter(f => f.dependsOn.length > 0).length;
      const withCallers = functions.filter(f => f.calledBy.length > 0).length;
      const isolated = functions.filter(f => f.dependsOn.length === 0 && f.calledBy.length === 0).length;
      
      sections.push('## Statistics\n');
      sections.push(`- Functions with dependencies: ${withDeps}`);
      sections.push(`- Functions with callers: ${withCallers}`);
      sections.push(`- Isolated functions: ${isolated}\n`);
      
      // High-dependency functions (called by many)
      const highDependency = functions
        .filter(f => f.calledBy.length >= 3)
        .sort((a, b) => b.calledBy.length - a.calledBy.length);
      
      if (highDependency.length > 0) {
        sections.push('## High-Dependency Functions\n');
        sections.push('Functions called by 3+ other functions:\n');
        highDependency.forEach(f => {
          sections.push(`- **${f.name}** (called by ${f.calledBy.length} functions)`);
        });
        sections.push('');
      }
      
      // Complex functions
      const complexFunctions = functions
        .filter(f => f.complexity >= 10)
        .sort((a, b) => b.complexity - a.complexity);
      
      if (complexFunctions.length > 0) {
        sections.push('## Complex Functions\n');
        sections.push('Functions with cyclomatic complexity >= 10:\n');
        complexFunctions.forEach(f => {
          sections.push(`- **${f.name}** (complexity ${f.complexity})`);
        });
        sections.push('');
      }
      
      // Full dependency list (grouped by source file)
      sections.push('## Function Dependencies by File\n');
      
      const byFile = new Map();
      functions.forEach(f => {
        if (!byFile.has(f.sourceFile)) {
          byFile.set(f.sourceFile, []);
        }
        byFile.get(f.sourceFile).push(f);
      });
      
      const sortedFiles = Array.from(byFile.keys()).sort();
      
      for (const file of sortedFiles) {
        sections.push(`### ${file}\n`);
        const fileFunctions = byFile.get(file);
        
        for (const fn of fileFunctions) {
          sections.push(`#### \`${fn.name}()\`\n`);
          
          if (fn.dependsOn.length > 0) {
            sections.push('**Depends on:**');
            fn.dependsOn.forEach(dep => {
              sections.push(`- \`${dep}()\``);
            });
            sections.push('');
          }
          
          if (fn.calledBy.length > 0) {
            sections.push('**Called by:**');
            fn.calledBy.forEach(caller => {
              sections.push(`- \`${caller}()\``);
            });
            sections.push('');
          }
          
          if (fn.dependsOn.length === 0 && fn.calledBy.length === 0) {
            sections.push('*Isolated function (no dependencies or callers)*\n');
          }
        }
      }
      
      // Write graph
      const graphContent = sections.join('\n');
      fs.writeFileSync('eval/stage_1/DEPENDENCY-GRAPH.md', graphContent, 'utf8');
      
      console.log('‚úì Generated DEPENDENCY-GRAPH.md');
    }
    
    generateDependencyGraph();
    ```
    
    **Run generator:**
    ```bash
    node bin/scripts/generate-dependency-graph.js
    ```
    
    **Verify output:**
    ```bash
    cat eval/stage_1/DEPENDENCY-GRAPH.md | head -50
    wc -l eval/stage_1/DEPENDENCY-GRAPH.md
    ```
  </action>
  <verify>
    - bin/scripts/generate-dependency-graph.js created
    - eval/stage_1/DEPENDENCY-GRAPH.md exists
    - Graph includes statistics section
    - Graph shows high-dependency functions
    - Graph lists all functions grouped by file
    - Each function shows depends_on and called_by relationships
  </verify>
  <done>
    Dependency graph document created showing complete function relationship map
  </done>
</task>

<task name="generate-inventory-summary" type="auto">
  <files>eval/stage_1/INVENTORY-SUMMARY.md</files>
  <action>
    Create comprehensive inventory summary document providing overview and statistics.
    
    **Create summary generator:**
    ```javascript
    #!/usr/bin/env node
    // bin/scripts/generate-inventory-summary.js
    
    const fs = require('fs-extra');
    const glob = require('glob');
    const matter = require('gray-matter');
    
    function generateInventorySummary() {
      const analysisFiles = glob.sync('eval/stage_1/*.md', {
        ignore: ['**/DEPENDENCY-GRAPH.md', '**/INVENTORY-SUMMARY.md']
      });
      
      const functions = [];
      
      // Parse all analysis documents
      for (const file of analysisFiles) {
        const content = fs.readFileSync(file, 'utf8');
        const parsed = matter(content);
        
        if (parsed.data.subject === 'function') {
          functions.push({
            name: parsed.data.name,
            sourceFile: parsed.data.source_file,
            sourceLocation: parsed.data.source_location,
            complexity: parsed.data.complexity || {},
            dependsOn: (parsed.data.depends_on || []).length,
            calledBy: (parsed.data.called_by || []).length,
            confidence: parsed.data.confidence || '100%'
          });
        }
      }
      
      // Calculate statistics
      const totalFiles = new Set(functions.map(f => f.sourceFile)).size;
      const totalFunctions = functions.length;
      
      const complexityBreakdown = {
        simple: functions.filter(f => f.complexity.cyclomatic < 5).length,
        moderate: functions.filter(f => f.complexity.cyclomatic >= 5 && f.complexity.cyclomatic < 10).length,
        complex: functions.filter(f => f.complexity.cyclomatic >= 10).length
      };
      
      const avgComplexity = functions.reduce((sum, f) => sum + (f.complexity.cyclomatic || 0), 0) / totalFunctions;
      const maxComplexity = Math.max(...functions.map(f => f.complexity.cyclomatic || 0));
      const maxNesting = Math.max(...functions.map(f => f.complexity.nesting_depth || 0));
      
      const withDependencies = functions.filter(f => f.dependsOn > 0).length;
      const withCallers = functions.filter(f => f.calledBy > 0).length;
      
      const lowConfidence = functions.filter(f => {
        const conf = parseInt(f.confidence);
        return !isNaN(conf) && conf < 100;
      });
      
      // Build summary document
      const sections = [];
      
      sections.push('# Function-level Inventory Summary\n');
      sections.push('**Phase 5.2 - Stage 1 Complete**\n');
      sections.push(`**Generated:** ${new Date().toISOString()}\n`);
      
      sections.push('## Overview\n');
      sections.push(`This document summarizes the comprehensive function-level analysis of \`bin/**\` completed in Phase 5.2 Stage 1.\n`);
      sections.push('**Purpose:** Create detailed inventory of every function with complexity metrics, I/O side effects, and dependency relationships.\n');
      sections.push('**Next:** Phase 5.3 (Stage 2) will analyze this inventory for consolidation opportunities.\n');
      
      sections.push('## Summary Statistics\n');
      sections.push(`- **Total files analyzed:** ${totalFiles}`);
      sections.push(`- **Total functions documented:** ${totalFunctions}`);
      sections.push(`- **Average complexity:** ${avgComplexity.toFixed(2)}`);
      sections.push(`- **Maximum complexity:** ${maxComplexity}`);
      sections.push(`- **Maximum nesting depth:** ${maxNesting}`);
      sections.push(`- **Functions with dependencies:** ${withDependencies} (${((withDependencies/totalFunctions)*100).toFixed(1)}%)`);
      sections.push(`- **Functions with callers:** ${withCallers} (${((withCallers/totalFunctions)*100).toFixed(1)}%)`);
      sections.push('');
      
      sections.push('## Complexity Distribution\n');
      sections.push(`- **Simple** (cyclomatic < 5): ${complexityBreakdown.simple} functions (${((complexityBreakdown.simple/totalFunctions)*100).toFixed(1)}%)`);
      sections.push(`- **Moderate** (cyclomatic 5-9): ${complexityBreakdown.moderate} functions (${((complexityBreakdown.moderate/totalFunctions)*100).toFixed(1)}%)`);
      sections.push(`- **Complex** (cyclomatic >= 10): ${complexityBreakdown.complex} functions (${((complexityBreakdown.complex/totalFunctions)*100).toFixed(1)}%)`);
      sections.push('');
      
      if (lowConfidence.length > 0) {
        sections.push('## Analysis Confidence\n');
        sections.push(`${lowConfidence.length} function(s) flagged with confidence < 100%:\n`);
        lowConfidence.forEach(f => {
          sections.push(`- **${f.name}** (${f.confidence}) - requires review`);
        });
        sections.push('');
      }
      
      sections.push('## Document Structure\n');
      sections.push('Analysis documents are organized using hybrid approach:\n');
      sections.push('- **Complex functions** (cyclomatic >= 10): Dedicated individual files');
      sections.push('- **Simple/Moderate functions**: Grouped in per-source-file analyses\n');
      
      sections.push('Each document includes:\n');
      sections.push('- **YAML header**: Metadata (name, source, complexity, dependencies, relationships)');
      sections.push('- **Markdown body**: Purpose, Signature, Inputs/Outputs, Side Effects, Complexity Analysis\n');
      
      sections.push('## Files Generated\n');
      sections.push(`Total analysis documents: ${analysisFiles.length}\n`);
      
      const dedicated = analysisFiles.filter(f => {
        const content = fs.readFileSync(f, 'utf8');
        const parsed = matter(content);
        return parsed.data.complexity?.cyclomatic >= 10;
      }).length;
      
      const grouped = analysisFiles.length - dedicated;
      
      sections.push(`- Dedicated files (complex functions): ${dedicated}`);
      sections.push(`- Grouped files (simple/moderate): ${grouped}`);
      sections.push('- DEPENDENCY-GRAPH.md: Function relationship map');
      sections.push('- INVENTORY-SUMMARY.md: This document\n');
      
      sections.push('## Next Steps\n');
      sections.push('1. **Phase 5.3 (Stage 2)**: Analyze for duplication and consolidation opportunities');
      sections.push('2. **Phase 5.4 (Stage 3)**: Review index.js function-by-function');
      sections.push('3. **Phase 5.5**: Execute approved unification plans');
      sections.push('4. **Phase 5.6**: Codex global support and path unification');
      sections.push('5. **Phase 5.7**: Future integration preparation\n');
      
      sections.push('## Success Criteria ‚úì\n');
      sections.push('- [x] Every function in bin/** analyzed and documented');
      sections.push('- [x] Complexity metrics calculated (cyclomatic, nesting, parameters)');
      sections.push('- [x] I/O side effects detected and documented');
      sections.push('- [x] Function relationships tracked (depends_on, called_by)');
      sections.push('- [x] User confirmation obtained via progressive disclosure workflow');
      sections.push('- [x] YAML+Markdown analysis documents generated');
      sections.push('- [x] Hybrid file organization implemented');
      sections.push('- [x] Dependency graph created');
      sections.push('- [x] Inventory summary generated\n');
      
      // Write summary
      const summaryContent = sections.join('\n');
      fs.writeFileSync('eval/stage_1/INVENTORY-SUMMARY.md', summaryContent, 'utf8');
      
      console.log('‚úì Generated INVENTORY-SUMMARY.md');
      console.log(`  Total functions: ${totalFunctions}`);
      console.log(`  Average complexity: ${avgComplexity.toFixed(2)}`);
    }
    
    generateInventorySummary();
    ```
    
    **Run generator:**
    ```bash
    node bin/scripts/generate-inventory-summary.js
    ```
    
    **Verify output:**
    ```bash
    cat eval/stage_1/INVENTORY-SUMMARY.md
    ```
  </action>
  <verify>
    - bin/scripts/generate-inventory-summary.js created
    - eval/stage_1/INVENTORY-SUMMARY.md exists
    - Summary includes complete statistics
    - Complexity distribution shown
    - Low-confidence functions listed (if any)
    - Success criteria checklist included
  </verify>
  <done>
    Inventory summary document provides comprehensive overview of Phase 5.2 analysis results
  </done>
</task>

<task name="verify-documentation-completeness" type="auto">
  <files>None (verification only)</files>
  <action>
    Verify all documentation meets Phase 5.2 requirements.
    
    **Create verification script:**
    ```bash
    #!/bin/bash
    # bin/scripts/verify-phase-5.2.sh
    
    echo "üîç Verifying Phase 5.2 Documentation Completeness"
    echo ""
    
    # Check directory structure
    echo "üìÅ Directory structure:"
    if [ -d "eval/stage_1" ]; then
      echo "  ‚úì eval/stage_1/ exists"
    else
      echo "  ‚úó eval/stage_1/ missing"
      exit 1
    fi
    
    # Check analysis documents
    echo ""
    echo "üìÑ Analysis documents:"
    DOC_COUNT=$(find eval/stage_1 -name "*.md" -not -name "DEPENDENCY-GRAPH.md" -not -name "INVENTORY-SUMMARY.md" | wc -l)
    echo "  Found $DOC_COUNT analysis documents"
    
    if [ $DOC_COUNT -eq 0 ]; then
      echo "  ‚úó No analysis documents found"
      exit 1
    fi
    
    # Check for YAML frontmatter
    echo ""
    echo "üìã YAML frontmatter verification:"
    YAML_COUNT=$(grep -l "^---" eval/stage_1/*.md 2>/dev/null | wc -l)
    echo "  $YAML_COUNT documents with YAML frontmatter"
    
    # Check required fields
    SUBJECT_COUNT=$(grep -l "subject: function" eval/stage_1/*.md 2>/dev/null | wc -l)
    COMPLEXITY_COUNT=$(grep -l "cyclomatic:" eval/stage_1/*.md 2>/dev/null | wc -l)
    
    echo "  $SUBJECT_COUNT with 'subject: function'"
    echo "  $COMPLEXITY_COUNT with complexity metrics"
    
    # Check dependency graph
    echo ""
    echo "üï∏Ô∏è Dependency graph:"
    if [ -f "eval/stage_1/DEPENDENCY-GRAPH.md" ]; then
      echo "  ‚úì DEPENDENCY-GRAPH.md exists"
      LINES=$(wc -l < eval/stage_1/DEPENDENCY-GRAPH.md)
      echo "    ($LINES lines)"
    else
      echo "  ‚úó DEPENDENCY-GRAPH.md missing"
      exit 1
    fi
    
    # Check inventory summary
    echo ""
    echo "üìä Inventory summary:"
    if [ -f "eval/stage_1/INVENTORY-SUMMARY.md" ]; then
      echo "  ‚úì INVENTORY-SUMMARY.md exists"
      LINES=$(wc -l < eval/stage_1/INVENTORY-SUMMARY.md)
      echo "    ($LINES lines)"
    else
      echo "  ‚úó INVENTORY-SUMMARY.md missing"
      exit 1
    fi
    
    # Check infrastructure
    echo ""
    echo "üîß Analysis infrastructure:"
    if [ -d "bin/lib/analysis" ]; then
      echo "  ‚úì bin/lib/analysis/ exists"
      UTIL_COUNT=$(find bin/lib/analysis -name "*.js" | wc -l)
      echo "    ($UTIL_COUNT utility modules)"
    else
      echo "  ‚úó bin/lib/analysis/ missing"
      exit 1
    fi
    
    if [ -d "bin/scripts" ]; then
      echo "  ‚úì bin/scripts/ exists"
      SCRIPT_COUNT=$(find bin/scripts -name "*.js" | wc -l)
      echo "    ($SCRIPT_COUNT scripts)"
    else
      echo "  ‚úó bin/scripts/ missing"
      exit 1
    fi
    
    echo ""
    echo "‚úÖ Phase 5.2 documentation verification complete!"
    echo ""
    echo "Summary:"
    echo "  - Analysis documents: $DOC_COUNT"
    echo "  - Dependency graph: ‚úì"
    echo "  - Inventory summary: ‚úì"
    echo "  - Infrastructure: ‚úì"
    echo ""
    ```
    
    **Make executable and run:**
    ```bash
    chmod +x bin/scripts/verify-phase-5.2.sh
    bash bin/scripts/verify-phase-5.2.sh
    ```
  </action>
  <verify>
    - Verification script runs without errors
    - All checks pass (‚úì indicators)
    - Analysis documents count > 0
    - DEPENDENCY-GRAPH.md exists
    - INVENTORY-SUMMARY.md exists
    - Infrastructure directories exist
  </verify>
  <done>
    Phase 5.2 documentation verified complete and meets all requirements
  </done>
</task>

<task name="update-roadmap" type="auto">
  <files>.planning/milestones/v1.10.0-ROADMAP.md</files>
  <action>
    Update roadmap to reflect Phase 5.2 completion and plan counts.
    
    **Read current roadmap:**
    ```bash
    grep -A 5 "Phase 5.2" .planning/milestones/v1.10.0-ROADMAP.md
    ```
    
    **Update Phase 5.2 entry:**
    The roadmap should show:
    - Plans: 3 plans (01-Infrastructure, 02-Analysis, 03-Documentation)
    - Brief description of each plan
    - Mark as ready for execution
    
    **Find and update the Phase 5.2 section:**
    ```bash
    # Phase 5.2 entry should be updated to show actual plan structure
    # If placeholder exists like "Plans: 0 plans" or "TBD", replace with actual
    
    # Expected format:
    # ### Phase 5.2: Function-level Inventory - Stage 1
    # **Goal:** [from CONTEXT.md]
    # **Plans:** 3 plans
    # Plans:
    # - [ ] 05.2-01-PLAN.md ‚Äî Analysis Infrastructure Setup
    # - [ ] 05.2-02-PLAN.md ‚Äî Function Analysis & Confirmation
    # - [ ] 05.2-03-PLAN.md ‚Äî Documentation Finalization
    ```
    
    Use edit tool to update the roadmap with actual plan information.
  </action>
  <verify>
    - .planning/milestones/v1.10.0-ROADMAP.md updated
    - Phase 5.2 shows "3 plans"
    - Plan list includes all three plans with brief descriptions
    - No placeholder text like "TBD" or "to be planned" remains
  </verify>
  <done>
    Roadmap updated to reflect Phase 5.2 planning complete with 3 executable plans
  </done>
</task>

## Verification

Final verification of Phase 5.2 completion:

```bash
# Run comprehensive verification
bash bin/scripts/verify-phase-5.2.sh

# Check directory structure
tree -L 2 eval/

# Count artifacts
echo "Analysis documents: $(find eval/stage_1 -name "*.md" | wc -l)"
echo "Utility modules: $(find bin/lib/analysis -name "*.js" | wc -l)"
echo "Scripts: $(find bin/scripts -name "*.js" | wc -l)"

# Verify roadmap updated
grep -A 10 "Phase 5.2" .planning/milestones/v1.10.0-ROADMAP.md
```

## Success Criteria

- [x] DEPENDENCY-GRAPH.md created with complete function relationship map
- [x] INVENTORY-SUMMARY.md created with statistics and overview
- [x] All analysis documents verified complete
- [x] YAML headers include all required fields
- [x] Markdown bodies include all required sections
- [x] Verification script passes all checks
- [x] ROADMAP.md updated with Phase 5.2 completion
- [x] Infrastructure ready for Phase 5.3 (Stage 2: Consolidation)

## Output

**Phase 5.2 complete deliverables:**

```
eval/stage_1/
‚îú‚îÄ‚îÄ DEPENDENCY-GRAPH.md          # Function relationship map
‚îú‚îÄ‚îÄ INVENTORY-SUMMARY.md         # Comprehensive statistics and overview
‚îú‚îÄ‚îÄ [source-file]-analysis.md    # Per-file analyses (simple/moderate functions)
‚îî‚îÄ‚îÄ [function-name].md           # Dedicated files (complex functions)

bin/lib/analysis/
‚îú‚îÄ‚îÄ ast-parser.js                # Function extraction from AST
‚îú‚îÄ‚îÄ complexity.js                # Cyclomatic complexity calculator
‚îú‚îÄ‚îÄ side-effects.js              # I/O side effect detector
‚îú‚îÄ‚îÄ classifier.js                # Function classification
‚îú‚îÄ‚îÄ relationships.js             # Dependency tracking
‚îî‚îÄ‚îÄ doc-generator.js             # YAML+Markdown generator

bin/scripts/
‚îú‚îÄ‚îÄ analyze-bin.js               # Main orchestrator
‚îú‚îÄ‚îÄ generate-dependency-graph.js # Graph generator
‚îú‚îÄ‚îÄ generate-inventory-summary.js # Summary generator
‚îî‚îÄ‚îÄ verify-phase-5.2.sh          # Verification script
```

**Ready for Phase 5.3:** Consolidation analysis can now consume Stage 1 inventory to identify duplication and unification opportunities.
