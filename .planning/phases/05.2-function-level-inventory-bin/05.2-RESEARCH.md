# Phase 5.2: Function-level Inventory of `bin/**` (Stage 1) - Research

**Researched:** 2025-01-25
**Domain:** JavaScript AST analysis, code complexity metrics, interactive CLI workflows
**Confidence:** MEDIUM-HIGH

## Summary

Phase 5.2 requires building a custom code analysis tool that parses JavaScript files in `bin/**`, calculates complexity metrics per function, detects I/O side effects, generates YAML+Markdown documentation, and uses an interactive confirmation workflow with progressive disclosure and smart batching.

The standard approach is **custom AST-based analysis** using established parsers (@babel/parser or acorn) with hand-rolled complexity calculation (cyclomatic, nesting depth, parameter count). Pre-existing complexity libraries (escomplex, typhonjs-escomplex) exist but are either outdated or low-version, making custom implementation more reliable. For user interaction, the project already has `prompts` library (v2.4.2) which is perfect for progressive disclosure patterns. Documentation generation leverages already-installed `gray-matter` (v4.0.3) for YAML frontmatter handling.

Key challenges: detecting helper vs exported functions, preventing confirmation fatigue through smart batching, tracking function relationships across files, and handling edge cases (anonymous functions, dynamic requires, arrow functions).

**Primary recommendation:** Build custom analyzer using @babel/parser for AST, manual complexity calculation following McCabe's algorithm, prompts for interactive workflow, gray-matter for documentation generation, and consider madge for dependency graph visualization.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @babel/parser | 7.28.6 | JavaScript AST parsing | Most complete ES feature support, handles latest syntax, TypeScript support, industry standard |
| acorn | 8.15.0 | Alternative lightweight parser | Fast, simple API, ES2020+ support, used by webpack/rollup |
| prompts | 2.4.2 (installed) | Interactive CLI prompts | Lightweight, no dependencies, multiple prompt types, already in project |
| gray-matter | 4.0.3 (installed) | YAML frontmatter parser | Standard for markdown+YAML, used by metalsmith/assemble, already in project |
| fs-extra | 11.3.3 (installed) | Enhanced file system | Already in project, better than fs for directory operations |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| madge | 8.0.0 | Dependency graph generation | Optional: if visual dependency graph needed (can be deferred) |
| chalk | 5.6.2 (installed) | Terminal colors | Already in project for formatting output |
| js-yaml | 4.1.1 (installed) | YAML serialization | Already in project for YAML operations |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| @babel/parser | espree (v11.1.0) | Espree is ESLint's parser, less feature-complete but simpler |
| @babel/parser | TypeScript Compiler API | Over-engineered for JavaScript-only analysis |
| Manual complexity | typhonjs-escomplex (v0.1.0) | Library is at v0.1.0 (very low version), manual more reliable |
| Manual complexity | escomplex (v2.0.0-alpha) | Library is alpha from 2016, abandoned |
| prompts | inquirer.js | Heavier, more dependencies, prompts already installed |

**Installation:**
```bash
npm install @babel/parser --save-dev
# OR (lighter alternative)
npm install acorn --save-dev

# Optional (only if visual graph needed)
npm install madge --save-dev
```

## Architecture Patterns

### Recommended Project Structure
```
bin/
├── lib/
│   └── analysis/           # NEW: Analysis utilities
│       ├── ast-parser.js       # AST parsing wrapper
│       ├── complexity.js       # Complexity calculation
│       ├── side-effects.js     # I/O detection
│       ├── relationships.js    # Dependency tracking
│       └── classifier.js       # Simple vs complex classification
├── scripts/
│   └── analyze-bin.js      # NEW: Main analysis script
└── [existing files...]

eval/
└── stage_1/                # NEW: Analysis output directory
    ├── DEPENDENCY-GRAPH.md     # Function relationship graph
    ├── install-js-analysis.md  # Per-file analyses
    ├── paths-js-analysis.md
    └── [complex function files...]
```

### Pattern 1: AST Visitor for Function Extraction
**What:** Traverse AST to find all function declarations, expressions, and arrow functions
**When to use:** Initial phase - discovering all functions in a file
**Example:**
```javascript
// Using @babel/parser
const parser = require('@babel/parser');
const fs = require('fs');

function extractFunctions(filePath) {
  const code = fs.readFileSync(filePath, 'utf8');
  const ast = parser.parse(code, {
    sourceType: 'module',
    plugins: ['jsx', 'typescript'] // Support TS if needed
  });
  
  const functions = [];
  
  function visit(node, parent) {
    // Handle different function types
    if (node.type === 'FunctionDeclaration') {
      functions.push({
        name: node.id.name,
        type: 'declaration',
        params: node.params,
        body: node.body,
        loc: node.loc
      });
    } else if (node.type === 'FunctionExpression') {
      // Named or anonymous
      const name = node.id?.name || `anonymous_${node.loc.start.line}`;
      functions.push({
        name,
        type: 'expression',
        params: node.params,
        body: node.body,
        loc: node.loc
      });
    } else if (node.type === 'ArrowFunctionExpression') {
      functions.push({
        name: `arrow_${node.loc.start.line}`,
        type: 'arrow',
        params: node.params,
        body: node.body,
        loc: node.loc
      });
    }
    
    // Recursive traversal
    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          node[key].forEach(child => visit(child, node));
        } else {
          visit(node[key], node);
        }
      }
    }
  }
  
  visit(ast, null);
  return functions;
}
```

### Pattern 2: Cyclomatic Complexity Calculation
**What:** Calculate McCabe's cyclomatic complexity by counting decision points
**When to use:** For every function extracted
**Example:**
```javascript
function calculateComplexity(functionNode) {
  let complexity = 1; // Base complexity
  let maxNestingDepth = 0;
  let currentDepth = 0;
  
  function visit(node) {
    // Track nesting depth
    const depthIncreasingNodes = [
      'IfStatement', 'ForStatement', 'WhileStatement', 
      'DoWhileStatement', 'SwitchStatement'
    ];
    
    if (depthIncreasingNodes.includes(node.type)) {
      currentDepth++;
      maxNestingDepth = Math.max(maxNestingDepth, currentDepth);
    }
    
    // Count decision points (add to complexity)
    switch (node.type) {
      case 'IfStatement':
      case 'ConditionalExpression': // Ternary
      case 'ForStatement':
      case 'ForInStatement':
      case 'ForOfStatement':
      case 'WhileStatement':
      case 'DoWhileStatement':
        complexity++;
        break;
      case 'SwitchCase':
        if (node.test) complexity++; // Each case, not default
        break;
      case 'CatchClause':
        complexity++;
        break;
      case 'LogicalExpression':
        // && and || add complexity
        if (node.operator === '&&' || node.operator === '||') {
          complexity++;
        }
        break;
    }
    
    // Recursively visit children
    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          node[key].forEach(visit);
        } else {
          visit(node[key]);
        }
      }
    }
    
    // Decrease depth when leaving nesting node
    if (depthIncreasingNodes.includes(node.type)) {
      currentDepth--;
    }
  }
  
  visit(functionNode.body);
  
  return {
    cyclomatic: complexity,
    nesting_depth: maxNestingDepth,
    parameter_count: functionNode.params.length
  };
}
```

### Pattern 3: I/O Side Effect Detection
**What:** Detect file system, console, and network operations (per user decision: I/O only)
**When to use:** For every function analyzed
**Example:**
```javascript
function detectIOSideEffects(functionNode) {
  const sideEffects = [];
  
  function visit(node) {
    // Check for member expressions: fs.readFile, console.log, etc.
    if (node.type === 'MemberExpression') {
      const object = node.object.name;
      const property = node.property.name || node.property.value;
      
      // File system operations
      if (object === 'fs' || object === 'fse') {
        sideEffects.push({
          type: 'file_system',
          operation: property,
          line: node.loc.start.line
        });
      }
      
      // Console operations
      if (object === 'console') {
        sideEffects.push({
          type: 'console',
          operation: property,
          line: node.loc.start.line
        });
      }
      
      // Process I/O (stdout/stderr only, not env/exit per user decision)
      if (object === 'process' && (property === 'stdout' || property === 'stderr')) {
        sideEffects.push({
          type: 'process_io',
          operation: property,
          line: node.loc.start.line
        });
      }
    }
    
    // Check for require('http'), require('https'), require('net')
    if (node.type === 'CallExpression' && node.callee.name === 'require') {
      const arg = node.arguments[0];
      if (arg && arg.value) {
        const networkModules = ['http', 'https', 'net', 'node-fetch', 'axios'];
        if (networkModules.includes(arg.value)) {
          sideEffects.push({
            type: 'network',
            operation: `require('${arg.value}')`,
            line: node.loc.start.line
          });
        }
      }
    }
    
    // Recursive traversal
    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          node[key].forEach(visit);
        } else {
          visit(node[key]);
        }
      }
    }
  }
  
  visit(functionNode.body);
  return sideEffects;
}
```

### Pattern 4: Progressive Disclosure Confirmation
**What:** Show summary first, allow expansion, then confirm in batches
**When to use:** User confirmation workflow
**Example:**
```javascript
const prompts = require('prompts');

async function confirmAnalyses(analyses) {
  // Classify functions
  const simple = analyses.filter(a => a.complexity.cyclomatic < 5);
  const moderate = analyses.filter(a => a.complexity.cyclomatic >= 5 && a.complexity.cyclomatic < 10);
  const complex = analyses.filter(a => a.complexity.cyclomatic >= 10);
  
  console.log(`\nAnalyzed ${analyses.length} functions:`);
  console.log(`  - ${simple.length} simple (complexity < 5)`);
  console.log(`  - ${moderate.length} moderate (complexity 5-9)`);
  console.log(`  - ${complex.length} complex (complexity >= 10)`);
  
  // Batch confirm simple functions
  if (simple.length > 0) {
    const { showSimple } = await prompts({
      type: 'confirm',
      name: 'showSimple',
      message: `Show details for ${simple.length} simple functions?`,
      initial: false
    });
    
    if (showSimple) {
      simple.forEach(a => console.log(`  - ${a.name} (complexity ${a.complexity.cyclomatic})`));
    }
    
    const { approveSimple } = await prompts({
      type: 'confirm',
      name: 'approveSimple',
      message: `Approve all ${simple.length} simple functions?`,
      initial: true
    });
    
    if (!approveSimple) {
      console.log('Simple functions not approved. Stopping.');
      return false;
    }
  }
  
  // Individual confirmation for complex functions
  for (const analysis of complex) {
    console.log(`\n=== ${analysis.name} ===`);
    console.log(`Complexity: ${analysis.complexity.cyclomatic}`);
    console.log(`Nesting depth: ${analysis.complexity.nesting_depth}`);
    console.log(`Parameters: ${analysis.complexity.parameter_count}`);
    console.log(`Side effects: ${analysis.sideEffects.length}`);
    
    const { action } = await prompts({
      type: 'select',
      name: 'action',
      message: 'Action:',
      choices: [
        { title: 'Approve', value: 'approve' },
        { title: 'Show full analysis', value: 'show' },
        { title: 'Skip for now', value: 'skip' },
        { title: 'Abort', value: 'abort' }
      ]
    });
    
    if (action === 'abort') {
      return false;
    } else if (action === 'show') {
      console.log(analysis.fullAnalysis);
      // Ask again after showing
    } else if (action === 'skip') {
      continue;
    }
  }
  
  return true;
}
```

### Pattern 5: YAML+Markdown Documentation Generation
**What:** Use gray-matter to create structured analysis documents
**When to use:** Writing analysis results to eval/stage_1/
**Example:**
```javascript
const matter = require('gray-matter');
const fs = require('fs-extra');
const path = require('path');

function generateAnalysisDocument(functionAnalysis, outputDir) {
  const metadata = {
    subject: 'function',
    name: functionAnalysis.name,
    source_file: path.basename(functionAnalysis.sourceFile),
    source_location: functionAnalysis.sourceFile,
    function_count_in_file: functionAnalysis.totalInFile,
    analysis_stage: 1,
    last_updated: new Date().toISOString(),
    complexity: {
      cyclomatic: functionAnalysis.complexity.cyclomatic,
      nesting_depth: functionAnalysis.complexity.nesting_depth,
      parameter_count: functionAnalysis.complexity.parameter_count
    },
    depends_on: functionAnalysis.dependencies,
    called_by: functionAnalysis.calledBy,
  };
  
  // Add confidence field only if < 100%
  if (functionAnalysis.confidence < 100) {
    metadata.confidence = functionAnalysis.confidence;
  }
  
  const markdownBody = `# Function: ${functionAnalysis.name}

## Purpose
${functionAnalysis.purpose}

## Signature
\`\`\`javascript
${functionAnalysis.signature}
\`\`\`

## Inputs/Outputs
- **Inputs**: ${functionAnalysis.inputs}
- **Returns**: ${functionAnalysis.returns}

## Dependencies
${functionAnalysis.dependencies.map(d => `- \`${d}()\` - [link to analysis](${d}-analysis.md)`).join('\n')}

## Side Effects
${functionAnalysis.sideEffects.length > 0 
  ? functionAnalysis.sideEffects.map(se => `- **${se.type}**: ${se.operation} (line ${se.line})`).join('\n')
  : 'None detected'}

## Complexity Analysis
- Cyclomatic complexity: ${functionAnalysis.complexity.cyclomatic}
- Nesting depth: ${functionAnalysis.complexity.nesting_depth}
- Parameter count: ${functionAnalysis.complexity.parameter_count}
- Classification: ${classifyComplexity(functionAnalysis.complexity.cyclomatic)}

${functionAnalysis.internalHelpers.length > 0 ? `
## Internal Helpers
${functionAnalysis.internalHelpers.map(h => `### ${h.name}\n${h.description}`).join('\n\n')}
` : ''}

${functionAnalysis.confidence < 100 ? `
## Uncertainties
${functionAnalysis.uncertainties.map(u => `- ${u.marker} ${u.description}`).join('\n')}
` : ''}
`;

  const document = matter.stringify(markdownBody, metadata);
  
  // Determine filename
  const filename = functionAnalysis.complexity.cyclomatic >= 10
    ? `${functionAnalysis.name}.md`  // Complex functions get own file
    : `${path.basename(functionAnalysis.sourceFile, '.js')}-analysis.md`; // Simple in per-file docs
  
  const outputPath = path.join(outputDir, filename);
  fs.ensureDirSync(outputDir);
  fs.writeFileSync(outputPath, document, 'utf8');
  
  return outputPath;
}

function classifyComplexity(cyclomatic) {
  if (cyclomatic < 5) return 'Simple';
  if (cyclomatic < 10) return 'Moderate';
  return 'Complex';
}
```

### Anti-Patterns to Avoid
- **File-by-file only processing**: User wants per-function analysis, not per-file
- **Re-parsing same file**: Parse once, extract all functions, cache AST
- **Ignoring arrow functions**: Must visit ArrowFunctionExpression nodes
- **Treating all functions equally**: User wants adaptive depth (complex vs simple)
- **Binary yes/no prompts only**: Offer Show Details, Skip, Abort options
- **Hardcoded thresholds**: Make complexity thresholds configurable (current suggestion: simple < 5, complex >= 10)
- **Forgetting helper functions**: Must document in parent function's analysis, not separately

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| YAML parsing | Custom YAML parser | gray-matter (installed) | Handles edge cases, frontmatter delimiters, multiple formats |
| Terminal prompts | readline loops | prompts (installed) | Validation, styling, multiple types, Ctrl+C handling |
| File system operations | fs callbacks | fs-extra (installed) | Promises, ensureDir, better error handling |
| Dependency graph visualization | Custom graph renderer | madge (if needed) | Handles cycles, multiple formats, mature tool |
| AST parsing | Regex-based parsing | @babel/parser or acorn | Handles all syntax edge cases, future-proof |

**Key insight:** AST parsing and static analysis is a well-solved problem with mature tools. The custom part is the *interpretation* (complexity calculation, side effect detection, classification), not the parsing itself.

## Common Pitfalls

### Pitfall 1: Missing Function Types
**What goes wrong:** Only visiting FunctionDeclaration nodes, missing arrow functions and function expressions
**Why it happens:** AST has three different node types for functions
**How to avoid:** Visit FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression
**Warning signs:** Function count lower than expected, exported arrow functions missing

### Pitfall 2: Under-counting Complexity
**What goes wrong:** Missing logical operators (`&&`, `||`) and ternaries in complexity calculation
**Why it happens:** These aren't obvious control flow statements
**How to avoid:** Visit LogicalExpression and ConditionalExpression nodes, add +1 for each
**Warning signs:** All functions show low complexity, even obviously complex ones

### Pitfall 3: Dynamic Requires Break Dependency Tracking
**What goes wrong:** `require(someVariable)` can't be statically resolved
**Why it happens:** Static analysis can't evaluate runtime values
**How to avoid:** Detect dynamic requires, mark as uncertain, document in analysis
**Warning signs:** Missing dependencies in graph, broken links in documentation

### Pitfall 4: Confirmation Fatigue
**What goes wrong:** User approves everything without reading after 20+ confirmations
**Why it happens:** Too many individual confirmations, no batching
**How to avoid:** Batch simple functions (complexity < 5), only individual review for complex (>= 10)
**Warning signs:** User says "yes" to everything, doesn't engage with details

### Pitfall 5: Name Collisions in Output Files
**What goes wrong:** Two functions with same name in different files overwrite each other
**Why it happens:** Using only function name for filename
**How to avoid:** Use hybrid approach - per-file for simple functions, dedicated files for complex
**Warning signs:** Missing analysis files, wrong file content

### Pitfall 6: Transitive Side Effects Missed
**What goes wrong:** Function calls another that does I/O, marked as "no side effects"
**Why it happens:** Only detecting direct I/O calls in function body
**How to avoid:** Stage 1: mark as direct only, flag for deeper analysis in Stage 2
**Warning signs:** Functions that clearly do I/O marked as pure

### Pitfall 7: Anonymous Function Naming
**What goes wrong:** Anonymous functions have no trackable name
**Why it happens:** `const handler = function() {}` has no function.id
**How to avoid:** Generate synthetic names using variable name or line number
**Warning signs:** Multiple functions with same name "anonymous"

### Pitfall 8: Forgetting Helper Functions
**What goes wrong:** Internal helper functions analyzed as separate entries
**Why it happens:** Treating all functions equally without parent context
**How to avoid:** Track function scope, document helpers within parent's analysis
**Warning signs:** Analysis document count >> meaningful function count

### Pitfall 9: Ignoring User's Scope Decisions
**What goes wrong:** Analyzing state mutations when user said "I/O only"
**Why it happens:** Not reading CONTEXT.md decisions carefully
**How to avoid:** Read CONTEXT.md first, constrain analysis to user's decisions
**Warning signs:** Analysis includes fields not requested (e.g., "mutates" field)

## Code Examples

Verified patterns from research:

### Complete Analysis Pipeline
```javascript
// analyze-bin.js - Main script
const parser = require('@babel/parser');
const fs = require('fs-extra');
const path = require('path');
const glob = require('glob');
const prompts = require('prompts');
const matter = require('gray-matter');

// Import analysis utilities
const { calculateComplexity } = require('../lib/analysis/complexity');
const { detectIOSideEffects } = require('../lib/analysis/side-effects');
const { extractFunctions } = require('../lib/analysis/ast-parser');
const { classifyFunction } = require('../lib/analysis/classifier');

async function analyzeAllFunctions() {
  const binFiles = glob.sync('bin/**/*.js', { 
    ignore: ['**/*.test.js', '**/node_modules/**'] 
  });
  
  console.log(`Found ${binFiles.length} files in bin/`);
  
  const allAnalyses = [];
  
  // Step 1: Analyze all files without interruption
  for (const file of binFiles) {
    const functions = extractFunctions(file);
    
    for (const fn of functions) {
      const complexity = calculateComplexity(fn);
      const sideEffects = detectIOSideEffects(fn);
      const classification = classifyFunction(complexity);
      
      allAnalyses.push({
        name: fn.name,
        sourceFile: file,
        complexity,
        sideEffects,
        classification,
        // ... other metadata
      });
    }
  }
  
  console.log(`\nAnalyzed ${allAnalyses.length} functions`);
  
  // Step 2: Interactive confirmation with batching
  const approved = await confirmAnalyses(allAnalyses);
  
  if (!approved) {
    console.log('Analysis cancelled by user');
    return;
  }
  
  // Step 3: Generate documentation
  const outputDir = 'eval/stage_1';
  fs.ensureDirSync(outputDir);
  
  for (const analysis of allAnalyses) {
    generateAnalysisDocument(analysis, outputDir);
  }
  
  // Step 4: Generate dependency graph
  generateDependencyGraph(allAnalyses, outputDir);
  
  console.log(`\nComplete! Analysis documents written to ${outputDir}/`);
}

analyzeAllFunctions().catch(console.error);
```

### Handling Different Module Formats
```javascript
// ast-parser.js
const parser = require('@babel/parser');

function parseFile(filePath) {
  const code = fs.readFileSync(filePath, 'utf8');
  
  // Try parsing with different source types
  const parseOptions = [
    { sourceType: 'module' },  // ES modules
    { sourceType: 'script' },  // CommonJS
    { sourceType: 'unambiguous' }  // Auto-detect
  ];
  
  for (const options of parseOptions) {
    try {
      return parser.parse(code, {
        ...options,
        plugins: ['jsx'],  // Support JSX just in case
        errorRecovery: true  // Continue parsing on errors
      });
    } catch (err) {
      // Try next option
      continue;
    }
  }
  
  throw new Error(`Failed to parse ${filePath}`);
}
```

### Dependency Extraction
```javascript
// relationships.js
function extractDependencies(functionNode, sourceFile) {
  const dependencies = [];
  
  function visit(node) {
    // Direct function calls
    if (node.type === 'CallExpression') {
      if (node.callee.type === 'Identifier') {
        dependencies.push({
          name: node.callee.name,
          type: 'direct',
          line: node.loc.start.line
        });
      } else if (node.callee.type === 'MemberExpression') {
        // method.call() - track the method
        const method = node.callee.property.name;
        dependencies.push({
          name: method,
          type: 'method',
          line: node.loc.start.line
        });
      }
    }
    
    // Recursive traversal
    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          node[key].forEach(visit);
        } else {
          visit(node[key]);
        }
      }
    }
  }
  
  visit(functionNode.body);
  
  // Deduplicate and filter
  const unique = [...new Set(dependencies.map(d => d.name))];
  
  return unique;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| escomplex library | Custom AST-based calculation | 2020-2025 | escomplex last updated 2016, libraries stagnant, manual calculation more reliable |
| Inquirer.js | prompts library | 2019+ | Prompts is lighter (no dependencies), more modern API |
| TypeScript Compiler API for JS | Babel parser | 2020+ | Babel better for pure JS analysis, TS API over-engineered |
| Plato for reporting | Custom markdown generation | 2023+ | Plato UI-focused, phase needs structured docs not HTML |

**Deprecated/outdated:**
- **escomplex (v2.0.0-alpha)**: Alpha version from 2016, not maintained
- **complexity-report**: Depends on escomplex, same issues
- **grunt-plato**: HTML visualization, not suitable for this use case
- **Esprima**: Replaced by Acorn/Babel in most projects

## Open Questions

Things that couldn't be fully resolved:

1. **Exact complexity threshold for batching**
   - What we know: User wants smart batching, complex functions individual review
   - What's unclear: Exact cyclomatic complexity threshold (5? 7? 10?)
   - Recommendation: Start with < 5 = simple, 5-9 = moderate, >= 10 = complex. Make configurable for tuning.

2. **Helper function detection heuristic**
   - What we know: Internal helpers documented with parent, not separately
   - What's unclear: How to detect "helper" vs "utility" programmatically
   - Recommendation: Use scope (non-exported) + naming convention (starts with underscore or lowercase) + called by only one function

3. **Confidence level calculation**
   - What we know: Need confidence percentage when interpretation uncertain
   - What's unclear: Formula for calculating confidence
   - Recommendation: Start at 100%, deduct points for: dynamic requires (-20%), unclear naming (-10%), no JSDoc (-5%), complex logic (-10%)

4. **Call site analysis depth**
   - What we know: Need to track "called_by" for each function
   - What's unclear: How deep to traverse (direct only? transitive?)
   - Recommendation: Stage 1: direct calls only (one level up). Transitive in Stage 2.

5. **Handling require() variants**
   - What we know: Must track dependencies via require() calls
   - What's unclear: How to handle destructured requires, re-exports, dynamic requires
   - Recommendation: Track `const { a } = require()` as dependency on module, flag dynamic requires as "uncertain"

## Sources

### Primary (HIGH confidence)
- npm package data for @babel/parser (v7.28.6), acorn (v8.15.0), prompts (v2.4.2), gray-matter (v4.0.3), madge (v8.0.0)
- User decisions from `.planning/phases/05.2-function-level-inventory-bin/05.2-01-CONTEXT.md` (15 decisions)
- Cyclomatic Complexity standard (McCabe, 1976) - well-established algorithm
- ESTree specification for AST node types

### Secondary (MEDIUM confidence)
- npm package searches for complexity analysis tools (escomplex ecosystem outdated)
- Common practice for AST traversal patterns (visitor pattern)
- Progressive disclosure CLI patterns (general software pattern, not library-specific)

### Tertiary (LOW confidence - needs validation)
- Exact thresholds for complexity classification (< 5 simple, >= 10 complex) - common but not standardized
- Helper function detection heuristics - no established standard found
- Confidence calculation formula - custom approach needed

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Libraries verified via npm, versions confirmed, already-installed packages identified
- Architecture: MEDIUM-HIGH - Patterns are standard (AST visitor, complexity calculation) but specific implementation needs testing
- Pitfalls: HIGH - Based on known AST analysis challenges, user decision context, and common CLI workflow issues
- Code examples: MEDIUM - Patterns are correct but untested in this specific project context

**Research date:** 2025-01-25
**Valid until:** ~60 days (stable domain - AST parsing and complexity analysis change slowly)

**Key uncertainties requiring planning/execution validation:**
1. Exact complexity thresholds for batching (recommend: < 5 simple, >= 10 complex)
2. Helper function detection algorithm (recommend: scope + naming + single caller)
3. Confidence percentage calculation method (recommend: deduction-based starting at 100%)
4. Whether to use @babel/parser or acorn (recommend: @babel/parser for completeness)
5. Whether dependency graph visualization (madge) is needed in Phase 5.2 or deferred

**Alignment with CONTEXT.md:**
- ✅ Per-function analysis (not file-by-file)
- ✅ Adaptive depth (complex vs simple)
- ✅ Helper functions in context
- ✅ Complexity metrics (cyclomatic, nesting, params)
- ✅ I/O side effects only (not state mutations)
- ✅ Investigation-first workflow
- ✅ Smart batching confirmation
- ✅ Progressive disclosure
- ✅ YAML + Markdown hybrid
- ✅ All three uncertainty markers
- ✅ Relationship tracking (cross-refs + YAML + graph)
