---
phase: 05.2-function-level-inventory-bin
plan: 01b
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/analysis/side-effects.js
  - bin/lib/analysis/classifier.js
  - bin/lib/analysis/confidence.js
  - bin/lib/analysis/relationships.js
autonomous: true
must_haves:
  - "I/O side effects correctly detected (file system, console, network)"
  - "Helper functions identified via 3-heuristic algorithm"
  - "Low-confidence analyses flagged with specific deduction reasons"
  - "Function call relationships tracked (direct calls only)"
  - "All utilities integrate with foundation modules"
---

# Phase 05.2 Plan 01b: Advanced Analysis Utilities

## Objective

Build advanced analysis utilities implementing resolved research questions: side effects detector (I/O only), classifier with 3-heuristic helper detection, confidence calculator with deduction formula, and relationships tracker (direct calls only).

## Context

This plan completes the analysis infrastructure started in Plan 01a. With foundation modules (parser, complexity) in place, we now build the advanced utilities:

**Resolved Question 2 - Helper Detection:**
- Use ALL THREE heuristics:
  1. Scope: not exported (not in module.exports or export statement)
  2. Naming: follows helper patterns (_helper, internal*, private*, etc.)
  3. Usage: called by only one parent function
- **Implementation**: If 2+ heuristics match → classify as helper

**Resolved Question 3 - Confidence Calculation:**
- Start at 100%, apply deductions:
  - Dynamic requires/imports: -20%
  - Unclear/generic naming: -10%
  - No JSDoc comments: -5%
  - Complex control flow without docs: -15%
  - External deps without clear purpose: -10%
- **Implementation**: Minimum confidence 30%

**Resolved Question 4 - Call Site Analysis:**
- Stage 1: Direct calls only (one level deep)
- **Implementation**: Record call sites but don't traverse beyond immediate dependencies

This plan creates all advanced utilities with these decisions baked in.

## Tasks

<task name="build-side-effects-detector" type="auto">
  <files>bin/lib/analysis/side-effects.js</files>
  <action>
    Create side effects detector (I/O operations only per CONTEXT.md).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/side-effects.js

    /**
     * Detect I/O side effects in a function
     * Per CONTEXT.md: I/O operations only (file system, console, network)
     * NOT state mutations
     * @param {Object} functionNode - AST node for the function
     * @returns {Array} Array of side effect objects
     */
    function detectIOSideEffects(functionNode) {
      const sideEffects = [];
      
      function visit(node) {
        // Check for member expressions: fs.readFile, console.log, etc.
        if (node.type === 'MemberExpression' && node.object?.name && node.property) {
          const object = node.object.name;
          const property = node.property.name || node.property.value;
          
          // File system operations
          if (object === 'fs' || object === 'fse' || object === 'fsExtra') {
            sideEffects.push({
              type: 'file_system',
              operation: `${object}.${property}`,
              line: node.loc?.start.line
            });
          }
          
          // Console operations
          if (object === 'console') {
            sideEffects.push({
              type: 'console',
              operation: `console.${property}`,
              line: node.loc?.start.line
            });
          }
          
          // Process I/O (stdout/stderr only)
          if (object === 'process' && (property === 'stdout' || property === 'stderr')) {
            sideEffects.push({
              type: 'process_io',
              operation: `process.${property}`,
              line: node.loc?.start.line
            });
          }
        }
        
        // Check for require() calls to network modules
        if (node.type === 'CallExpression' && node.callee?.name === 'require') {
          const arg = node.arguments?.[0];
          if (arg?.value) {
            const networkModules = ['http', 'https', 'net', 'node-fetch', 'axios', 'request'];
            if (networkModules.includes(arg.value)) {
              sideEffects.push({
                type: 'network_import',
                operation: `require('${arg.value}')`,
                line: node.loc?.start.line
              });
            }
          }
        }
        
        // Recursive traversal
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child);
                }
              });
            } else if (node[key].type) {
              visit(node[key]);
            }
          }
        }
      }
      
      visit(functionNode.body);
      return sideEffects;
    }

    module.exports = {
      detectIOSideEffects
    };
    ```
  </action>
  <verify>
    - bin/lib/analysis/side-effects.js exists
    - Detects file_system, console, process_io, network_import
    - Only I/O operations (not state mutations)
  </verify>
  <done>
    Side effects detector finds I/O operations only (per requirements)
  </done>
</task>

<task name="build-classifier-and-relationships" type="auto">
  <files>bin/lib/analysis/classifier.js, bin/lib/analysis/relationships.js</files>
  <action>
    Create classifier (Question 2: 3-heuristic helper detection) and relationships tracker (Question 4: direct calls only).
    
    **Classifier implementation:**
    ```javascript
    // bin/lib/analysis/classifier.js

    /**
     * Classify a function based on complexity
     * Used for smart batching
     * @param {Object} functionInfo - Function metadata with complexity
     * @returns {string} Classification (simple/moderate/complex)
     */
    function classifyFunction(functionInfo) {
      const { complexity } = functionInfo;
      
      // Use thresholds from complexity module
      if (complexity.cyclomatic < 5) {
        return 'simple';
      } else if (complexity.cyclomatic < 10) {
        return 'moderate';
      } else {
        return 'complex';
      }
    }

    /**
     * Determine if function is a helper using 3-heuristic algorithm
     * Resolved Question 2: Use ALL THREE heuristics, 2+ matches = helper
     * 
     * Heuristics:
     * 1. Scope: function is not exported
     * 2. Naming: follows helper naming patterns (_*, internal*, private*, anonymous*)
     * 3. Usage: called by only one parent function (single caller)
     * 
     * @param {Object} functionInfo - Function metadata
     * @param {Array} allFunctions - All functions for usage analysis
     * @returns {Object} { isHelper: boolean, matchedHeuristics: number, heuristics: [] }
     */
    function isHelperFunction(functionInfo, allFunctions = []) {
      const heuristics = [];
      
      // Heuristic 1: Scope (not exported)
      if (!functionInfo.isExported) {
        heuristics.push('scope');
      }
      
      // Heuristic 2: Naming patterns
      const name = functionInfo.name;
      const helperPatterns = [
        /^_/,            // Starts with underscore
        /^internal/i,    // Starts with internal
        /^private/i,     // Starts with private
        /^anonymous/,    // Anonymous function
        /^arrow_/,       // Arrow function
        /helper$/i,      // Ends with helper
        /util$/i         // Ends with util
      ];
      
      if (helperPatterns.some(pattern => pattern.test(name))) {
        heuristics.push('naming');
      }
      
      // Heuristic 3: Usage (single caller)
      // Only applicable if we have calledBy information
      if (functionInfo.calledBy && functionInfo.calledBy.length === 1) {
        heuristics.push('usage');
      } else if (functionInfo.depth > 0) {
        // Nested function (defined inside another) = definitely helper
        heuristics.push('usage');
      }
      
      // Resolved Question 2: If 2+ heuristics match → classify as helper
      const matchedCount = heuristics.length;
      const isHelper = matchedCount >= 2;
      
      return {
        isHelper,
        matchedHeuristics: matchedCount,
        heuristics
      };
    }

    module.exports = {
      classifyFunction,
      isHelperFunction
    };
    ```
    
    **Relationships tracker implementation:**
    ```javascript
    // bin/lib/analysis/relationships.js

    /**
     * Extract function dependencies
     * Resolved Question 4: Stage 1 is DIRECT CALLS ONLY (one level deep)
     * Transitive call analysis deferred to Stage 2
     * @param {Object} functionNode - AST node for the function
     * @returns {Array} Array of function names called directly
     */
    function extractDependencies(functionNode) {
      const dependencies = [];
      
      function visit(node) {
        // Direct function calls only
        if (node.type === 'CallExpression') {
          if (node.callee?.type === 'Identifier') {
            dependencies.push(node.callee.name);
          } else if (node.callee?.type === 'MemberExpression') {
            // method.call() - track the method name
            const method = node.callee.property?.name;
            if (method) {
              dependencies.push(method);
            }
          }
        }
        
        // Recursive traversal (but only record immediate calls, not transitive)
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child);
                }
              });
            } else if (node[key].type) {
              visit(node[key]);
            }
          }
        }
      }
      
      visit(functionNode.body);
      
      // Deduplicate
      return [...new Set(dependencies)];
    }

    /**
     * Build reverse dependency map (called_by)
     * @param {Array} allFunctions - All analyzed functions
     * @returns {Map} Map of function name -> array of callers
     */
    function buildCalledByMap(allFunctions) {
      const calledByMap = new Map();
      
      // Initialize map
      allFunctions.forEach(fn => {
        calledByMap.set(fn.name, []);
      });
      
      // Build reverse dependencies (direct only, per Question 4)
      allFunctions.forEach(fn => {
        if (fn.dependencies) {
          fn.dependencies.forEach(depName => {
            if (calledByMap.has(depName)) {
              calledByMap.get(depName).push(fn.name);
            }
          });
        }
      });
      
      return calledByMap;
    }

    module.exports = {
      extractDependencies,
      buildCalledByMap
    };
    ```
    
    **Test both utilities:**
    ```bash
    node -e "
    const { isHelperFunction } = require('./bin/lib/analysis/classifier.js');
    const { buildCalledByMap } = require('./bin/lib/analysis/relationships.js');
    
    const helper = { name: '_internal', isExported: false, depth: 0, calledBy: ['parent'] };
    const exported = { name: 'publicFunc', isExported: true, depth: 0, calledBy: [] };
    
    console.log('Helper test:', isHelperFunction(helper));
    console.log('Exported test:', isHelperFunction(exported));
    
    const funcs = [
      { name: 'A', dependencies: ['B'] },
      { name: 'B', dependencies: [] }
    ];
    const map = buildCalledByMap(funcs);
    console.log('B called by:', map.get('B'));
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/classifier.js exists
    - isHelperFunction implements 3-heuristic algorithm (2+ = helper)
    - bin/lib/analysis/relationships.js exists
    - extractDependencies records ONLY direct calls
    - buildCalledByMap creates reverse dependency map
  </verify>
  <done>
    Classifier with 3-heuristic helper detection and relationships tracker (direct calls only) implemented
  </done>
</task>

<task name="build-confidence-calculator" type="auto">
  <files>bin/lib/analysis/confidence.js</files>
  <action>
    Create confidence calculator implementing resolved Question 3 (deduction-based formula).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/confidence.js

    /**
     * Calculate confidence percentage for function analysis
     * Resolved Question 3: Start at 100%, apply deductions, minimum 30%
     * 
     * Deductions:
     * - Dynamic requires/imports: -20%
     * - Unclear/generic naming: -10%
     * - No JSDoc comments: -5%
     * - Complex control flow without documentation: -15%
     * - External dependency usage without clear purpose: -10%
     * 
     * @param {Object} functionInfo - Function metadata
     * @param {Object} ast - AST node for checking documentation
     * @returns {Object} { confidence: number, deductions: [], reasons: [] }
     */
    function calculateConfidence(functionInfo, ast = null) {
      let confidence = 100;
      const deductions = [];
      const reasons = [];
      
      // Check for dynamic requires/imports
      if (hasDynamicRequires(functionInfo)) {
        confidence -= 20;
        deductions.push({ amount: 20, reason: 'Dynamic requires/imports detected' });
        reasons.push('Dynamic requires make dependency analysis uncertain');
      }
      
      // Check for unclear/generic naming
      if (hasUnclearNaming(functionInfo.name)) {
        confidence -= 10;
        deductions.push({ amount: 10, reason: 'Unclear or generic function name' });
        reasons.push(`Name "${functionInfo.name}" is generic or unclear`);
      }
      
      // Check for JSDoc comments
      if (!hasJSDoc(functionInfo, ast)) {
        confidence -= 5;
        deductions.push({ amount: 5, reason: 'No JSDoc documentation' });
        reasons.push('Missing JSDoc comments');
      }
      
      // Check for complex control flow without documentation
      if (isComplexWithoutDocs(functionInfo, ast)) {
        confidence -= 15;
        deductions.push({ amount: 15, reason: 'Complex control flow without documentation' });
        reasons.push(`Complexity ${functionInfo.complexity.cyclomatic} but no documentation`);
      }
      
      // Check for unclear external dependencies
      if (hasUnclearDependencies(functionInfo)) {
        confidence -= 10;
        deductions.push({ amount: 10, reason: 'External dependencies without clear purpose' });
        reasons.push('Dependencies used but purpose unclear');
      }
      
      // Minimum confidence: 30%
      confidence = Math.max(confidence, 30);
      
      return {
        confidence,
        deductions,
        reasons
      };
    }

    /**
     * Check for dynamic require() calls
     */
    function hasDynamicRequires(functionInfo) {
      // Check if dependencies include patterns like require(variable)
      if (functionInfo.dependencies) {
        return functionInfo.dependencies.some(dep => 
          dep.includes('require') && !dep.match(/require\(['"][\w/-]+['"]\)/)
        );
      }
      return false;
    }

    /**
     * Check for unclear/generic naming
     */
    function hasUnclearNaming(name) {
      const genericNames = [
        /^temp/i, /^tmp/i, /^test/i, /^foo/i, /^bar/i,
        /^handle/i, /^process/i, /^do/i, /^run/i,
        /^func\d*/i, /^fn\d*/i, /^method\d*/i,
        /^util$/i, /^helper$/i, /^main$/i
      ];
      
      return genericNames.some(pattern => pattern.test(name));
    }

    /**
     * Check for JSDoc comments
     * (Simplified - just check if ast has comments property)
     */
    function hasJSDoc(functionInfo, ast) {
      // If no AST provided, assume no JSDoc
      if (!ast || !ast.leadingComments) {
        return false;
      }
      
      // Check for /** */ style comments
      return ast.leadingComments.some(comment => 
        comment.type === 'CommentBlock' && comment.value.trim().startsWith('*')
      );
    }

    /**
     * Check if complex but undocumented
     */
    function isComplexWithoutDocs(functionInfo, ast) {
      const isComplex = functionInfo.complexity && functionInfo.complexity.cyclomatic >= 10;
      const lacksDoc = !hasJSDoc(functionInfo, ast);
      return isComplex && lacksDoc;
    }

    /**
     * Check for unclear external dependencies
     */
    function hasUnclearDependencies(functionInfo) {
      // If has external deps but no clear documentation, flag it
      if (functionInfo.dependencies && functionInfo.dependencies.length > 3) {
        return !functionInfo.purpose;  // Many deps but no documented purpose
      }
      return false;
    }

    module.exports = {
      calculateConfidence
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const { calculateConfidence } = require('./bin/lib/analysis/confidence.js');
    
    const perfect = { name: 'validateInput', complexity: { cyclomatic: 3 }, dependencies: [] };
    const unclear = { name: 'temp', complexity: { cyclomatic: 12 }, dependencies: ['require(x)'] };
    
    console.log('Perfect function:', calculateConfidence(perfect));
    console.log('Unclear function:', calculateConfidence(unclear));
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/confidence.js exists
    - Implements deduction-based formula starting at 100%
    - Applies all 5 deduction rules correctly
    - Minimum confidence is 30%
    - Returns confidence, deductions, and reasons
  </verify>
  <done>
    Confidence calculator with deduction-based formula (start 100%, min 30%) implemented
  </done>
</task>

## Verification

After completing all tasks:

```bash
# Verify all advanced utilities exist
ls -la bin/lib/analysis/

# Should now have 6 modules total:
# - ast-parser.js (from Plan 01a)
# - complexity.js (from Plan 01a)
# - side-effects.js (NEW)
# - classifier.js (NEW)
# - confidence.js (NEW)
# - relationships.js (NEW)

# Test integration of all utilities
node -e "
const { extractFunctions } = require('./bin/lib/analysis/ast-parser.js');
const { calculateComplexity } = require('./bin/lib/analysis/complexity.js');
const { detectIOSideEffects } = require('./bin/lib/analysis/side-effects.js');
const { classifyFunction, isHelperFunction } = require('./bin/lib/analysis/classifier.js');
const { extractDependencies } = require('./bin/lib/analysis/relationships.js');
const { calculateConfidence } = require('./bin/lib/analysis/confidence.js');

console.log('✓ All 6 analysis utilities loaded successfully');
console.log('✓ Advanced utilities integrated with foundation');
"
```

## Success Criteria

- [x] Side effects detector finds I/O operations only
- [x] Classifier implements 3-heuristic helper detection (2+ matches = helper)
- [x] Confidence calculator uses deduction formula (start 100%, min 30%)
- [x] Relationships tracker limits to direct calls only (Stage 1)
- [x] All utilities integrate with foundation from Plan 01a
- [x] All utilities tested and verified working

## Output

**Complete analysis infrastructure:**
```
bin/lib/analysis/
├── ast-parser.js      # Question 5: @babel/parser + acorn fallback
├── complexity.js      # Question 1: hardcoded thresholds
├── side-effects.js    # I/O detection (NEW)
├── classifier.js      # Question 2: 3-heuristic helper detection (NEW)
├── confidence.js      # Question 3: deduction formula (NEW)
└── relationships.js   # Question 4: direct calls only (NEW)
```

**All 5 research questions resolved and implemented:**
1. ✅ Complexity thresholds: Simple < 5, Moderate 5-9, Complex >= 10 (configurable constants)
2. ✅ Helper detection: 3-heuristic algorithm (scope + naming + usage), 2+ = helper
3. ✅ Confidence calculation: Deduction formula (-20%, -10%, -5%, -15%, -10%), min 30%
4. ✅ Call site analysis: Direct calls only (one level), transitive deferred to Stage 2
5. ✅ Parser choice: @babel/parser primary, acorn fallback, graceful error handling

**Next:** Plan 02 will use this infrastructure to analyze all functions and generate documentation.
