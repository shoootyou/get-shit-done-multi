---
phase: 05.2-function-level-inventory-bin
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - bin/lib/analysis/ast-parser.js
  - bin/lib/analysis/complexity.js
  - bin/lib/analysis/side-effects.js
  - bin/lib/analysis/classifier.js
  - bin/lib/analysis/relationships.js
  - eval/stage_1/.gitkeep
autonomous: true
must_haves:
  - "@babel/parser installed and available in package.json"
  - "eval/stage_1/ directory exists and is ready for analysis documents"
  - "bin/lib/analysis/ directory contains 5 utility modules"
  - "AST parser extracts all function types (declaration, expression, arrow)"
  - "Complexity calculator implements McCabe's cyclomatic algorithm correctly"
  - "Side effects detector finds all I/O operations (fs, console, network)"
  - "All utilities are tested and verified working"
---

# Phase 05.2 Plan 01: Analysis Infrastructure Setup

## Objective

Build the foundational analysis infrastructure for function-level inventory: install AST parser, create analysis utilities for function extraction, complexity calculation, side effects detection, and function classification.

## Context

Phase 5.2 is the first stage of a comprehensive function-level audit of `bin/**`. We need to analyze every function individually with adaptive depth (complex functions get deep analysis, simple functions get lighter treatment). This requires custom AST-based analysis tools since existing complexity libraries (escomplex, typhonjs-escomplex) are outdated or abandoned.

**Key requirements from CONTEXT.md:**
- Per-function analysis (not file-by-file)
- Complexity metrics: cyclomatic complexity, nesting depth, parameter count
- I/O side effects only (file system, console, network)
- Helper functions documented within parent context
- Smart batching based on complexity thresholds

**Technology from RESEARCH.md:**
- @babel/parser for AST parsing (most complete ES feature support)
- Manual complexity calculation following McCabe's algorithm
- Already have: prompts (v2.4.2), gray-matter (v4.0.3), fs-extra (v11.3.3)

This plan creates the infrastructure. Plan 02 will use it to analyze all functions with user confirmations.

## Tasks

<task name="install-babel-parser" type="auto">
  <files>package.json</files>
  <action>
    Install @babel/parser as dev dependency for AST parsing:
    
    ```bash
    npm install --save-dev @babel/parser
    ```
    
    Verify installation:
    ```bash
    npm list @babel/parser
    ```
  </action>
  <verify>
    - package.json includes "@babel/parser" in devDependencies
    - npm list shows @babel/parser installed successfully
  </verify>
  <done>
    @babel/parser is installed and ready for use in analysis utilities
  </done>
</task>

<task name="create-directory-structure" type="auto">
  <files>bin/lib/analysis/, eval/stage_1/</files>
  <action>
    Create directory structure for analysis infrastructure and output:
    
    ```bash
    mkdir -p bin/lib/analysis
    mkdir -p eval/stage_1
    touch eval/stage_1/.gitkeep
    ```
    
    Verify structure:
    ```bash
    ls -la bin/lib/analysis/
    ls -la eval/stage_1/
    ```
  </action>
  <verify>
    - bin/lib/analysis/ directory exists
    - eval/stage_1/ directory exists with .gitkeep
  </verify>
  <done>
    Directory structure created and ready for analysis utilities and output documents
  </done>
</task>

<task name="build-ast-parser-utility" type="auto">
  <files>bin/lib/analysis/ast-parser.js</files>
  <action>
    Create AST parser utility that extracts all functions from a JavaScript file.
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/ast-parser.js
    const parser = require('@babel/parser');
    const fs = require('fs');
    
    /**
     * Parse a JavaScript file and extract all functions
     * @param {string} filePath - Path to JavaScript file
     * @returns {Array} Array of function objects with metadata
     */
    function extractFunctions(filePath) {
      const code = fs.readFileSync(filePath, 'utf8');
      
      // Try different source types for compatibility
      let ast;
      const parseOptions = [
        { sourceType: 'module' },       // ES modules
        { sourceType: 'script' },       // CommonJS
        { sourceType: 'unambiguous' }   // Auto-detect
      ];
      
      for (const options of parseOptions) {
        try {
          ast = parser.parse(code, {
            ...options,
            plugins: ['jsx'],
            errorRecovery: true
          });
          break;
        } catch (err) {
          continue;
        }
      }
      
      if (!ast) {
        throw new Error(`Failed to parse ${filePath}`);
      }
      
      const functions = [];
      
      function visit(node, parent = null, depth = 0) {
        let functionInfo = null;
        
        // Handle different function types
        if (node.type === 'FunctionDeclaration') {
          functionInfo = {
            name: node.id?.name || `anonymous_function_${node.loc.start.line}`,
            type: 'declaration',
            params: node.params,
            body: node.body,
            loc: node.loc,
            isExported: parent?.type === 'ExportNamedDeclaration' || parent?.type === 'ExportDefaultDeclaration',
            depth: depth
          };
        } else if (node.type === 'FunctionExpression') {
          const name = node.id?.name || (parent?.type === 'VariableDeclarator' ? parent.id.name : `anonymous_${node.loc.start.line}`);
          functionInfo = {
            name,
            type: 'expression',
            params: node.params,
            body: node.body,
            loc: node.loc,
            isExported: false,
            depth: depth
          };
        } else if (node.type === 'ArrowFunctionExpression') {
          const name = parent?.type === 'VariableDeclarator' ? parent.id.name : `arrow_${node.loc.start.line}`;
          functionInfo = {
            name,
            type: 'arrow',
            params: node.params,
            body: node.body,
            loc: node.loc,
            isExported: false,
            depth: depth
          };
        }
        
        if (functionInfo) {
          functions.push(functionInfo);
          // Don't increase depth for nested functions - we want nesting within the function body
        }
        
        // Recursive traversal
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object') {
                  visit(child, node, depth);
                }
              });
            } else if (node[key].type) {
              visit(node[key], node, depth);
            }
          }
        }
      }
      
      visit(ast, null, 0);
      
      return functions;
    }
    
    module.exports = {
      extractFunctions
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const { extractFunctions } = require('./bin/lib/analysis/ast-parser.js');
    const funcs = extractFunctions('./bin/install.js');
    console.log('Extracted', funcs.length, 'functions from install.js');
    console.log('First function:', funcs[0]?.name);
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/ast-parser.js exists and exports extractFunctions
    - Test successfully extracts functions from install.js
    - Handles FunctionDeclaration, FunctionExpression, ArrowFunctionExpression
    - Returns array with name, type, params, body, loc metadata
  </verify>
  <done>
    AST parser utility is working and can extract all function types from any JavaScript file
  </done>
</task>

<task name="build-complexity-calculator" type="auto">
  <files>bin/lib/analysis/complexity.js</files>
  <action>
    Create complexity calculator implementing McCabe's cyclomatic complexity algorithm.
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/complexity.js
    
    /**
     * Calculate complexity metrics for a function node
     * Uses McCabe's cyclomatic complexity algorithm
     * @param {Object} functionNode - AST node for the function
     * @returns {Object} Complexity metrics
     */
    function calculateComplexity(functionNode) {
      let cyclomaticComplexity = 1; // Base complexity
      let maxNestingDepth = 0;
      let currentDepth = 0;
      
      function visit(node) {
        // Track nesting depth
        const depthIncreasingNodes = [
          'IfStatement',
          'ForStatement',
          'ForInStatement',
          'ForOfStatement',
          'WhileStatement',
          'DoWhileStatement',
          'SwitchStatement',
          'TryStatement'
        ];
        
        if (depthIncreasingNodes.includes(node.type)) {
          currentDepth++;
          maxNestingDepth = Math.max(maxNestingDepth, currentDepth);
        }
        
        // Count decision points (McCabe's algorithm)
        switch (node.type) {
          case 'IfStatement':
          case 'ConditionalExpression': // Ternary operator
          case 'ForStatement':
          case 'ForInStatement':
          case 'ForOfStatement':
          case 'WhileStatement':
          case 'DoWhileStatement':
            cyclomaticComplexity++;
            break;
          case 'SwitchCase':
            // Each case adds complexity (not default)
            if (node.test) {
              cyclomaticComplexity++;
            }
            break;
          case 'CatchClause':
            cyclomaticComplexity++;
            break;
          case 'LogicalExpression':
            // && and || add complexity
            if (node.operator === '&&' || node.operator === '||') {
              cyclomaticComplexity++;
            }
            break;
        }
        
        // Recursive traversal
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child);
                }
              });
            } else if (node[key].type) {
              visit(node[key]);
            }
          }
        }
        
        // Decrease depth when leaving nesting node
        if (depthIncreasingNodes.includes(node.type)) {
          currentDepth--;
        }
      }
      
      visit(functionNode.body);
      
      return {
        cyclomatic: cyclomaticComplexity,
        nesting_depth: maxNestingDepth,
        parameter_count: functionNode.params.length
      };
    }
    
    /**
     * Classify complexity level
     * @param {number} cyclomatic - Cyclomatic complexity score
     * @returns {string} Classification (Simple/Moderate/Complex)
     */
    function classifyComplexity(cyclomatic) {
      if (cyclomatic < 5) return 'Simple';
      if (cyclomatic < 10) return 'Moderate';
      return 'Complex';
    }
    
    module.exports = {
      calculateComplexity,
      classifyComplexity
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const parser = require('@babel/parser');
    const { calculateComplexity, classifyComplexity } = require('./bin/lib/analysis/complexity.js');
    
    // Test with a simple function
    const code = 'function test(a, b) { if (a > b) { return a; } else { return b; } }';
    const ast = parser.parse(code);
    const funcNode = ast.program.body[0];
    const metrics = calculateComplexity(funcNode);
    console.log('Complexity:', metrics);
    console.log('Classification:', classifyComplexity(metrics.cyclomatic));
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/complexity.js exists and exports calculateComplexity, classifyComplexity
    - Test successfully calculates complexity for a simple if/else function
    - Returns cyclomatic, nesting_depth, parameter_count
    - Classification works (Simple < 5, Moderate 5-9, Complex >= 10)
  </verify>
  <done>
    Complexity calculator implements McCabe's algorithm correctly and can classify functions by complexity level
  </done>
</task>

<task name="build-side-effects-detector" type="auto">
  <files>bin/lib/analysis/side-effects.js</files>
  <action>
    Create side effects detector that identifies I/O operations (per CONTEXT.md: I/O only, not state mutations).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/side-effects.js
    
    /**
     * Detect I/O side effects in a function
     * Per Phase 5.2 requirements: I/O operations only
     * (file system, console, network - NOT state mutations)
     * @param {Object} functionNode - AST node for the function
     * @returns {Array} Array of side effect objects
     */
    function detectIOSideEffects(functionNode) {
      const sideEffects = [];
      
      function visit(node) {
        // Check for member expressions: fs.readFile, console.log, etc.
        if (node.type === 'MemberExpression' && node.object?.name && node.property) {
          const object = node.object.name;
          const property = node.property.name || node.property.value;
          
          // File system operations
          if (object === 'fs' || object === 'fse' || object === 'fsExtra') {
            sideEffects.push({
              type: 'file_system',
              operation: `${object}.${property}`,
              line: node.loc?.start.line
            });
          }
          
          // Console operations
          if (object === 'console') {
            sideEffects.push({
              type: 'console',
              operation: `console.${property}`,
              line: node.loc?.start.line
            });
          }
          
          // Process I/O (stdout/stderr only, not env/exit per CONTEXT)
          if (object === 'process' && (property === 'stdout' || property === 'stderr')) {
            sideEffects.push({
              type: 'process_io',
              operation: `process.${property}`,
              line: node.loc?.start.line
            });
          }
        }
        
        // Check for require() calls to network modules
        if (node.type === 'CallExpression' && node.callee?.name === 'require') {
          const arg = node.arguments?.[0];
          if (arg?.value) {
            const networkModules = ['http', 'https', 'net', 'node-fetch', 'axios', 'request'];
            if (networkModules.includes(arg.value)) {
              sideEffects.push({
                type: 'network_import',
                operation: `require('${arg.value}')`,
                line: node.loc?.start.line
              });
            }
          }
        }
        
        // Recursive traversal
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child);
                }
              });
            } else if (node[key].type) {
              visit(node[key]);
            }
          }
        }
      }
      
      visit(functionNode.body);
      
      return sideEffects;
    }
    
    module.exports = {
      detectIOSideEffects
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const parser = require('@babel/parser');
    const { detectIOSideEffects } = require('./bin/lib/analysis/side-effects.js');
    
    const code = \`function test() {
      console.log('hello');
      const data = fs.readFileSync('file.txt');
      return data;
    }\`;
    
    const ast = parser.parse(code);
    const funcNode = ast.program.body[0];
    const effects = detectIOSideEffects(funcNode);
    console.log('Side effects:', effects);
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/side-effects.js exists and exports detectIOSideEffects
    - Test successfully detects console.log and fs.readFileSync
    - Returns array with type, operation, line number
    - Detects file_system, console, process_io, network_import types
  </verify>
  <done>
    Side effects detector can find all I/O operations in function bodies
  </done>
</task>

<task name="build-classifier-and-relationships" type="auto">
  <files>bin/lib/analysis/classifier.js, bin/lib/analysis/relationships.js</files>
  <action>
    Create function classifier and relationship tracker utilities.
    
    **Classifier implementation:**
    ```javascript
    // bin/lib/analysis/classifier.js
    
    /**
     * Classify a function based on its characteristics
     * Used for smart batching: simple functions batched, complex reviewed individually
     * @param {Object} functionInfo - Function metadata with complexity
     * @returns {string} Classification (simple/moderate/complex)
     */
    function classifyFunction(functionInfo) {
      const { complexity } = functionInfo;
      
      // Per CONTEXT.md and RESEARCH.md:
      // Simple: < 5, Moderate: 5-9, Complex: >= 10
      if (complexity.cyclomatic < 5) {
        return 'simple';
      } else if (complexity.cyclomatic < 10) {
        return 'moderate';
      } else {
        return 'complex';
      }
    }
    
    /**
     * Determine if function is a helper (internal, not exported)
     * Per CONTEXT.md: helpers documented within parent, not separately
     * @param {Object} functionInfo - Function metadata
     * @returns {boolean} True if helper function
     */
    function isHelperFunction(functionInfo) {
      // Heuristics per RESEARCH.md:
      // - Not exported
      // - Name starts with underscore or is lowercase
      // - Defined inside another function (depth > 0)
      
      if (functionInfo.isExported) {
        return false;
      }
      
      if (functionInfo.depth > 0) {
        return true; // Nested function = helper
      }
      
      const name = functionInfo.name;
      if (name.startsWith('_') || name.startsWith('anonymous')) {
        return true;
      }
      
      return false;
    }
    
    module.exports = {
      classifyFunction,
      isHelperFunction
    };
    ```
    
    **Relationships tracker:**
    ```javascript
    // bin/lib/analysis/relationships.js
    
    /**
     * Extract function dependencies (calls to other functions)
     * Per CONTEXT.md: Stage 1 is direct calls only (one level)
     * @param {Object} functionNode - AST node for the function
     * @returns {Array} Array of function names called
     */
    function extractDependencies(functionNode) {
      const dependencies = [];
      
      function visit(node) {
        // Direct function calls
        if (node.type === 'CallExpression') {
          if (node.callee?.type === 'Identifier') {
            dependencies.push(node.callee.name);
          } else if (node.callee?.type === 'MemberExpression') {
            // method.call() - track the method name
            const method = node.callee.property?.name;
            if (method) {
              dependencies.push(method);
            }
          }
        }
        
        // Recursive traversal
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child);
                }
              });
            } else if (node[key].type) {
              visit(node[key]);
            }
          }
        }
      }
      
      visit(functionNode.body);
      
      // Deduplicate
      return [...new Set(dependencies)];
    }
    
    /**
     * Build reverse dependency map (called_by)
     * @param {Array} allFunctions - All analyzed functions
     * @returns {Map} Map of function name -> array of callers
     */
    function buildCalledByMap(allFunctions) {
      const calledByMap = new Map();
      
      // Initialize map
      allFunctions.forEach(fn => {
        calledByMap.set(fn.name, []);
      });
      
      // Build reverse dependencies
      allFunctions.forEach(fn => {
        fn.dependencies.forEach(depName => {
          if (calledByMap.has(depName)) {
            calledByMap.get(depName).push(fn.name);
          }
        });
      });
      
      return calledByMap;
    }
    
    module.exports = {
      extractDependencies,
      buildCalledByMap
    };
    ```
    
    **Test both utilities:**
    ```bash
    node -e "
    const { classifyFunction, isHelperFunction } = require('./bin/lib/analysis/classifier.js');
    
    const simple = { complexity: { cyclomatic: 3 }, isExported: true };
    const complex = { complexity: { cyclomatic: 12 }, isExported: true };
    const helper = { name: '_helper', isExported: false, depth: 1 };
    
    console.log('Simple classification:', classifyFunction(simple));
    console.log('Complex classification:', classifyFunction(complex));
    console.log('Is helper?', isHelperFunction(helper));
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/classifier.js exists and exports classifyFunction, isHelperFunction
    - bin/lib/analysis/relationships.js exists and exports extractDependencies, buildCalledByMap
    - Test shows correct classifications (simple/moderate/complex)
    - Helper detection works for non-exported and nested functions
  </verify>
  <done>
    Function classifier and relationship tracker are working and ready to support analysis workflow
  </done>
</task>

## Verification

After completing all tasks:

```bash
# Verify all utilities exist
ls -la bin/lib/analysis/

# Should show:
# - ast-parser.js
# - complexity.js
# - side-effects.js
# - classifier.js
# - relationships.js

# Verify package.json
grep "@babel/parser" package.json

# Verify output directory
ls -la eval/stage_1/

# Test integration of all utilities
node -e "
const { extractFunctions } = require('./bin/lib/analysis/ast-parser.js');
const { calculateComplexity } = require('./bin/lib/analysis/complexity.js');
const { detectIOSideEffects } = require('./bin/lib/analysis/side-effects.js');
const { classifyFunction } = require('./bin/lib/analysis/classifier.js');

console.log('âœ“ All analysis utilities loaded successfully');
"
```

## Success Criteria

- [x] @babel/parser installed in package.json devDependencies
- [x] eval/stage_1/ directory created and ready
- [x] bin/lib/analysis/ directory contains 5 utility modules
- [x] AST parser can extract all function types (declaration, expression, arrow)
- [x] Complexity calculator implements McCabe's algorithm with correct decision point counting
- [x] Side effects detector finds I/O operations (fs, console, network)
- [x] Classifier can categorize functions as simple/moderate/complex
- [x] Relationship tracker can extract function dependencies
- [x] All utilities tested and working independently

## Output

Infrastructure ready for Phase 05.2 Plan 02 to analyze all functions in `bin/**` with user confirmations.

**Files created:**
- bin/lib/analysis/ast-parser.js
- bin/lib/analysis/complexity.js
- bin/lib/analysis/side-effects.js
- bin/lib/analysis/classifier.js
- bin/lib/analysis/relationships.js
- eval/stage_1/.gitkeep

**Dependencies added:**
- @babel/parser (dev)

**Next:** Plan 02 will build the main analyzer script, run analysis on all bin/** files, and conduct interactive user confirmations with progressive disclosure.
