---
phase: 05.2-function-level-inventory-bin
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - bin/lib/analysis/ast-parser.js
  - bin/lib/analysis/complexity.js
  - bin/lib/analysis/side-effects.js
  - bin/lib/analysis/classifier.js
  - bin/lib/analysis/relationships.js
  - bin/lib/analysis/confidence.js
  - eval/stage_1/.gitkeep
autonomous: true
must_haves:
  - "@babel/parser installed with acorn as fallback dependency"
  - "eval/stage_1/ directory exists and ready for analysis documents"
  - "bin/lib/analysis/ contains 6 utility modules (parser, complexity, side-effects, classifier, relationships, confidence)"
  - "AST parser uses @babel/parser primary, acorn fallback, graceful error handling"
  - "Complexity calculator hardcodes thresholds: Simple < 5, Moderate 5-9, Complex >= 10"
  - "Helper detector implements 3-heuristic algorithm (scope + naming + usage)"
  - "Confidence calculator uses deduction formula starting at 100%"
  - "All utilities tested and verified working"
---

# Phase 05.2 Plan 01: Analysis Infrastructure Setup

## Objective

Build the foundational analysis infrastructure with resolved research questions baked in: install parsers (@babel/parser + acorn fallback), create analysis utilities with hardcoded thresholds (Simple < 5, Complex >= 10), implement 3-heuristic helper detection, build deduction-based confidence calculator, and limit call site analysis to direct dependencies only.

## Context

Phase 5.2 Stage 1 requires comprehensive function-level inventory of `bin/**` with adaptive depth analysis. Research identified 5 open questions that are now resolved and must be implemented as concrete code:

**Resolved Question 1 - Complexity Thresholds:**
- Simple: cyclomatic < 5
- Moderate: cyclomatic 5-9  
- Complex: cyclomatic >= 10
- **Implementation**: Hardcode as constants for now, make configurable later

**Resolved Question 2 - Helper Detection:**
- Use ALL THREE heuristics:
  1. Scope: not exported (not in module.exports or export statement)
  2. Naming: follows helper patterns (_helper, internal*, private*, etc.)
  3. Usage: called by only one parent function
- **Implementation**: If 2+ heuristics match → classify as helper

**Resolved Question 3 - Confidence Calculation:**
- Start at 100%, apply deductions:
  - Dynamic requires/imports: -20%
  - Unclear/generic naming: -10%
  - No JSDoc comments: -5%
  - Complex control flow without docs: -15%
  - External deps without clear purpose: -10%
- **Implementation**: Minimum confidence 30%

**Resolved Question 4 - Call Site Analysis:**
- Stage 1: Direct calls only (one level deep)
- **Implementation**: Record call sites but don't traverse beyond immediate dependencies

**Resolved Question 5 - Parser Choice:**
- Primary: @babel/parser (most complete ES feature support)
- Fallback: acorn (if @babel/parser fails)
- **Implementation**: Try @babel/parser first, catch errors, try acorn, handle gracefully

This plan creates all infrastructure modules with these decisions baked in as concrete implementation.

## Tasks

<task name="install-parsers" type="auto">
  <files>package.json</files>
  <action>
    Install BOTH @babel/parser (primary) and acorn (fallback) as dev dependencies:
    
    ```bash
    npm install --save-dev @babel/parser acorn
    ```
    
    Verify both installed:
    ```bash
    npm list @babel/parser
    npm list acorn
    ```
  </action>
  <verify>
    - package.json includes "@babel/parser" in devDependencies
    - package.json includes "acorn" in devDependencies
    - Both show as installed in npm list
  </verify>
  <done>
    Both parsers installed and ready - @babel/parser as primary, acorn as fallback
  </done>
</task>

<task name="create-directory-structure" type="auto">
  <files>bin/lib/analysis/, eval/stage_1/</files>
  <action>
    Create directory structure for analysis infrastructure and output:
    
    ```bash
    mkdir -p bin/lib/analysis
    mkdir -p eval/stage_1
    touch eval/stage_1/.gitkeep
    ```
    
    Verify structure:
    ```bash
    ls -la bin/lib/analysis/
    ls -la eval/stage_1/
    ```
  </action>
  <verify>
    - bin/lib/analysis/ directory exists
    - eval/stage_1/ directory exists with .gitkeep
  </verify>
  <done>
    Directory structure created and ready for analysis utilities and output documents
  </done>
</task>

<task name="build-ast-parser-with-fallback" type="auto">
  <files>bin/lib/analysis/ast-parser.js</files>
  <action>
    Create AST parser utility implementing resolved Question 5 (primary + fallback strategy).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/ast-parser.js
    const fs = require('fs');

    // Resolved Question 5: @babel/parser primary, acorn fallback
    let babelParser;
    let acorn;
    
    try {
      babelParser = require('@babel/parser');
    } catch (e) {
      console.warn('⚠️  @babel/parser not available');
    }
    
    try {
      acorn = require('acorn');
    } catch (e) {
      console.warn('⚠️  acorn not available');
    }

    /**
     * Parse JavaScript file with fallback strategy
     * Resolved Question 5: Try @babel/parser first, then acorn, handle errors gracefully
     * @param {string} filePath - Path to JavaScript file
     * @returns {Object} AST
     */
    function parseFile(filePath) {
      const code = fs.readFileSync(filePath, 'utf8');
      
      // Try @babel/parser first (most complete)
      if (babelParser) {
        const parseOptions = [
          { sourceType: 'module' },       // ES modules
          { sourceType: 'script' },       // CommonJS
          { sourceType: 'unambiguous' }   // Auto-detect
        ];
        
        for (const options of parseOptions) {
          try {
            return babelParser.parse(code, {
              ...options,
              plugins: ['jsx'],  // Support JSX
              errorRecovery: true,  // Continue on errors
              ecmaVersion: 'latest'  // Latest ES features
            });
          } catch (err) {
            continue;  // Try next option
          }
        }
      }
      
      // Fallback to acorn
      if (acorn) {
        try {
          return acorn.parse(code, {
            ecmaVersion: 'latest',
            sourceType: 'module',
            locations: true  // Include loc info
          });
        } catch (err) {
          // Try as script
          try {
            return acorn.parse(code, {
              ecmaVersion: 'latest',
              sourceType: 'script',
              locations: true
            });
          } catch (err2) {
            throw new Error(`Failed to parse ${filePath} with both parsers: ${err2.message}`);
          }
        }
      }
      
      throw new Error(`No parser available for ${filePath}`);
    }

    /**
     * Extract all functions from a JavaScript file
     * @param {string} filePath - Path to JavaScript file
     * @returns {Array} Array of function objects with metadata
     */
    function extractFunctions(filePath) {
      const ast = parseFile(filePath);
      const functions = [];
      
      function visit(node, parent = null, depth = 0) {
        let functionInfo = null;
        
        // Handle different function types
        if (node.type === 'FunctionDeclaration') {
          functionInfo = {
            name: node.id?.name || `anonymous_function_${node.loc.start.line}`,
            type: 'declaration',
            params: node.params,
            body: node.body,
            loc: node.loc,
            isExported: parent?.type === 'ExportNamedDeclaration' || parent?.type === 'ExportDefaultDeclaration',
            depth: depth
          };
        } else if (node.type === 'FunctionExpression') {
          const name = node.id?.name || (parent?.type === 'VariableDeclarator' ? parent.id.name : `anonymous_${node.loc.start.line}`);
          functionInfo = {
            name,
            type: 'expression',
            params: node.params,
            body: node.body,
            loc: node.loc,
            isExported: false,  // Will check module.exports separately
            depth: depth
          };
        } else if (node.type === 'ArrowFunctionExpression') {
          const name = parent?.type === 'VariableDeclarator' ? parent.id.name : `arrow_${node.loc.start.line}`;
          functionInfo = {
            name,
            type: 'arrow',
            params: node.params,
            body: node.body,
            loc: node.loc,
            isExported: false,
            depth: depth
          };
        }
        
        if (functionInfo) {
          functions.push(functionInfo);
        }
        
        // Recursive traversal
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child, node, depth);
                }
              });
            } else if (node[key].type) {
              visit(node[key], node, depth);
            }
          }
        }
      }
      
      visit(ast, null, 0);
      return functions;
    }

    module.exports = {
      parseFile,
      extractFunctions
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const { extractFunctions } = require('./bin/lib/analysis/ast-parser.js');
    const funcs = extractFunctions('./bin/install.js');
    console.log('✓ Extracted', funcs.length, 'functions from install.js');
    console.log('  First function:', funcs[0]?.name);
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/ast-parser.js exists
    - Exports parseFile and extractFunctions
    - Test successfully parses install.js with either parser
    - Handles FunctionDeclaration, FunctionExpression, ArrowFunctionExpression
    - Fallback strategy works (try @babel/parser, then acorn)
  </verify>
  <done>
    AST parser with primary/fallback strategy implemented and tested
  </done>
</task>

<task name="build-complexity-calculator-with-thresholds" type="auto">
  <files>bin/lib/analysis/complexity.js</files>
  <action>
    Create complexity calculator implementing resolved Question 1 (hardcoded thresholds).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/complexity.js

    // Resolved Question 1: Hardcoded complexity thresholds (configurable via constants)
    const COMPLEXITY_THRESHOLDS = {
      SIMPLE: 5,      // cyclomatic < 5
      MODERATE: 10    // cyclomatic < 10
      // Complex is >= 10
    };

    /**
     * Calculate complexity metrics for a function node
     * Uses McCabe's cyclomatic complexity algorithm
     * @param {Object} functionNode - AST node for the function
     * @returns {Object} Complexity metrics
     */
    function calculateComplexity(functionNode) {
      let cyclomaticComplexity = 1; // Base complexity
      let maxNestingDepth = 0;
      let currentDepth = 0;
      
      function visit(node) {
        // Track nesting depth
        const depthIncreasingNodes = [
          'IfStatement',
          'ForStatement',
          'ForInStatement',
          'ForOfStatement',
          'WhileStatement',
          'DoWhileStatement',
          'SwitchStatement',
          'TryStatement'
        ];
        
        if (depthIncreasingNodes.includes(node.type)) {
          currentDepth++;
          maxNestingDepth = Math.max(maxNestingDepth, currentDepth);
        }
        
        // Count decision points (McCabe's algorithm)
        switch (node.type) {
          case 'IfStatement':
          case 'ConditionalExpression': // Ternary operator
          case 'ForStatement':
          case 'ForInStatement':
          case 'ForOfStatement':
          case 'WhileStatement':
          case 'DoWhileStatement':
            cyclomaticComplexity++;
            break;
          case 'SwitchCase':
            // Each case adds complexity (not default)
            if (node.test) {
              cyclomaticComplexity++;
            }
            break;
          case 'CatchClause':
            cyclomaticComplexity++;
            break;
          case 'LogicalExpression':
            // && and || add complexity
            if (node.operator === '&&' || node.operator === '||') {
              cyclomaticComplexity++;
            }
            break;
        }
        
        // Recursive traversal
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child);
                }
              });
            } else if (node[key].type) {
              visit(node[key]);
            }
          }
        }
        
        // Decrease depth when leaving nesting node
        if (depthIncreasingNodes.includes(node.type)) {
          currentDepth--;
        }
      }
      
      visit(functionNode.body);
      
      return {
        cyclomatic: cyclomaticComplexity,
        nesting_depth: maxNestingDepth,
        parameter_count: functionNode.params.length
      };
    }

    /**
     * Classify complexity level using hardcoded thresholds
     * Resolved Question 1: Simple < 5, Moderate 5-9, Complex >= 10
     * @param {number} cyclomatic - Cyclomatic complexity score
     * @returns {string} Classification (Simple/Moderate/Complex)
     */
    function classifyComplexity(cyclomatic) {
      if (cyclomatic < COMPLEXITY_THRESHOLDS.SIMPLE) return 'Simple';
      if (cyclomatic < COMPLEXITY_THRESHOLDS.MODERATE) return 'Moderate';
      return 'Complex';
    }

    /**
     * Get complexity thresholds for external use
     * @returns {Object} Threshold constants
     */
    function getThresholds() {
      return { ...COMPLEXITY_THRESHOLDS };
    }

    module.exports = {
      calculateComplexity,
      classifyComplexity,
      getThresholds,
      COMPLEXITY_THRESHOLDS  // Export for testing
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const { COMPLEXITY_THRESHOLDS, classifyComplexity } = require('./bin/lib/analysis/complexity.js');
    console.log('✓ Thresholds:', COMPLEXITY_THRESHOLDS);
    console.log('  Complexity 3:', classifyComplexity(3));
    console.log('  Complexity 7:', classifyComplexity(7));
    console.log('  Complexity 12:', classifyComplexity(12));
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/complexity.js exists
    - COMPLEXITY_THRESHOLDS constant defined (SIMPLE: 5, MODERATE: 10)
    - classifyComplexity uses hardcoded thresholds correctly
    - Test shows: 3=Simple, 7=Moderate, 12=Complex
  </verify>
  <done>
    Complexity calculator with hardcoded thresholds (Simple < 5, Complex >= 10) implemented
  </done>
</task>

<task name="build-side-effects-detector" type="auto">
  <files>bin/lib/analysis/side-effects.js</files>
  <action>
    Create side effects detector (I/O operations only per CONTEXT.md).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/side-effects.js

    /**
     * Detect I/O side effects in a function
     * Per CONTEXT.md: I/O operations only (file system, console, network)
     * NOT state mutations
     * @param {Object} functionNode - AST node for the function
     * @returns {Array} Array of side effect objects
     */
    function detectIOSideEffects(functionNode) {
      const sideEffects = [];
      
      function visit(node) {
        // Check for member expressions: fs.readFile, console.log, etc.
        if (node.type === 'MemberExpression' && node.object?.name && node.property) {
          const object = node.object.name;
          const property = node.property.name || node.property.value;
          
          // File system operations
          if (object === 'fs' || object === 'fse' || object === 'fsExtra') {
            sideEffects.push({
              type: 'file_system',
              operation: `${object}.${property}`,
              line: node.loc?.start.line
            });
          }
          
          // Console operations
          if (object === 'console') {
            sideEffects.push({
              type: 'console',
              operation: `console.${property}`,
              line: node.loc?.start.line
            });
          }
          
          // Process I/O (stdout/stderr only)
          if (object === 'process' && (property === 'stdout' || property === 'stderr')) {
            sideEffects.push({
              type: 'process_io',
              operation: `process.${property}`,
              line: node.loc?.start.line
            });
          }
        }
        
        // Check for require() calls to network modules
        if (node.type === 'CallExpression' && node.callee?.name === 'require') {
          const arg = node.arguments?.[0];
          if (arg?.value) {
            const networkModules = ['http', 'https', 'net', 'node-fetch', 'axios', 'request'];
            if (networkModules.includes(arg.value)) {
              sideEffects.push({
                type: 'network_import',
                operation: `require('${arg.value}')`,
                line: node.loc?.start.line
              });
            }
          }
        }
        
        // Recursive traversal
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child);
                }
              });
            } else if (node[key].type) {
              visit(node[key]);
            }
          }
        }
      }
      
      visit(functionNode.body);
      return sideEffects;
    }

    module.exports = {
      detectIOSideEffects
    };
    ```
  </action>
  <verify>
    - bin/lib/analysis/side-effects.js exists
    - Detects file_system, console, process_io, network_import
    - Only I/O operations (not state mutations)
  </verify>
  <done>
    Side effects detector finds I/O operations only (per requirements)
  </done>
</task>

<task name="build-classifier-with-3-heuristics" type="auto">
  <files>bin/lib/analysis/classifier.js</files>
  <action>
    Create function classifier implementing resolved Question 2 (3-heuristic helper detection).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/classifier.js

    /**
     * Classify a function based on complexity
     * Used for smart batching
     * @param {Object} functionInfo - Function metadata with complexity
     * @returns {string} Classification (simple/moderate/complex)
     */
    function classifyFunction(functionInfo) {
      const { complexity } = functionInfo;
      
      // Use thresholds from complexity module
      if (complexity.cyclomatic < 5) {
        return 'simple';
      } else if (complexity.cyclomatic < 10) {
        return 'moderate';
      } else {
        return 'complex';
      }
    }

    /**
     * Determine if function is a helper using 3-heuristic algorithm
     * Resolved Question 2: Use ALL THREE heuristics, 2+ matches = helper
     * 
     * Heuristics:
     * 1. Scope: function is not exported
     * 2. Naming: follows helper naming patterns (_*, internal*, private*, anonymous*)
     * 3. Usage: called by only one parent function (single caller)
     * 
     * @param {Object} functionInfo - Function metadata
     * @param {Array} allFunctions - All functions for usage analysis
     * @returns {Object} { isHelper: boolean, matchedHeuristics: number, heuristics: [] }
     */
    function isHelperFunction(functionInfo, allFunctions = []) {
      const heuristics = [];
      
      // Heuristic 1: Scope (not exported)
      if (!functionInfo.isExported) {
        heuristics.push('scope');
      }
      
      // Heuristic 2: Naming patterns
      const name = functionInfo.name;
      const helperPatterns = [
        /^_/,            // Starts with underscore
        /^internal/i,    // Starts with internal
        /^private/i,     // Starts with private
        /^anonymous/,    // Anonymous function
        /^arrow_/,       // Arrow function
        /helper$/i,      // Ends with helper
        /util$/i         // Ends with util
      ];
      
      if (helperPatterns.some(pattern => pattern.test(name))) {
        heuristics.push('naming');
      }
      
      // Heuristic 3: Usage (single caller)
      // Only applicable if we have calledBy information
      if (functionInfo.calledBy && functionInfo.calledBy.length === 1) {
        heuristics.push('usage');
      } else if (functionInfo.depth > 0) {
        // Nested function (defined inside another) = definitely helper
        heuristics.push('usage');
      }
      
      // Resolved Question 2: If 2+ heuristics match → classify as helper
      const matchedCount = heuristics.length;
      const isHelper = matchedCount >= 2;
      
      return {
        isHelper,
        matchedHeuristics: matchedCount,
        heuristics
      };
    }

    module.exports = {
      classifyFunction,
      isHelperFunction
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const { isHelperFunction } = require('./bin/lib/analysis/classifier.js');
    
    const helper1 = { name: '_internal', isExported: false, depth: 0, calledBy: ['parent'] };
    const helper2 = { name: 'anonymous_123', isExported: false, depth: 1 };
    const exported = { name: 'publicFunc', isExported: true, depth: 0, calledBy: [] };
    
    console.log('Helper 1:', isHelperFunction(helper1));
    console.log('Helper 2:', isHelperFunction(helper2));
    console.log('Exported:', isHelperFunction(exported));
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/classifier.js exists
    - isHelperFunction implements 3-heuristic algorithm
    - Returns object with isHelper, matchedHeuristics, heuristics array
    - Test shows 2+ heuristics = helper
  </verify>
  <done>
    Function classifier with 3-heuristic helper detection (2+ matches = helper) implemented
  </done>
</task>

<task name="build-confidence-calculator" type="auto">
  <files>bin/lib/analysis/confidence.js</files>
  <action>
    Create confidence calculator implementing resolved Question 3 (deduction-based formula).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/confidence.js

    /**
     * Calculate confidence percentage for function analysis
     * Resolved Question 3: Start at 100%, apply deductions, minimum 30%
     * 
     * Deductions:
     * - Dynamic requires/imports: -20%
     * - Unclear/generic naming: -10%
     * - No JSDoc comments: -5%
     * - Complex control flow without documentation: -15%
     * - External dependency usage without clear purpose: -10%
     * 
     * @param {Object} functionInfo - Function metadata
     * @param {Object} ast - AST node for checking documentation
     * @returns {Object} { confidence: number, deductions: [], reasons: [] }
     */
    function calculateConfidence(functionInfo, ast = null) {
      let confidence = 100;
      const deductions = [];
      const reasons = [];
      
      // Check for dynamic requires/imports
      if (hasDynamicRequires(functionInfo)) {
        confidence -= 20;
        deductions.push({ amount: 20, reason: 'Dynamic requires/imports detected' });
        reasons.push('Dynamic requires make dependency analysis uncertain');
      }
      
      // Check for unclear/generic naming
      if (hasUnclearNaming(functionInfo.name)) {
        confidence -= 10;
        deductions.push({ amount: 10, reason: 'Unclear or generic function name' });
        reasons.push(`Name "${functionInfo.name}" is generic or unclear`);
      }
      
      // Check for JSDoc comments
      if (!hasJSDoc(functionInfo, ast)) {
        confidence -= 5;
        deductions.push({ amount: 5, reason: 'No JSDoc documentation' });
        reasons.push('Missing JSDoc comments');
      }
      
      // Check for complex control flow without documentation
      if (isComplexWithoutDocs(functionInfo, ast)) {
        confidence -= 15;
        deductions.push({ amount: 15, reason: 'Complex control flow without documentation' });
        reasons.push(`Complexity ${functionInfo.complexity.cyclomatic} but no documentation`);
      }
      
      // Check for unclear external dependencies
      if (hasUnclearDependencies(functionInfo)) {
        confidence -= 10;
        deductions.push({ amount: 10, reason: 'External dependencies without clear purpose' });
        reasons.push('Dependencies used but purpose unclear');
      }
      
      // Minimum confidence: 30%
      confidence = Math.max(confidence, 30);
      
      return {
        confidence,
        deductions,
        reasons
      };
    }

    /**
     * Check for dynamic require() calls
     */
    function hasDynamicRequires(functionInfo) {
      // Check if dependencies include patterns like require(variable)
      if (functionInfo.dependencies) {
        return functionInfo.dependencies.some(dep => 
          dep.includes('require') && !dep.match(/require\(['"][\w/-]+['"]\)/)
        );
      }
      return false;
    }

    /**
     * Check for unclear/generic naming
     */
    function hasUnclearNaming(name) {
      const genericNames = [
        /^temp/i, /^tmp/i, /^test/i, /^foo/i, /^bar/i,
        /^handle/i, /^process/i, /^do/i, /^run/i,
        /^func\d*/i, /^fn\d*/i, /^method\d*/i,
        /^util$/i, /^helper$/i, /^main$/i
      ];
      
      return genericNames.some(pattern => pattern.test(name));
    }

    /**
     * Check for JSDoc comments
     * (Simplified - just check if ast has comments property)
     */
    function hasJSDoc(functionInfo, ast) {
      // If no AST provided, assume no JSDoc
      if (!ast || !ast.leadingComments) {
        return false;
      }
      
      // Check for /** */ style comments
      return ast.leadingComments.some(comment => 
        comment.type === 'CommentBlock' && comment.value.trim().startsWith('*')
      );
    }

    /**
     * Check if complex but undocumented
     */
    function isComplexWithoutDocs(functionInfo, ast) {
      const isComplex = functionInfo.complexity && functionInfo.complexity.cyclomatic >= 10;
      const lacksDoc = !hasJSDoc(functionInfo, ast);
      return isComplex && lacksDoc;
    }

    /**
     * Check for unclear external dependencies
     */
    function hasUnclearDependencies(functionInfo) {
      // If has external deps but no clear documentation, flag it
      if (functionInfo.dependencies && functionInfo.dependencies.length > 3) {
        return !functionInfo.purpose;  // Many deps but no documented purpose
      }
      return false;
    }

    module.exports = {
      calculateConfidence
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const { calculateConfidence } = require('./bin/lib/analysis/confidence.js');
    
    const perfect = { name: 'validateInput', complexity: { cyclomatic: 3 }, dependencies: [] };
    const unclear = { name: 'temp', complexity: { cyclomatic: 12 }, dependencies: ['require(x)'] };
    
    console.log('Perfect function:', calculateConfidence(perfect));
    console.log('Unclear function:', calculateConfidence(unclear));
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/confidence.js exists
    - Implements deduction-based formula starting at 100%
    - Applies all 5 deduction rules correctly
    - Minimum confidence is 30%
    - Returns confidence, deductions, and reasons
  </verify>
  <done>
    Confidence calculator with deduction-based formula (start 100%, min 30%) implemented
  </done>
</task>

<task name="build-relationships-tracker" type="auto">
  <files>bin/lib/analysis/relationships.js</files>
  <action>
    Create relationships tracker implementing resolved Question 4 (direct calls only).
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/relationships.js

    /**
     * Extract function dependencies
     * Resolved Question 4: Stage 1 is DIRECT CALLS ONLY (one level deep)
     * Transitive call analysis deferred to Stage 2
     * @param {Object} functionNode - AST node for the function
     * @returns {Array} Array of function names called directly
     */
    function extractDependencies(functionNode) {
      const dependencies = [];
      
      function visit(node) {
        // Direct function calls only
        if (node.type === 'CallExpression') {
          if (node.callee?.type === 'Identifier') {
            dependencies.push(node.callee.name);
          } else if (node.callee?.type === 'MemberExpression') {
            // method.call() - track the method name
            const method = node.callee.property?.name;
            if (method) {
              dependencies.push(method);
            }
          }
        }
        
        // Recursive traversal (but only record immediate calls, not transitive)
        for (const key in node) {
          if (node[key] && typeof node[key] === 'object') {
            if (Array.isArray(node[key])) {
              node[key].forEach(child => {
                if (child && typeof child === 'object' && child.type) {
                  visit(child);
                }
              });
            } else if (node[key].type) {
              visit(node[key]);
            }
          }
        }
      }
      
      visit(functionNode.body);
      
      // Deduplicate
      return [...new Set(dependencies)];
    }

    /**
     * Build reverse dependency map (called_by)
     * @param {Array} allFunctions - All analyzed functions
     * @returns {Map} Map of function name -> array of callers
     */
    function buildCalledByMap(allFunctions) {
      const calledByMap = new Map();
      
      // Initialize map
      allFunctions.forEach(fn => {
        calledByMap.set(fn.name, []);
      });
      
      // Build reverse dependencies (direct only, per Question 4)
      allFunctions.forEach(fn => {
        if (fn.dependencies) {
          fn.dependencies.forEach(depName => {
            if (calledByMap.has(depName)) {
              calledByMap.get(depName).push(fn.name);
            }
          });
        }
      });
      
      return calledByMap;
    }

    module.exports = {
      extractDependencies,
      buildCalledByMap
    };
    ```
    
    **Test the utility:**
    ```bash
    node -e "
    const { buildCalledByMap } = require('./bin/lib/analysis/relationships.js');
    
    const funcs = [
      { name: 'A', dependencies: ['B', 'C'] },
      { name: 'B', dependencies: [] },
      { name: 'C', dependencies: ['B'] }
    ];
    
    const map = buildCalledByMap(funcs);
    console.log('B called by:', map.get('B'));
    console.log('C called by:', map.get('C'));
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/relationships.js exists
    - extractDependencies records ONLY direct calls (one level)
    - buildCalledByMap creates reverse dependency map
    - Documentation clearly states Stage 1 = direct only, transitive deferred
  </verify>
  <done>
    Relationships tracker limits analysis to direct calls only (Stage 1 constraint)
  </done>
</task>

## Verification

After completing all tasks:

```bash
# Verify all utilities exist
ls -la bin/lib/analysis/

# Should show:
# - ast-parser.js (with @babel/parser + acorn fallback)
# - complexity.js (with hardcoded thresholds)
# - side-effects.js
# - classifier.js (with 3-heuristic helper detection)
# - relationships.js (direct calls only)
# - confidence.js (deduction-based formula)

# Verify parsers installed
npm list @babel/parser
npm list acorn

# Verify output directory
ls -la eval/stage_1/

# Test integration of all utilities
node -e "
const { extractFunctions } = require('./bin/lib/analysis/ast-parser.js');
const { calculateComplexity, COMPLEXITY_THRESHOLDS } = require('./bin/lib/analysis/complexity.js');
const { detectIOSideEffects } = require('./bin/lib/analysis/side-effects.js');
const { classifyFunction, isHelperFunction } = require('./bin/lib/analysis/classifier.js');
const { extractDependencies } = require('./bin/lib/analysis/relationships.js');
const { calculateConfidence } = require('./bin/lib/analysis/confidence.js');

console.log('✓ All 6 analysis utilities loaded successfully');
console.log('✓ Thresholds:', COMPLEXITY_THRESHOLDS);
"
```

## Success Criteria

- [x] @babel/parser AND acorn installed (primary + fallback)
- [x] eval/stage_1/ directory created and ready
- [x] bin/lib/analysis/ directory contains 6 utility modules
- [x] AST parser implements primary + fallback strategy (Question 5)
- [x] Complexity calculator hardcodes thresholds: Simple < 5, Complex >= 10 (Question 1)
- [x] Classifier implements 3-heuristic helper detection, 2+ = helper (Question 2)
- [x] Confidence calculator uses deduction formula, starts 100%, min 30% (Question 3)
- [x] Relationships tracker limits to direct calls only, documents constraint (Question 4)
- [x] All utilities tested and working independently

## Output

Infrastructure ready with all 5 resolved research questions implemented:

**Files created:**
- bin/lib/analysis/ast-parser.js (Question 5: primary + fallback)
- bin/lib/analysis/complexity.js (Question 1: hardcoded thresholds)
- bin/lib/analysis/side-effects.js
- bin/lib/analysis/classifier.js (Question 2: 3-heuristic helper detection)
- bin/lib/analysis/relationships.js (Question 4: direct calls only)
- bin/lib/analysis/confidence.js (Question 3: deduction-based formula)
- eval/stage_1/.gitkeep

**Dependencies added:**
- @babel/parser (primary parser)
- acorn (fallback parser)

**Resolved questions baked into code:**
1. ✅ Thresholds hardcoded as constants (Simple < 5, Moderate 5-9, Complex >= 10)
2. ✅ Helper detection uses ALL 3 heuristics (2+ matches = helper)
3. ✅ Confidence starts 100%, deductions applied, min 30%
4. ✅ Call site analysis limited to direct dependencies only
5. ✅ Parser strategy: @babel/parser first, acorn fallback, graceful errors

**Next:** Plan 02 will build the main analyzer script and run analysis with user confirmations.
