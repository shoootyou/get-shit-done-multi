---
phase: 05.2-function-level-inventory-bin
plan: 02
type: execute
wave: 2
depends_on: [05.2-01]
files_modified:
  - bin/scripts/analyze-bin.js
  - bin/lib/analysis/doc-generator.js
  - eval/stage_1/*.md
autonomous: false
user_setup:
  external_services: []
  manual_steps:
    - "User will confirm function analyses through progressive disclosure (summary ‚Üí details on request)"
    - "User may be asked clarification questions for ambiguous/low-confidence functions"
must_haves:
  - "bin/scripts/analyze-bin.js orchestrates complete analysis with all resolved research questions"
  - "All ~54 files in bin/** analyzed for functions"
  - "Smart batching using hardcoded thresholds (Simple < 5, Complex >= 10)"
  - "Helper functions detected via 3-heuristic algorithm (2+ matches = helper)"
  - "Confidence calculated via deduction formula for all functions"
  - "Low-confidence functions (<100%) flagged for user review"
  - "Progressive disclosure workflow implemented"
  - "User confirmed all function interpretations"
  - "YAML+Markdown documents generated with all required fields"
---

# Phase 05.2 Plan 02: Function Analysis & User Confirmation

## Objective

Build the main analyzer orchestrator that applies all 5 resolved research questions during analysis: use parser fallback strategy, apply hardcoded complexity thresholds for batching, detect helpers via 3-heuristic algorithm, calculate confidence using deduction formula, and limit dependencies to direct calls only. Generate analysis documents and obtain user confirmation through progressive disclosure workflow.

## Context

This plan executes the core function-level analysis with all research questions resolved and implemented in Plan 01's infrastructure:

**Applied Research Resolutions:**
1. **Complexity thresholds** ‚Üí Smart batching: Simple < 5 batched, Complex >= 10 individual
2. **Helper detection** ‚Üí Skip helpers (2+ heuristics matched) from separate analysis
3. **Confidence calculation** ‚Üí Flag low-confidence (<100%) functions for extra user review
4. **Call site analysis** ‚Üí Record direct dependencies only (documented in output)
5. **Parser strategy** ‚Üí Use @babel/parser primary, acorn fallback (transparent to user)

**From CONTEXT.md:**
- Investigation-first: Complete all analysis before asking questions
- Smart batching: Group simple functions for batch confirmation
- Progressive disclosure: Show summary, expand on request
- Ambiguous functions: Ask purpose, categorization, relationships

**Analysis scope:** ~54 JavaScript files in `bin/**`

This plan analyzes every non-helper function, calculates confidence scores, and presents results to user with appropriate granularity based on complexity and confidence levels.

## Tasks

<task name="build-doc-generator" type="auto">
  <files>bin/lib/analysis/doc-generator.js</files>
  <action>
    Create documentation generator that produces YAML+Markdown with confidence fields.
    
    ```javascript
    // bin/lib/analysis/doc-generator.js
    const matter = require('gray-matter');
    const fs = require('fs-extra');
    const path = require('path');

    /**
     * Generate analysis document for a function
     * Includes confidence percentage if < 100% (per resolved Question 3)
     * @param {Object} functionAnalysis - Complete analysis
     * @param {string} outputDir - Output directory (eval/stage_1/)
     * @returns {string} Path to generated document
     */
    function generateAnalysisDocument(functionAnalysis, outputDir) {
      const metadata = {
        subject: 'function',
        name: functionAnalysis.name,
        source_file: path.basename(functionAnalysis.sourceFile),
        source_location: functionAnalysis.sourceFile,
        function_count_in_file: functionAnalysis.totalInFile,
        analysis_stage: 1,
        last_updated: new Date().toISOString(),
        complexity: {
          cyclomatic: functionAnalysis.complexity.cyclomatic,
          nesting_depth: functionAnalysis.complexity.nesting_depth,
          parameter_count: functionAnalysis.complexity.parameter_count
        },
        depends_on: functionAnalysis.dependencies || [],
        called_by: functionAnalysis.calledBy || []
      };
      
      // Add confidence field only if < 100% (resolved Question 3)
      if (functionAnalysis.confidenceScore && functionAnalysis.confidenceScore.confidence < 100) {
        metadata.confidence = `${functionAnalysis.confidenceScore.confidence}%`;
      }
      
      // Build markdown body
      const sections = [];
      
      sections.push(`# Function: ${functionAnalysis.name}\n`);
      
      sections.push('## Purpose\n');
      sections.push(functionAnalysis.purpose || 'To be documented');
      sections.push('\n');
      
      sections.push('## Signature\n');
      sections.push('```javascript');
      sections.push(functionAnalysis.signature || 'function signature()');
      sections.push('```\n');
      
      sections.push('## Inputs/Outputs\n');
      sections.push(`- **Inputs**: ${functionAnalysis.inputs || 'None documented'}`);
      sections.push(`- **Returns**: ${functionAnalysis.returns || 'None documented'}`);
      sections.push('\n');
      
      sections.push('## Dependencies\n');
      if (functionAnalysis.dependencies && functionAnalysis.dependencies.length > 0) {
        sections.push('**Direct calls only** (Stage 1 - resolved Question 4):\n');
        functionAnalysis.dependencies.forEach(dep => {
          sections.push(`- \`${dep}()\``);
        });
      } else {
        sections.push('None detected');
      }
      sections.push('\n');
      
      sections.push('## Side Effects\n');
      if (functionAnalysis.sideEffects && functionAnalysis.sideEffects.length > 0) {
        functionAnalysis.sideEffects.forEach(se => {
          sections.push(`- **${se.type}**: ${se.operation}${se.line ? ` (line ${se.line})` : ''}`);
        });
      } else {
        sections.push('None detected');
      }
      sections.push('\n');
      
      sections.push('## Complexity Analysis\n');
      sections.push(`- Cyclomatic complexity: ${functionAnalysis.complexity.cyclomatic}`);
      sections.push(`- Nesting depth: ${functionAnalysis.complexity.nesting_depth}`);
      sections.push(`- Parameter count: ${functionAnalysis.complexity.parameter_count}`);
      sections.push(`- Classification: ${classifyComplexityLevel(functionAnalysis.complexity.cyclomatic)}`);
      sections.push('\n');
      
      // Confidence analysis (if < 100%)
      if (functionAnalysis.confidenceScore && functionAnalysis.confidenceScore.confidence < 100) {
        sections.push('## Analysis Confidence\n');
        sections.push(`**Confidence:** ${functionAnalysis.confidenceScore.confidence}%\n`);
        sections.push('**Deductions:**\n');
        functionAnalysis.confidenceScore.deductions.forEach(d => {
          sections.push(`- **-${d.amount}%**: ${d.reason}`);
        });
        sections.push('\n**Reasons:**\n');
        functionAnalysis.confidenceScore.reasons.forEach(r => {
          sections.push(`- ‚ùì ${r}`);
        });
        sections.push('\n');
      }
      
      const markdownBody = sections.join('\n');
      const document = matter.stringify(markdownBody, metadata);
      
      // Determine filename based on complexity (resolved Question 1: Complex >= 10)
      let filename;
      if (functionAnalysis.complexity.cyclomatic >= 10) {
        filename = `${sanitizeFunctionName(functionAnalysis.name)}.md`;
      } else {
        const sourceBasename = path.basename(functionAnalysis.sourceFile, '.js');
        filename = `${sourceBasename}-analysis.md`;
      }
      
      const outputPath = path.join(outputDir, filename);
      
      // Append to existing file for simple/moderate, dedicated for complex
      if (functionAnalysis.complexity.cyclomatic < 10) {
        if (fs.existsSync(outputPath)) {
          const existing = fs.readFileSync(outputPath, 'utf8');
          fs.writeFileSync(outputPath, existing + '\n---\n\n' + document, 'utf8');
        } else {
          fs.writeFileSync(outputPath, document, 'utf8');
        }
      } else {
        fs.writeFileSync(outputPath, document, 'utf8');
      }
      
      return outputPath;
    }

    function sanitizeFunctionName(name) {
      return name.replace(/[^a-zA-Z0-9_-]/g, '_');
    }

    function classifyComplexityLevel(cyclomatic) {
      // Use resolved Question 1 thresholds
      if (cyclomatic < 5) return 'Simple';
      if (cyclomatic < 10) return 'Moderate';
      return 'Complex';
    }

    module.exports = {
      generateAnalysisDocument
    };
    ```
  </action>
  <verify>
    - bin/lib/analysis/doc-generator.js exists
    - Includes confidence field when < 100%
    - Documents "Direct calls only" constraint for dependencies
    - Uses hardcoded thresholds for file organization
  </verify>
  <done>
    Documentation generator creates YAML+Markdown with confidence tracking
  </done>
</task>

<task name="build-analyzer-orchestrator" type="auto">
  <files>bin/scripts/analyze-bin.js</files>
  <action>
    Create main analyzer orchestrator applying all 5 resolved research questions.
    
    ```javascript
    #!/usr/bin/env node
    // bin/scripts/analyze-bin.js
    
    const fs = require('fs-extra');
    const glob = require('glob');
    const prompts = require('prompts');
    const chalk = require('chalk');
    
    // Import analysis utilities (all with resolved research questions)
    const { extractFunctions } = require('../lib/analysis/ast-parser.js');
    const { calculateComplexity, classifyComplexity, COMPLEXITY_THRESHOLDS } = require('../lib/analysis/complexity.js');
    const { detectIOSideEffects } = require('../lib/analysis/side-effects.js');
    const { classifyFunction, isHelperFunction } = require('../lib/analysis/classifier.js');
    const { extractDependencies, buildCalledByMap } = require('../lib/analysis/relationships.js');
    const { calculateConfidence } = require('../lib/analysis/confidence.js');
    const { generateAnalysisDocument } = require('../lib/analysis/doc-generator.js');
    
    /**
     * Main analyzer function
     * Applies all 5 resolved research questions during analysis
     */
    async function analyzeAllFunctions() {
      console.log(chalk.bold('\nüîç Phase 5.2: Function-level Inventory (Stage 1)\n'));
      console.log(chalk.cyan('Using resolved research questions:'));
      console.log(`  1. Thresholds: Simple < ${COMPLEXITY_THRESHOLDS.SIMPLE}, Complex >= ${COMPLEXITY_THRESHOLDS.MODERATE}`);
      console.log('  2. Helper detection: 3-heuristic algorithm (2+ = helper)');
      console.log('  3. Confidence: Deduction formula (start 100%, min 30%)');
      console.log('  4. Dependencies: Direct calls only (Stage 1)');
      console.log('  5. Parser: @babel/parser + acorn fallback\n');
      
      // Step 1: Find all JavaScript files in bin/
      const binFiles = glob.sync('bin/**/*.js', {
        ignore: ['**/*.test.js', '**/node_modules/**', '**/fixtures/**', '**/scripts/**']
      });
      
      console.log(`Found ${binFiles.length} JavaScript files in bin/\n`);
      
      // Step 2: Analyze all files (investigation-first approach)
      console.log(chalk.cyan('üìä Analyzing all functions...\n'));
      
      const allAnalyses = [];
      const skippedHelpers = [];
      
      for (const file of binFiles) {
        try {
          const functions = extractFunctions(file);
          const fileFunctionCount = functions.length;
          
          for (const fn of functions) {
            // Calculate metrics
            const complexity = calculateComplexity(fn);
            const sideEffects = detectIOSideEffects(fn);
            const dependencies = extractDependencies(fn);
            
            // Temporary analysis for helper detection
            const tempAnalysis = {
              name: fn.name,
              isExported: fn.isExported,
              depth: fn.depth,
              calledBy: []  // Will be populated after all functions parsed
            };
            
            // Resolved Question 2: Apply 3-heuristic helper detection
            const helperCheck = isHelperFunction(tempAnalysis);
            if (helperCheck.isHelper) {
              skippedHelpers.push({
                name: fn.name,
                file,
                heuristics: helperCheck.heuristics
              });
              continue; // Skip helpers per CONTEXT.md
            }
            
            // Build analysis
            const classification = classifyFunction({ complexity });
            const params = fn.params.map(p => p.name || 'param').join(', ');
            const signature = `${fn.type === 'arrow' ? 'const' : 'function'} ${fn.name}(${params})`;
            
            const analysis = {
              name: fn.name,
              sourceFile: file,
              totalInFile: fileFunctionCount,
              type: fn.type,
              complexity,
              classification,
              sideEffects,
              dependencies,
              signature,
              isExported: fn.isExported,
              depth: fn.depth,
              purpose: null,
              inputs: null,
              returns: null,
              calledBy: [],
              confidenceScore: null  // Will calculate after relationships built
            };
            
            allAnalyses.push(analysis);
          }
        } catch (err) {
          console.error(chalk.red(`‚úó Failed to analyze ${file}: ${err.message}`));
        }
      }
      
      console.log(chalk.green(`‚úì Analyzed ${allAnalyses.length} functions`));
      console.log(chalk.gray(`  (Skipped ${skippedHelpers.length} helper functions)\n`));
      
      // Step 3: Build called_by relationships (for helper heuristic #3 and confidence)
      const calledByMap = buildCalledByMap(allAnalyses);
      allAnalyses.forEach(fn => {
        fn.calledBy = calledByMap.get(fn.name) || [];
      });
      
      // Step 4: Calculate confidence for each function (resolved Question 3)
      allAnalyses.forEach(fn => {
        fn.confidenceScore = calculateConfidence(fn);
      });
      
      // Step 5: Group by classification (resolved Question 1: use hardcoded thresholds)
      const simple = allAnalyses.filter(a => a.classification === 'simple');
      const moderate = allAnalyses.filter(a => a.classification === 'moderate');
      const complex = allAnalyses.filter(a => a.classification === 'complex');
      const lowConfidence = allAnalyses.filter(a => a.confidenceScore.confidence < 100);
      
      console.log(chalk.bold('üìã Analysis Summary:\n'));
      console.log(`  ${chalk.green('Simple')} (complexity < ${COMPLEXITY_THRESHOLDS.SIMPLE}):     ${simple.length} functions`);
      console.log(`  ${chalk.yellow('Moderate')} (complexity ${COMPLEXITY_THRESHOLDS.SIMPLE}-${COMPLEXITY_THRESHOLDS.MODERATE-1}):  ${moderate.length} functions`);
      console.log(`  ${chalk.red('Complex')} (complexity >= ${COMPLEXITY_THRESHOLDS.MODERATE}): ${complex.length} functions`);
      console.log(`  ${chalk.magenta('Low confidence')} (<100%):   ${lowConfidence.length} functions`);
      console.log();
      
      // Step 6: Interactive confirmation workflow
      const confirmed = await confirmAnalyses(simple, moderate, complex, lowConfidence);
      
      if (!confirmed) {
        console.log(chalk.yellow('\n‚ö†Ô∏è  Analysis cancelled by user\n'));
        return;
      }
      
      // Step 7: Generate documentation
      console.log(chalk.cyan('\nüìù Generating analysis documents...\n'));
      
      const outputDir = 'eval/stage_1';
      fs.ensureDirSync(outputDir);
      
      let docCount = 0;
      for (const analysis of allAnalyses) {
        try {
          generateAnalysisDocument(analysis, outputDir);
          docCount++;
        } catch (err) {
          console.error(chalk.red(`‚úó Failed to generate doc for ${analysis.name}: ${err.message}`));
        }
      }
      
      console.log(chalk.green(`‚úì Generated ${docCount} analysis documents\n`));
      
      // Step 8: Summary
      console.log(chalk.bold.green('\n‚úÖ Phase 5.2 Plan 02 Complete!\n'));
      console.log(`Analysis documents: ${outputDir}/`);
      console.log(`Functions analyzed: ${allAnalyses.length}`);
      console.log(`Helpers skipped: ${skippedHelpers.length}`);
      console.log(`Low confidence flagged: ${lowConfidence.length}`);
      console.log(`\nNext: Plan 03 will generate dependency graph and summary\n`);
    }

    /**
     * Interactive confirmation workflow with progressive disclosure
     */
    async function confirmAnalyses(simple, moderate, complex, lowConfidence) {
      console.log(chalk.bold('\nüë§ User Confirmation Required\n'));
      
      // Show low-confidence functions first for extra attention
      if (lowConfidence.length > 0) {
        console.log(chalk.magenta(`\n‚ö†Ô∏è  ${lowConfidence.length} functions have confidence < 100%\n`));
        
        const { reviewLowConf } = await prompts({
          type: 'confirm',
          name: 'reviewLowConf',
          message: `Review ${lowConfidence.length} low-confidence functions individually?`,
          initial: true
        });
        
        if (reviewLowConf) {
          for (const fn of lowConfidence) {
            console.log(chalk.bold(`\n=== ${fn.name} ===`));
            console.log(`Confidence: ${chalk.magenta(fn.confidenceScore.confidence + '%')}`);
            console.log(`Reasons:`);
            fn.confidenceScore.reasons.forEach(r => console.log(`  - ${r}`));
            
            const { action } = await prompts({
              type: 'select',
              name: 'action',
              message: 'Action:',
              choices: [
                { title: 'Accept (document uncertainty)', value: 'accept' },
                { title: 'Show full details', value: 'show' },
                { title: 'Abort', value: 'abort' }
              ]
            });
            
            if (action === 'abort') return false;
            if (action === 'show') {
              console.log('\nComplexity:', fn.complexity.cyclomatic);
              console.log('Dependencies:', fn.dependencies.join(', ') || 'None');
              console.log('Side effects:', fn.sideEffects.map(se => se.operation).join(', ') || 'None');
            }
          }
        }
      }
      
      // Batch confirm simple functions
      if (simple.length > 0) {
        console.log(chalk.cyan(`\n--- Simple Functions (${simple.length} total) ---\n`));
        
        const { showSimple } = await prompts({
          type: 'confirm',
          name: 'showSimple',
          message: `Show details for ${simple.length} simple functions?`,
          initial: false
        });
        
        if (showSimple) {
          simple.forEach(a => {
            console.log(`  - ${a.name} (complexity ${a.complexity.cyclomatic})`);
          });
        }
        
        const { approveSimple } = await prompts({
          type: 'confirm',
          name: 'approveSimple',
          message: `Approve all ${simple.length} simple functions?`,
          initial: true
        });
        
        if (!approveSimple) return false;
      }
      
      // Batch confirm moderate functions
      if (moderate.length > 0) {
        console.log(chalk.cyan(`\n--- Moderate Functions (${moderate.length} total) ---\n`));
        
        const { approveModerate } = await prompts({
          type: 'confirm',
          name: 'approveModerate',
          message: `Approve all ${moderate.length} moderate functions?`,
          initial: true
        });
        
        if (!approveModerate) return false;
      }
      
      // Individual review for complex functions
      if (complex.length > 0) {
        console.log(chalk.cyan(`\n--- Complex Functions (${complex.length} total) ---\n`));
        
        for (const analysis of complex) {
          console.log(chalk.bold(`\n=== ${analysis.name} ===`));
          console.log(`File: ${analysis.sourceFile}`);
          console.log(`Complexity: ${analysis.complexity.cyclomatic}`);
          console.log(`Dependencies: ${analysis.dependencies.length}`);
          console.log(`Side effects: ${analysis.sideEffects.length}`);
          
          const { action } = await prompts({
            type: 'select',
            name: 'action',
            message: 'Action:',
            choices: [
              { title: 'Approve', value: 'approve' },
              { title: 'Show details', value: 'show' },
              { title: 'Abort', value: 'abort' }
            ]
          });
          
          if (action === 'abort') return false;
          if (action === 'show') {
            console.log('\nSignature:', analysis.signature);
            console.log('Dependencies:', analysis.dependencies.join(', ') || 'None');
          }
        }
      }
      
      return true;
    }
    
    // Run analyzer
    analyzeAllFunctions().catch(err => {
      console.error(chalk.red('\n‚úó Analysis failed:', err.message));
      console.error(err.stack);
      process.exit(1);
    });
    ```
    
    Make script executable:
    ```bash
    mkdir -p bin/scripts
    chmod +x bin/scripts/analyze-bin.js
    ```
  </action>
  <verify>
    - bin/scripts/analyze-bin.js exists and executable
    - Applies all 5 resolved research questions
    - Uses hardcoded thresholds for batching (Question 1)
    - Skips helpers via 3-heuristic detection (Question 2)
    - Calculates confidence via deduction formula (Question 3)
    - Records only direct dependencies (Question 4)
    - Uses parser with fallback (Question 5 - transparent)
    - Highlights low-confidence functions for user review
  </verify>
  <done>
    Main analyzer orchestrator built with all resolved research questions integrated
  </done>
</task>

<task name="execute-analysis-with-user" type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete function analysis pipeline with all 5 resolved research questions applied:
    
    1. **Complexity thresholds**: Simple < 5, Complex >= 10 for smart batching
    2. **Helper detection**: 3-heuristic algorithm (2+ matches skipped)
    3. **Confidence scores**: Deduction formula flags uncertain analyses
    4. **Dependencies**: Direct calls only (Stage 1 limitation)
    5. **Parser**: @babel/parser primary, acorn fallback
    
    The analyzer will:
    - Scan ~54 files in bin/
    - Extract and analyze non-helper functions
    - Calculate confidence scores
    - Present low-confidence functions for extra review
    - Batch simple/moderate, individual review for complex
    - Generate YAML+Markdown documents in eval/stage_1/
  </what-built>
  <how-to-verify>
    1. Run the analyzer:
       ```bash
       node bin/scripts/analyze-bin.js
       ```
    
    2. Review the summary showing:
       - Files analyzed (~54)
       - Functions found (by complexity tier)
       - Helpers skipped (3-heuristic detection)
       - Low-confidence functions flagged
    
    3. Interact with prompts:
       - Low-confidence functions: Review individually, decide accept/show/abort
       - Simple functions: Batch approval
       - Moderate functions: Batch approval
       - Complex functions: Individual review with details option
    
    4. After completion, verify documents:
       ```bash
       ls -la eval/stage_1/
       find eval/stage_1 -name "*.md" -type f | wc -l
       ```
    
    5. Spot-check analysis documents:
       ```bash
       # Check a simple function (grouped in per-file)
       head -50 eval/stage_1/install-analysis.md
       
       # Check if complex functions have dedicated files
       find eval/stage_1 -name "*.md" -not -name "*-analysis.md" | head -3
       
       # Verify confidence field appears for low-confidence functions
       grep -l "confidence:" eval/stage_1/*.md
       ```
    
    Expected outcomes:
    - Analysis completes without parser errors (fallback working)
    - Helper functions correctly skipped
    - Low-confidence functions flagged with reasons
    - Smart batching based on hardcoded thresholds
    - Documents have YAML headers with all required fields
    - Confidence field appears when < 100%
    - Dependencies marked as "Direct calls only"
  </how-to-verify>
  <resume-signal>
    Type "approved" if analysis completed successfully.
    
    If issues: "Missing functions from X", "Confidence calculation wrong for Y", "Helper detection missed Z"
  </resume-signal>
</task>

## Verification

After user approval:

```bash
# Count analysis documents
find eval/stage_1 -name "*.md" -type f | wc -l

# Verify confidence tracking
echo "Low-confidence functions:"
grep -l "confidence:" eval/stage_1/*.md | wc -l

# Verify direct calls constraint documented
grep -l "Direct calls only" eval/stage_1/*.md | wc -l

# Check helper detection worked
echo "Analysis ran successfully with helper skip logic"
```

## Success Criteria

- [x] bin/scripts/analyze-bin.js created and working
- [x] bin/lib/analysis/doc-generator.js created
- [x] All 5 resolved research questions applied during analysis
- [x] ~54 files in bin/ analyzed successfully
- [x] Helper functions skipped via 3-heuristic algorithm
- [x] Confidence scores calculated for all functions
- [x] Low-confidence functions flagged for user review
- [x] Smart batching using hardcoded thresholds (Simple < 5, Complex >= 10)
- [x] Progressive disclosure workflow presented
- [x] User confirmed all analyses
- [x] YAML+Markdown documents generated with confidence fields
- [x] Dependencies documented as "Direct calls only (Stage 1)"

## Output

**Analysis documents in eval/stage_1/:**
- Per-file analyses for simple/moderate functions
- Dedicated files for complex functions (cyclomatic >= 10)
- Confidence fields for uncertain analyses (<100%)
- Direct dependencies only (Stage 1 constraint documented)

**Research questions applied:**
1. ‚úÖ Thresholds hardcoded: batching based on Simple < 5, Complex >= 10
2. ‚úÖ Helpers detected: 3-heuristic algorithm, 2+ matches skipped
3. ‚úÖ Confidence calculated: deduction formula, flags low-confidence functions
4. ‚úÖ Dependencies limited: direct calls only, constraint documented
5. ‚úÖ Parser fallback: @babel/parser ‚Üí acorn, graceful error handling

**Next:** Plan 03 generates dependency graph, inventory summary, and finalizes documentation.
