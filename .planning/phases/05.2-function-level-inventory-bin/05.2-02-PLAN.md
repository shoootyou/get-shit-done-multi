---
phase: 05.2-function-level-inventory-bin
plan: 02
type: execute
wave: 2
depends_on: [05.2-01]
files_modified:
  - bin/scripts/analyze-bin.js
  - bin/lib/analysis/doc-generator.js
  - eval/stage_1/*.md (analysis documents)
autonomous: false
user_setup:
  external_services: []
  manual_steps:
    - "User will interactively confirm function analyses through progressive disclosure workflow"
    - "User may be asked clarification questions for ambiguous functions"
must_haves:
  - "bin/scripts/analyze-bin.js orchestrates complete analysis pipeline"
  - "All ~51 files in bin/** analyzed for functions"
  - "Smart batching implemented: simple functions in batches, complex individually"
  - "Progressive disclosure: show summary first, expand on request"
  - "User confirmed all function interpretations"
  - "YAML+Markdown analysis documents generated using gray-matter"
  - "Analysis documents use hybrid organization (per-file for simple, dedicated for complex)"
  - "All YAML headers include required fields + complexity + relationships + confidence"
---

# Phase 05.2 Plan 02: Function Analysis & Confirmation

## Objective

Build the main analyzer orchestrator, execute comprehensive function-by-function analysis of all `bin/**` files with interactive user confirmation workflow using smart batching and progressive disclosure, and generate YAML+Markdown analysis documents.

## Context

This is the core execution phase of the function-level inventory. We'll analyze ~51 JavaScript files in `bin/**` directory, extract every function, calculate complexity metrics, detect I/O side effects, and document each function with user confirmation throughout the process.

**From CONTEXT.md - User Interaction Model:**
- Investigation-first approach: Complete initial analysis before asking clarifications
- Smart batching: Simple functions (cyclomatic < 5) confirmed in batches
- Progressive disclosure: Show summary, allow expansion to details
- Individual review for complex functions (cyclomatic >= 10)
- Ambiguous functions: Ask purpose, categorization, relationships

**From CONTEXT.md - Output Structure:**
- Hybrid file organization: Per-source-file for simple, dedicated files for complex
- YAML headers: subject, name, source_file, complexity, depends_on, called_by, confidence
- Markdown body: Purpose, Signature, Inputs/Outputs, Dependencies, Side Effects, Complexity Analysis
- Uncertainty markers: YAML confidence field + Uncertainties section + inline emoji (‚ö†Ô∏è, ‚ùì)

**Dependencies from Plan 01:**
- @babel/parser installed
- bin/lib/analysis utilities ready (ast-parser, complexity, side-effects, classifier, relationships)
- eval/stage_1/ directory created

This plan creates the orchestrator, runs the full analysis, and generates all documentation with user involvement.

## Tasks

<task name="build-doc-generator-utility" type="auto">
  <files>bin/lib/analysis/doc-generator.js</files>
  <action>
    Create documentation generator that produces YAML+Markdown analysis documents using gray-matter.
    
    **Implementation:**
    ```javascript
    // bin/lib/analysis/doc-generator.js
    const matter = require('gray-matter');
    const fs = require('fs-extra');
    const path = require('path');
    
    /**
     * Generate analysis document for a function
     * Per CONTEXT.md: Hybrid organization (per-file for simple, dedicated for complex)
     * @param {Object} functionAnalysis - Complete analysis for function
     * @param {string} outputDir - Output directory (eval/stage_1/)
     * @returns {string} Path to generated document
     */
    function generateAnalysisDocument(functionAnalysis, outputDir) {
      const metadata = {
        subject: 'function',
        name: functionAnalysis.name,
        source_file: path.basename(functionAnalysis.sourceFile),
        source_location: functionAnalysis.sourceFile,
        function_count_in_file: functionAnalysis.totalInFile,
        analysis_stage: 1,
        last_updated: new Date().toISOString(),
        complexity: {
          cyclomatic: functionAnalysis.complexity.cyclomatic,
          nesting_depth: functionAnalysis.complexity.nesting_depth,
          parameter_count: functionAnalysis.complexity.parameter_count
        },
        depends_on: functionAnalysis.dependencies || [],
        called_by: functionAnalysis.calledBy || []
      };
      
      // Add confidence field only if < 100%
      if (functionAnalysis.confidence && functionAnalysis.confidence < 100) {
        metadata.confidence = `${functionAnalysis.confidence}%`;
      }
      
      // Build markdown body
      const sections = [];
      
      sections.push(`# Function: ${functionAnalysis.name}\n`);
      
      sections.push('## Purpose\n');
      sections.push(functionAnalysis.purpose || 'To be documented');
      sections.push('\n');
      
      sections.push('## Signature\n');
      sections.push('```javascript');
      sections.push(functionAnalysis.signature || 'function signature()');
      sections.push('```\n');
      
      sections.push('## Inputs/Outputs\n');
      sections.push(`- **Inputs**: ${functionAnalysis.inputs || 'None documented'}`);
      sections.push(`- **Returns**: ${functionAnalysis.returns || 'None documented'}`);
      sections.push('\n');
      
      sections.push('## Dependencies\n');
      if (functionAnalysis.dependencies && functionAnalysis.dependencies.length > 0) {
        functionAnalysis.dependencies.forEach(dep => {
          sections.push(`- \`${dep}()\``);
        });
      } else {
        sections.push('None detected');
      }
      sections.push('\n');
      
      sections.push('## Side Effects\n');
      if (functionAnalysis.sideEffects && functionAnalysis.sideEffects.length > 0) {
        functionAnalysis.sideEffects.forEach(se => {
          sections.push(`- **${se.type}**: ${se.operation}${se.line ? ` (line ${se.line})` : ''}`);
        });
      } else {
        sections.push('None detected');
      }
      sections.push('\n');
      
      sections.push('## Complexity Analysis\n');
      sections.push(`- Cyclomatic complexity: ${functionAnalysis.complexity.cyclomatic}`);
      sections.push(`- Nesting depth: ${functionAnalysis.complexity.nesting_depth}`);
      sections.push(`- Parameter count: ${functionAnalysis.complexity.parameter_count}`);
      sections.push(`- Classification: ${classifyComplexityLevel(functionAnalysis.complexity.cyclomatic)}`);
      sections.push('\n');
      
      // Internal helpers (if any)
      if (functionAnalysis.internalHelpers && functionAnalysis.internalHelpers.length > 0) {
        sections.push('## Internal Helpers\n');
        functionAnalysis.internalHelpers.forEach(helper => {
          sections.push(`### ${helper.name}\n`);
          sections.push(helper.description || 'Helper function');
          sections.push('\n');
        });
      }
      
      // Uncertainties (if confidence < 100%)
      if (functionAnalysis.uncertainties && functionAnalysis.uncertainties.length > 0) {
        sections.push('## Uncertainties\n');
        functionAnalysis.uncertainties.forEach(u => {
          const marker = u.marker || '‚ùì';
          sections.push(`- ${marker} ${u.description}`);
        });
        sections.push('\n');
      }
      
      const markdownBody = sections.join('\n');
      const document = matter.stringify(markdownBody, metadata);
      
      // Determine filename based on complexity
      // Per CONTEXT.md: Complex functions (>= 10) get dedicated files
      let filename;
      if (functionAnalysis.complexity.cyclomatic >= 10) {
        filename = `${sanitizeFunctionName(functionAnalysis.name)}.md`;
      } else {
        // Simple/moderate: group in per-file analysis
        const sourceBasename = path.basename(functionAnalysis.sourceFile, '.js');
        filename = `${sourceBasename}-analysis.md`;
      }
      
      const outputPath = path.join(outputDir, filename);
      
      // If appending to existing file (simple functions)
      if (functionAnalysis.complexity.cyclomatic < 10) {
        // Check if file exists, append if so
        if (fs.existsSync(outputPath)) {
          const existing = fs.readFileSync(outputPath, 'utf8');
          fs.writeFileSync(outputPath, existing + '\n---\n\n' + document, 'utf8');
        } else {
          fs.writeFileSync(outputPath, document, 'utf8');
        }
      } else {
        // Complex functions: dedicated file
        fs.writeFileSync(outputPath, document, 'utf8');
      }
      
      return outputPath;
    }
    
    /**
     * Sanitize function name for filename
     */
    function sanitizeFunctionName(name) {
      return name.replace(/[^a-zA-Z0-9_-]/g, '_');
    }
    
    /**
     * Classify complexity level (Simple/Moderate/Complex)
     */
    function classifyComplexityLevel(cyclomatic) {
      if (cyclomatic < 5) return 'Simple';
      if (cyclomatic < 10) return 'Moderate';
      return 'Complex';
    }
    
    module.exports = {
      generateAnalysisDocument
    };
    ```
    
    **Test the generator:**
    ```bash
    node -e "
    const { generateAnalysisDocument } = require('./bin/lib/analysis/doc-generator.js');
    const fs = require('fs-extra');
    
    const testAnalysis = {
      name: 'testFunction',
      sourceFile: './bin/test.js',
      totalInFile: 5,
      complexity: { cyclomatic: 3, nesting_depth: 1, parameter_count: 2 },
      purpose: 'Test purpose',
      signature: 'function testFunction(a, b) { return a + b; }',
      inputs: 'a (number), b (number)',
      returns: 'sum (number)',
      dependencies: [],
      calledBy: [],
      sideEffects: [],
      confidence: 100
    };
    
    fs.ensureDirSync('eval/stage_1');
    const output = generateAnalysisDocument(testAnalysis, 'eval/stage_1');
    console.log('Generated:', output);
    console.log(fs.readFileSync(output, 'utf8').substring(0, 300));
    "
    ```
  </action>
  <verify>
    - bin/lib/analysis/doc-generator.js exists and exports generateAnalysisDocument
    - Test creates analysis document in eval/stage_1/
    - Document includes YAML frontmatter with all required fields
    - Markdown body includes all sections (Purpose, Signature, etc.)
    - Hybrid organization works (complex functions get dedicated files)
  </verify>
  <done>
    Documentation generator can create properly formatted YAML+Markdown analysis documents
  </done>
</task>

<task name="build-analyzer-orchestrator" type="auto">
  <files>bin/scripts/analyze-bin.js</files>
  <action>
    Create main analyzer script that orchestrates the complete analysis pipeline.
    
    **Create scripts directory:**
    ```bash
    mkdir -p bin/scripts
    ```
    
    **Implementation:**
    ```javascript
    #!/usr/bin/env node
    // bin/scripts/analyze-bin.js
    
    const fs = require('fs-extra');
    const path = require('path');
    const glob = require('glob');
    const prompts = require('prompts');
    const chalk = require('chalk');
    
    // Import analysis utilities
    const { extractFunctions } = require('../lib/analysis/ast-parser.js');
    const { calculateComplexity, classifyComplexity } = require('../lib/analysis/complexity.js');
    const { detectIOSideEffects } = require('../lib/analysis/side-effects.js');
    const { classifyFunction, isHelperFunction } = require('../lib/analysis/classifier.js');
    const { extractDependencies, buildCalledByMap } = require('../lib/analysis/relationships.js');
    const { generateAnalysisDocument } = require('../lib/analysis/doc-generator.js');
    
    /**
     * Main analyzer function
     * Per CONTEXT.md: Investigation-first, then smart batching confirmations
     */
    async function analyzeAllFunctions() {
      console.log(chalk.bold('\nüîç Phase 5.2: Function-level Inventory\n'));
      
      // Step 1: Find all JavaScript files in bin/
      const binFiles = glob.sync('bin/**/*.js', {
        ignore: ['**/*.test.js', '**/node_modules/**', '**/fixtures/**']
      });
      
      console.log(`Found ${binFiles.length} JavaScript files in bin/\n`);
      
      // Step 2: Analyze all files (investigation-first approach)
      console.log(chalk.cyan('üìä Analyzing all functions (this may take a minute)...\n'));
      
      const allAnalyses = [];
      const fileAnalyses = new Map(); // Track functions per file
      
      for (const file of binFiles) {
        try {
          const functions = extractFunctions(file);
          const fileFunctionCount = functions.length;
          
          for (const fn of functions) {
            // Skip helper functions (documented with parent)
            if (isHelperFunction(fn)) {
              continue; // Per CONTEXT.md: helpers not analyzed separately
            }
            
            // Calculate metrics
            const complexity = calculateComplexity(fn);
            const sideEffects = detectIOSideEffects(fn);
            const dependencies = extractDependencies(fn);
            const classification = classifyFunction({ complexity });
            
            // Build signature string
            const params = fn.params.map(p => p.name || 'param').join(', ');
            const signature = `${fn.type === 'arrow' ? 'const' : 'function'} ${fn.name}(${params})`;
            
            const analysis = {
              name: fn.name,
              sourceFile: file,
              totalInFile: fileFunctionCount,
              type: fn.type,
              complexity,
              classification,
              sideEffects,
              dependencies,
              signature,
              isExported: fn.isExported,
              confidence: 100, // Default, may be lowered for ambiguous functions
              // To be filled during confirmation
              purpose: null,
              inputs: null,
              returns: null,
              calledBy: [],
              uncertainties: []
            };
            
            allAnalyses.push(analysis);
            
            // Track per file
            if (!fileAnalyses.has(file)) {
              fileAnalyses.set(file, []);
            }
            fileAnalyses.get(file).push(analysis);
          }
        } catch (err) {
          console.error(chalk.red(`‚úó Failed to analyze ${file}: ${err.message}`));
        }
      }
      
      console.log(chalk.green(`‚úì Analyzed ${allAnalyses.length} functions\n`));
      
      // Step 3: Build called_by relationships
      const calledByMap = buildCalledByMap(allAnalyses);
      allAnalyses.forEach(fn => {
        fn.calledBy = calledByMap.get(fn.name) || [];
      });
      
      // Step 4: Group by classification for smart batching
      const simple = allAnalyses.filter(a => a.classification === 'simple');
      const moderate = allAnalyses.filter(a => a.classification === 'moderate');
      const complex = allAnalyses.filter(a => a.classification === 'complex');
      
      console.log(chalk.bold('üìã Analysis Summary:\n'));
      console.log(`  ${chalk.green('Simple')} (complexity < 5):     ${simple.length} functions`);
      console.log(`  ${chalk.yellow('Moderate')} (complexity 5-9):  ${moderate.length} functions`);
      console.log(`  ${chalk.red('Complex')} (complexity >= 10): ${complex.length} functions`);
      console.log();
      
      // Step 5: Interactive confirmation workflow
      const confirmed = await confirmAnalyses(simple, moderate, complex);
      
      if (!confirmed) {
        console.log(chalk.yellow('\n‚ö†Ô∏è  Analysis cancelled by user\n'));
        return;
      }
      
      // Step 6: Generate documentation
      console.log(chalk.cyan('\nüìù Generating analysis documents...\n'));
      
      const outputDir = 'eval/stage_1';
      fs.ensureDirSync(outputDir);
      
      let docCount = 0;
      for (const analysis of allAnalyses) {
        try {
          generateAnalysisDocument(analysis, outputDir);
          docCount++;
        } catch (err) {
          console.error(chalk.red(`‚úó Failed to generate doc for ${analysis.name}: ${err.message}`));
        }
      }
      
      console.log(chalk.green(`‚úì Generated ${docCount} analysis documents\n`));
      
      // Step 7: Summary
      console.log(chalk.bold.green('\n‚úÖ Phase 5.2 Plan 02 Complete!\n'));
      console.log(`Analysis documents: ${outputDir}/`);
      console.log(`Next: Plan 03 will generate dependency graph and finalize documentation\n`);
    }
    
    /**
     * Interactive confirmation workflow
     * Per CONTEXT.md: Smart batching + progressive disclosure
     */
    async function confirmAnalyses(simple, moderate, complex) {
      console.log(chalk.bold('\nüë§ User Confirmation Required\n'));
      
      // Batch confirm simple functions
      if (simple.length > 0) {
        console.log(chalk.cyan(`\n--- Simple Functions (${simple.length} total) ---\n`));
        
        const { showSimple } = await prompts({
          type: 'confirm',
          name: 'showSimple',
          message: `Show details for ${simple.length} simple functions?`,
          initial: false
        });
        
        if (showSimple) {
          simple.forEach(a => {
            console.log(`  - ${a.name} (complexity ${a.complexity.cyclomatic}, ${a.sideEffects.length} side effects)`);
          });
        }
        
        const { approveSimple } = await prompts({
          type: 'confirm',
          name: 'approveSimple',
          message: `Approve all ${simple.length} simple functions?`,
          initial: true
        });
        
        if (!approveSimple) {
          console.log(chalk.yellow('Simple functions not approved.'));
          return false;
        }
      }
      
      // Batch confirm moderate functions (optional detail view)
      if (moderate.length > 0) {
        console.log(chalk.cyan(`\n--- Moderate Functions (${moderate.length} total) ---\n`));
        
        const { showModerate } = await prompts({
          type: 'confirm',
          name: 'showModerate',
          message: `Show details for ${moderate.length} moderate functions?`,
          initial: false
        });
        
        if (showModerate) {
          moderate.forEach(a => {
            console.log(`  - ${a.name} (complexity ${a.complexity.cyclomatic}, ${a.sideEffects.length} side effects, ${a.dependencies.length} dependencies)`);
          });
        }
        
        const { approveModerate } = await prompts({
          type: 'confirm',
          name: 'approveModerate',
          message: `Approve all ${moderate.length} moderate functions?`,
          initial: true
        });
        
        if (!approveModerate) {
          console.log(chalk.yellow('Moderate functions not approved.'));
          return false;
        }
      }
      
      // Individual review for complex functions
      if (complex.length > 0) {
        console.log(chalk.cyan(`\n--- Complex Functions (${complex.length} total) ---\n`));
        console.log(chalk.yellow('Each complex function requires individual review.\n'));
        
        for (const analysis of complex) {
          console.log(chalk.bold(`\n=== ${analysis.name} ===`));
          console.log(`File: ${analysis.sourceFile}`);
          console.log(`Complexity: ${analysis.complexity.cyclomatic} (${classifyComplexity(analysis.complexity.cyclomatic)})`);
          console.log(`Nesting depth: ${analysis.complexity.nesting_depth}`);
          console.log(`Parameters: ${analysis.complexity.parameter_count}`);
          console.log(`Side effects: ${analysis.sideEffects.length}`);
          console.log(`Dependencies: ${analysis.dependencies.length}`);
          
          const { action } = await prompts({
            type: 'select',
            name: 'action',
            message: 'Action:',
            choices: [
              { title: 'Approve', value: 'approve' },
              { title: 'Show full details', value: 'show' },
              { title: 'Skip for now', value: 'skip' },
              { title: 'Abort analysis', value: 'abort' }
            ]
          });
          
          if (action === 'abort') {
            return false;
          } else if (action === 'show') {
            console.log('\nSignature:', analysis.signature);
            console.log('Dependencies:', analysis.dependencies.join(', ') || 'None');
            console.log('Side effects:', analysis.sideEffects.map(se => se.operation).join(', ') || 'None');
          } else if (action === 'skip') {
            console.log(chalk.yellow(`Skipped ${analysis.name}`));
            continue;
          }
        }
      }
      
      return true;
    }
    
    // Run analyzer
    analyzeAllFunctions().catch(err => {
      console.error(chalk.red('\\n‚úó Analysis failed:', err.message));
      console.error(err.stack);
      process.exit(1);
    });
    ```
    
    **Make script executable:**
    ```bash
    chmod +x bin/scripts/analyze-bin.js
    ```
    
    **Test the analyzer (dry run - user will approve/abort):**
    ```bash
    node bin/scripts/analyze-bin.js
    ```
    
    This will start the analysis and wait for user confirmation at checkpoints.
  </action>
  <verify>
    - bin/scripts/analyze-bin.js exists and is executable
    - Script imports all analysis utilities correctly
    - Finds all JavaScript files in bin/ (should find ~51 files)
    - Extracts and analyzes functions from each file
    - Groups functions by complexity (simple/moderate/complex)
    - Presents interactive confirmation workflow to user
  </verify>
  <done>
    Main analyzer orchestrator is built and ready to run full analysis with user interaction
  </done>
</task>

<task name="execute-function-analysis" type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete function analysis pipeline with interactive user confirmation workflow.
    
    The analyzer will:
    1. Scan all ~51 JavaScript files in bin/
    2. Extract and analyze every function (complexity, side effects, dependencies)
    3. Group functions by complexity for smart batching
    4. Present progressive disclosure workflow for user confirmation
    5. Generate YAML+Markdown analysis documents in eval/stage_1/
  </what-built>
  <how-to-verify>
    1. Run the analyzer script:
       ```bash
       node bin/scripts/analyze-bin.js
       ```
    
    2. Review the analysis summary presented:
       - Total files found in bin/
       - Total functions analyzed
       - Breakdown by complexity (simple/moderate/complex)
    
    3. Interact with confirmation prompts:
       - For simple functions: Choose whether to see details, then approve/reject batch
       - For moderate functions: Same progressive disclosure workflow
       - For complex functions: Individual review with full details
    
    4. After approval, verify documents generated:
       ```bash
       ls -la eval/stage_1/
       ```
    
    5. Spot-check a few analysis documents:
       ```bash
       # Check a simple function (in per-file analysis)
       cat eval/stage_1/install-analysis.md | head -50
       
       # Check if any complex functions have dedicated files
       find eval/stage_1 -name "*.md" -type f
       ```
    
    6. Verify YAML frontmatter structure:
       ```bash
       # Should show valid YAML with required fields
       head -20 eval/stage_1/*.md
       ```
    
    Expected outcomes:
    - Analysis completes without errors
    - User confirmation workflow is clear and non-fatiguing
    - Analysis documents exist in eval/stage_1/
    - Documents have proper YAML headers + Markdown body
    - Complex functions (if any) have dedicated files
    - Simple/moderate functions grouped in per-file analyses
  </how-to-verify>
  <resume-signal>
    Type "approved" if analysis completed successfully and documents look good.
    
    If issues found, describe them (e.g., "Missing functions from X file", "YAML headers malformed", "Complexity calculation seems wrong for Y function").
  </resume-signal>
</task>

## Verification

After user approval:

```bash
# Count analysis documents generated
find eval/stage_1 -name "*.md" -type f | wc -l

# Verify YAML frontmatter in documents
grep -l "subject: function" eval/stage_1/*.md | wc -l

# Check for complexity metrics
grep -l "cyclomatic:" eval/stage_1/*.md | wc -l

# Verify all files analyzed
echo "Files in bin/:" $(find bin/ -name "*.js" -not -path "*/node_modules/*" -not -name "*.test.js" | wc -l)
echo "Analysis docs:" $(find eval/stage_1 -name "*.md" | wc -l)
```

## Success Criteria

- [x] bin/scripts/analyze-bin.js created and working
- [x] bin/lib/analysis/doc-generator.js created
- [x] All ~51 JavaScript files in bin/ analyzed
- [x] Functions extracted and categorized by complexity
- [x] Smart batching workflow presented to user
- [x] Progressive disclosure (summary ‚Üí details on request)
- [x] User confirmed all function analyses
- [x] YAML+Markdown documents generated in eval/stage_1/
- [x] Hybrid organization: complex functions in dedicated files, simple grouped per-file
- [x] All YAML headers include: subject, name, source_file, complexity, depends_on, called_by
- [x] Markdown bodies include: Purpose, Signature, Inputs/Outputs, Dependencies, Side Effects, Complexity

## Output

**Analysis documents created in eval/stage_1/:**
- Per-file analyses for simple/moderate functions (e.g., `install-analysis.md`, `paths-analysis.md`)
- Dedicated files for complex functions (if any with cyclomatic >= 10)

**User interaction completed:**
- All function analyses confirmed through progressive disclosure workflow
- Ambiguous functions clarified (if any)

**Next:** Plan 03 will generate the dependency graph file, verify all documentation is complete, and update the roadmap.
