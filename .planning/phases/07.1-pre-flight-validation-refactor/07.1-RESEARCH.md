# Phase 7.1: Pre-Flight Validation Refactor - Research

**Researched:** 2025-01-29
**Domain:** Validation orchestration, error aggregation, CLI testing patterns
**Confidence:** HIGH

## Summary

Pre-flight validation is a standard pattern in mature CLIs (npm, git, docker) where all checks run upfront before any work begins. The key insight is the hybrid approach: **fail-fast execution** (stop at first blocker) combined with **fail-slow reporting** (collect all errors before displaying).

The standard architecture uses an **orchestrator pattern** - a single coordinator function that delegates to domain-specific validators, manages dependency ordering, collects errors, and formats grouped output. This provides better UX than scattered validation (users see all problems at once, not one-at-a-time).

Critical implementation details from existing code analysis and Node.js best practices:
- Use Node.js built-in `fs.statfs()` with `bavail` (not `bfree`) for disk checks
- Order validations: cheap-first (disk â†’ templates) then expensive-last (paths)
- Stop on prerequisite failures (templates missing â†’ skip path validation)
- Use existing validation modules (path-validator.js, symlink-resolver.js) rather than duplicating
- Test with integration tests in isolated `/tmp` directories (mocking fs defeats the purpose)

**Primary recommendation:** Build thin orchestrator that coordinates existing validators with try-catch error collection, format grouped output extending error-logger.js, and test with bash-based integration suite executing real install.js.

## Standard Stack

The established approach for pre-flight validation in Node.js CLIs:

### Core
| Component | Source | Purpose | Why Standard |
|-----------|--------|---------|--------------|
| Orchestrator Pattern | Industry standard (npm, git) | Single entry point coordinating domain validators | Separation of concerns, clear error collection point |
| fs.statfs() | Node.js 19+ built-in | Cross-platform disk space checking | Native API, no dependencies needed |
| Existing validators | Project codebase | Path security, permissions, disk checks | Already comprehensive (8-layer path validation), tested |
| Error grouping | CLI best practice | Category-based error display | Users see all problems at once (not whack-a-mole) |

### Supporting
| Component | Source | Purpose | When to Use |
|-----------|--------|---------|-------------|
| lstat + readlink | Node.js fs/promises | Symlink detection and resolution | Pre-flight symlink validation (don't follow symlinks) |
| try-catch blocks | JavaScript standard | Error collection in orchestrator | Wrap each validator, accumulate errors |
| InstallError types | Project errors/ | Structured error objects | Existing error infrastructure with codes and details |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Orchestrator function | Class-based validators (Strategy pattern) | Classes add overhead for 5 validators; functions sufficient |
| Built-in statfs | check-disk-space npm package | Package adds dependency for single function now built-in |
| Integration tests | Jest with mocked fs | Mocking defeats purpose - validation needs real filesystem |

**Installation:**
```bash
# No new dependencies required
# Use Node.js 19+ for fs.statfs() built-in
```

## Architecture Patterns

### Recommended Project Structure
```
bin/lib/preflight/
â”œâ”€â”€ pre-flight-validator.js    # Orchestrator: validateBeforeInstall()
â””â”€â”€ error-formatter.js          # formatPreflightReport() - extend error-logger.js
```

**Rationale:** Independent domain module like `updater/`, not transversal concern like `validation/` (which contains reusable validators). Clear boundary between "validation logic" (validation/) and "validation orchestration" (preflight/).

### Pattern 1: Orchestrator with Error Collection
**What:** Single coordinator function delegates to validators, catches errors, manages flow
**When to use:** Pre-flight validation gate before installation begins
**Example:**
```javascript
// Source: Existing codebase pattern + CLI best practices
// bin/lib/preflight/pre-flight-validator.js

import { checkDiskSpace, checkWritePermissions } from '../validation/pre-install-checks.js';
import { validateAllPaths } from '../validation/path-validator.js';
import { resolveSymlinkSingleLevel } from '../paths/symlink-resolver.js';
import { formatPreflightReport } from './error-formatter.js';

/**
 * Pre-flight validation orchestrator
 * Hybrid approach: fail-fast execution + fail-slow reporting
 * 
 * Order: disk â†’ templates â†’ permissions â†’ paths â†’ symlinks
 * Stop: At first prerequisite failure (templates missing)
 * Collect: All independent validation errors
 */
export async function validateBeforeInstall(config) {
  const errors = [];
  
  // 1. Disk space (cheap, independent)
  try {
    await checkDiskSpace(config.targetDir, config.templateSize);
  } catch (err) {
    errors.push({ category: 'Disk', error: err });
  }
  
  // 2. Templates exist (cheap, PREREQUISITE for paths)
  try {
    await checkTemplatesExist(config.templatesDir);
  } catch (err) {
    errors.push({ category: 'Templates', error: err });
    // STOP HERE: Can't validate paths without templates
    throw formatPreflightReport(errors);
  }
  
  // 3. Write permissions (medium cost)
  try {
    await checkWritePermissions(config.targetDir);
  } catch (err) {
    errors.push({ category: 'Permissions', error: err });
  }
  
  // 4. Batch path validation (expensive: N paths Ã— 8 layers)
  const pathResults = validateAllPaths(config.basePath, config.outputPaths);
  if (pathResults.invalid.length > 0) {
    errors.push({ 
      category: 'Paths',
      invalid: pathResults.invalid 
    });
  }
  
  // 5. Symlink warnings (non-blocking)
  const symlinkInfo = await resolveSymlinkSingleLevel(config.targetDir);
  if (symlinkInfo.isSymlink) {
    // Handle separately - user prompt, not error
    await promptSymlinkConfirmation(symlinkInfo);
  }
  
  // Report all collected errors
  if (errors.length > 0) {
    throw formatPreflightReport(errors);
  }
}
```

### Pattern 2: Dependency-Aware Ordering
**What:** Order validations by cost + dependencies, stop at prerequisite failures
**When to use:** Managing validation execution flow
**Dependency chain:**
```
Templates (required) â†’ blocks â†’ Paths
                    â†˜ blocks â†’ Permissions

Disk (independent - always run)
Symlinks (independent warning - always check)
```

**Implementation:**
```javascript
// Check prerequisites first
if (templatesMissing) {
  throw immediately; // Skip dependent checks (paths, permissions)
}

// Continue collecting independent errors
collectDiskErrors();
collectPathErrors();
collectPermissionErrors();
```

### Pattern 3: Grouped Error Formatting
**What:** Category-based error display with visual hierarchy
**When to use:** Displaying validation results to user
**Example:**
```javascript
// Source: CLI best practices (npm, git, docker)
// bin/lib/preflight/error-formatter.js

export function formatPreflightReport(errors) {
  const lines = ['', 'ðŸš¨ Pre-Flight Validation Failed', ''];
  
  // Group by category
  const groups = {
    Templates: [],
    Paths: [],
    Disk: [],
    Permissions: [],
    Symlinks: []
  };
  
  for (const err of errors) {
    if (!groups[err.category]) continue;
    groups[err.category].push(err);
  }
  
  // Format each category
  for (const [category, items] of Object.entries(groups)) {
    if (items.length === 0) continue;
    
    lines.push(`${category}:`);
    for (const item of items) {
      lines.push(`  âœ— ${item.error.message}`);
      
      // Add details from error.details
      if (item.error.details?.reason) {
        lines.push(`  | Reason: ${item.error.details.reason}`);
      }
      if (item.error.details?.fix) {
        lines.push(`  | Fix: ${item.error.details.fix}`);
      }
    }
    lines.push('');
  }
  
  return lines.join('\n');
}
```

**Output format:**
```
ðŸš¨ Pre-Flight Validation Failed

Templates:
  âœ— Missing: templates/skills/
  | Fix: Ensure templates directory exists

Paths:
  âœ— Invalid path: ../../../etc
  | Reason: Path traversal detected
  | Fix: Use a valid installation directory

Disk:
  âœ— Insufficient space: 5MB available
  | Required: 15MB (10MB templates + 50% buffer)
  | Fix: Free up disk space
```

### Anti-Patterns to Avoid

- **Defense-in-Depth Redundancy:** Validating same thing in multiple places (pre-flight, during install, post-install). Decision: Single validation point upfront.

- **Wrong Fail-Fast/Slow Balance:** Either stopping at first error (whack-a-mole UX) OR continuing all checks when prerequisite missing (wasted time). Use hybrid: collect independent errors, stop on prerequisites.

- **Technical Error Messages:** Showing stack traces or internal error codes to users. Always format with user-facing message + actionable fix.

- **Expensive-First Ordering:** Running path validation (N Ã— 8 layers) before checking if templates exist. Order by cost: cheap checks first, expensive last.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Disk space checking | Shell `df` parsing, custom C bindings | `fs.statfs()` (Node 19+) | Built-in, cross-platform, handles edge cases |
| Path security validation | New traversal detection | Existing `path-validator.js` | 8-layer defense-in-depth, already tested |
| Symlink resolution | Custom readlink logic | Existing `symlink-resolver.js` | Handles broken/circular symlinks |
| Error formatting | New formatting system | Extend `error-logger.js` | Consistency with existing error display |
| Permission checking | fs.access() checks | Existing `checkWritePermissions()` | Actually writes test file (more reliable) |

**Key insight:** This phase is **orchestration**, not new validation logic. Coordinate existing validators with error collection/formatting. Don't duplicate 8-layer path validation or disk space logic.

## Common Pitfalls

### Pitfall 1: Using bfree Instead of bavail for Disk Space
**What goes wrong:** User gets "insufficient space" error even with space available
**Why it happens:** `bfree` includes blocks reserved for root; non-root users can't access them
**How to avoid:** Always use `stats.bavail * stats.bsize`, never `stats.bfree`
**Warning signs:** Disk check fails but `df -h` shows space available
```javascript
// WRONG
const availableBytes = stats.bfree * stats.bsize;

// CORRECT  
const availableBytes = stats.bavail * stats.bsize;
```

### Pitfall 2: Not Skipping Dependent Validations
**What goes wrong:** Validating paths when templates missing, cascading errors confuse user
**Why it happens:** Running all checks sequentially without dependency awareness
**How to avoid:** Check prerequisites first, throw immediately on failure, skip dependents
**Warning signs:** Error report shows "templates missing" AND "can't validate paths" (redundant)

### Pitfall 3: Insufficient Disk Buffer
**What goes wrong:** Installation fails mid-process with "disk full" despite passing pre-flight
**Why it happens:** Calculating exact template size without accounting for filesystem overhead
**How to avoid:** Add 50% buffer (`requiredBytes * 1.5`) for metadata, temp files, journaling
**Warning signs:** Pre-flight passes but installation fails at 80-90% progress

### Pitfall 4: Validating Symlink Path Instead of Target
**What goes wrong:** Security validation passes for symlink but target escapes allowed directories
**Why it happens:** Running path validation before resolving symlinks
**How to avoid:** Resolve symlink first (`resolveSymlinkSingleLevel`), then validate resolved target
**Warning signs:** Path traversal attack succeeds via symlink to forbidden directory

### Pitfall 5: Over-Mocking in Tests
**What goes wrong:** Tests pass but real validation fails on actual filesystem
**Why it happens:** Mocking fs operations instead of testing real behavior
**How to avoid:** Use integration tests with isolated `/tmp` directories, execute real install.js
**Warning signs:** Tests green but users report validation failures

### Pitfall 6: Mixing Execution Flow and Error Reporting
**What goes wrong:** Inconsistent behavior - sometimes fails fast, sometimes continues
**Why it happens:** Not distinguishing execution control from error display
**How to avoid:** Hybrid approach: fail-fast execution (stop on blockers) + fail-slow reporting (collect errors before displaying)
**Warning signs:** Users confused why validation stopped vs continued

### Pitfall 7: Not Checking Parent Directory When Target Missing
**What goes wrong:** `statfs()` fails on first install because target directory doesn't exist yet
**Why it happens:** Checking disk space on non-existent path
**How to avoid:** If target doesn't exist, check parent directory instead
**Warning signs:** Pre-flight fails on first install but succeeds on reinstall
```javascript
// Handle first install vs reinstall
let checkPath = targetDir;
if (!await pathExists(targetDir)) {
  checkPath = resolve(targetDir, '..'); // Check parent
}
const stats = await statfsPromise(checkPath);
```

## Code Examples

Verified patterns from existing codebase analysis:

### Disk Space Checking (Node 19+)
```javascript
// Source: bin/lib/validation/pre-install-checks.js (existing code)
import { statfs } from 'fs';
import { promisify } from 'util';

const statfsPromise = promisify(statfs);

export async function checkDiskSpace(targetDir, requiredBytes) {
  // Use parent directory if target doesn't exist yet (first install)
  let checkPath = targetDir;
  if (!await pathExists(targetDir)) {
    checkPath = resolve(targetDir, '..');
  }
  
  const stats = await statfsPromise(checkPath);
  
  // CRITICAL: Use bavail (available to non-root), not bfree
  const availableBytes = stats.bavail * stats.bsize;
  
  // Add 50% buffer for filesystem overhead (context decision)
  const requiredWithBuffer = Math.ceil(requiredBytes * 1.5);
  
  if (availableBytes < requiredWithBuffer) {
    throw insufficientSpace(
      'Insufficient disk space',
      {
        required: requiredWithBuffer,
        available: availableBytes,
        path: targetDir,
        requiredMB: (requiredWithBuffer / 1024 / 1024).toFixed(2),
        availableMB: (availableBytes / 1024 / 1024).toFixed(2)
      }
    );
  }
}
```

### Template Existence Check
```javascript
// Source: Pattern from existing code
import { pathExists } from '../io/file-operations.js';
import { missingTemplates } from '../errors/install-error.js';

async function checkTemplatesExist(templatesDir) {
  const requiredDirs = [
    join(templatesDir, 'skills'),
    join(templatesDir, 'agents'),
    join(templatesDir, 'shared')
  ];
  
  const missing = [];
  for (const dir of requiredDirs) {
    if (!await pathExists(dir)) {
      missing.push(path.relative(templatesDir, dir));
    }
  }
  
  if (missing.length > 0) {
    throw missingTemplates(
      'Required template directories not found',
      { missing, templatesDir }
    );
  }
}
```

### Batch Path Validation Collection
```javascript
// Source: bin/lib/validation/path-validator.js (existing code)
export function validateAllPaths(basePath, paths) {
  const results = {
    valid: [],
    invalid: [],
    totalErrors: 0
  };
  
  for (const inputPath of paths) {
    try {
      const validated = validatePath(basePath, inputPath);
      results.valid.push({
        input: inputPath,
        normalized: validated.normalized,
        resolved: validated.resolved
      });
    } catch (error) {
      results.invalid.push({
        input: inputPath,
        error: error.message,
        details: error.details
      });
      results.totalErrors++;
    }
  }
  
  return results;
}
```

### Integration Test Pattern (Bash)
```bash
# Source: Testing best practices for validation
#!/bin/bash

test_insufficient_disk() {
  # Setup: Isolated test environment
  TEST_DIR="/tmp/gsd-test-no-disk-$$"
  mkdir -p "$TEST_DIR"
  cp -r "$PROJECT_ROOT" "$TEST_DIR/gsd"
  
  # Act: Execute real install.js
  cd "$TEST_DIR/gsd"
  output=$(node bin/install.js --copilot --custom-path "$TEST_DIR/target" 2>&1 || true)
  exit_code=$?
  
  # Assert: Verify behavior
  if echo "$output" | grep -q "Insufficient disk space"; then
    echo "âœ“ Disk check error displayed"
  else
    echo "âœ— Expected disk error not found"
    exit 1
  fi
  
  if [ $exit_code -eq 0 ]; then
    echo "âœ— Installation should have failed"
    exit 1
  fi
  
  # Cleanup
  cd /
  rm -rf "$TEST_DIR"
  
  echo "âœ“ Test passed: insufficient_disk"
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Scattered validation (pre-install + during install) | Single pre-flight gate | Phase 7.1 | Better UX: users see all errors at once |
| Batch validation in orchestrator | Pre-flight orchestrator | Phase 7.1 | Clear separation: orchestrator only processes files |
| Return booleans from validators | Throw errors immediately | Phase 7 | Simpler error handling, consistent pattern |
| 10% disk buffer | 50% disk buffer | Phase 7.1 | More reliable: accounts for filesystem overhead |

**Deprecated/outdated:**
- `check-disk-space` npm package: statfs now built-in to Node.js 19+
- Multiple validation points: Single pre-flight validation is standard
- Technical error messages: User-facing messages with fixes are expected

## Open Questions

Things that couldn't be fully resolved:

1. **Node.js < 19 fallback strategy**
   - What we know: statfs added in Node 19, earlier versions don't have it
   - What's unclear: Should we add `check-disk-space` dependency for older Node, or just warn?
   - Recommendation: Document Node 19+ requirement, show warning if unavailable (existing code pattern)

2. **Symlink confirmation prompt UX**
   - What we know: Symlinks should warn, not block; user needs to confirm
   - What's unclear: Exact prompt wording, `--force` flag vs interactive prompt
   - Recommendation: Follow existing CLI patterns (show resolved path, ask "Continue? [y/N]")

3. **Test automation integration**
   - What we know: Bash-based integration tests work well for filesystem validation
   - What's unclear: Should these integrate with existing vitest suite or stay separate?
   - Recommendation: Keep bash tests separate in `tests/integration/preflight/` - easier to maintain, more reliable for filesystem testing

4. **Performance baseline**
   - What we know: Total validation should be < 500ms for good UX
   - What's unclear: Actual timings depend on filesystem, number of files
   - Recommendation: Measure in testing, optimize if > 500ms (likely not needed for ~100 files)

## Sources

### Primary (HIGH confidence)
- Existing codebase validation modules:
  - `bin/lib/validation/pre-install-checks.js` - disk space, permissions, existing patterns
  - `bin/lib/validation/path-validator.js` - 8-layer validation, batch validation pattern
  - `bin/lib/validation/error-logger.js` - error formatting patterns
  - `bin/lib/paths/symlink-resolver.js` - symlink resolution
- Node.js documentation:
  - `fs.statfs()` API (Node 19+) - disk space checking
  - `fs/promises` lstat/readlink - symlink detection

### Secondary (MEDIUM confidence)
- CLI best practices observed in mature tools:
  - npm: Category-based error grouping
  - git: User-friendly error messages with fixes
  - docker: Clear actionable guidance pattern
- Industry patterns:
  - Orchestrator pattern for coordination
  - Fail-fast execution + fail-slow reporting hybrid
  - Integration testing for filesystem operations

### Tertiary (LOW confidence)
- None - all findings verified against existing code or official Node.js APIs

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Based on existing codebase + Node.js built-ins
- Architecture: HIGH - Orchestrator pattern verified in existing code structure
- Pitfalls: HIGH - Derived from actual code analysis (bavail vs bfree, buffer sizes)
- Testing: MEDIUM - Best practices but not project-specific yet

**Research date:** 2025-01-29
**Valid until:** ~30 days (stable domain - validation patterns don't change rapidly)
