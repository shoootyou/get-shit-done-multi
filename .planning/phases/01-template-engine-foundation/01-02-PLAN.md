---
phase: 01-template-engine-foundation
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - bin/lib/template-system/context-builder.js
  - bin/lib/template-system/engine.js
autonomous: true

must_haves:
  truths:
    - "Context builder produces platform-specific context objects"
    - "Template engine renders templates with variable substitution"
    - "Engine validates YAML output before returning"
    - "Invalid YAML caught with line-specific error messages"
  artifacts:
    - path: "bin/lib/template-system/context-builder.js"
      provides: "Platform context construction"
      exports: ["buildContext"]
      min_lines: 40
    - path: "bin/lib/template-system/engine.js"
      provides: "Template rendering and YAML validation"
      exports: ["render", "validate"]
      min_lines: 60
  key_links:
    - from: "bin/lib/template-system/engine.js"
      to: "js-yaml"
      via: "require and yaml.load()"
      pattern: "yaml\\.load\\("
---

<objective>
Create context-builder and template engine modules that handle platform-specific variable substitution and YAML validation.

Purpose: Enable template rendering with platform differences (Claude vs Copilot) and catch invalid YAML before file generation.

Output: Working context-builder and engine modules with validation.
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md

# Completed work
@.planning/phases/01-template-engine-foundation/01-01-SUMMARY.md

# Existing codebase
@bin/install.js
@bin/lib/adapters/claude.js
@bin/lib/adapters/copilot.js
@bin/lib/paths.js
</context>

<tasks>

<task type="auto">
  <name>Create context-builder module</name>
  <files>bin/lib/template-system/context-builder.js</files>
  <action>
Implement context-builder.js that constructs platform-specific template context:

**Module purpose:**
Build context objects containing platform flags, paths, and variables used during template rendering.

**Key functionality:**

1. **buildContext(platform, options)** - Main export
   - Parameters:
     - `platform`: 'claude' | 'copilot' | 'codex'
     - `options`: { paths, workDir, additionalVars }
   - Returns: Context object for template rendering

2. **Context structure:**
```javascript
{
  // Platform flags (for conditional sections)
  isClaude: boolean,
  isCopilot: boolean,
  isCodex: boolean,
  
  // Platform-specific paths
  agentsPath: string,
  skillsPath: string,
  workDir: string,
  
  // Capabilities (for conditional features)
  supportsModel: boolean,      // Claude only
  supportsHooks: boolean,       // Claude only
  supportsMCP: boolean,         // Both (but different config)
  
  // Any additional variables
  ...options.additionalVars
}
```

3. **Platform capability mapping:**
Based on research/PITFALLS.md findings:
- Claude: model selection, hooks, skills, higher char limits
- Copilot: MCP in frontmatter, tool wildcards, 30k char limit
- Shared: tools (with canonical names), basic frontmatter

**Integration with existing adapters:**
Use existing bin/lib/paths.js logic for path resolution. Reference existing adapters for platform-specific paths:
- Claude: ~/.claude/agents/ (global) or ./.claude/agents/ (local)
- Copilot: ./.github/copilot/agents/
- Codex: ~/.codex/agents/ (global) or ./.codex/agents/ (local)

**Error handling:**
- Validate platform parameter (must be 'claude', 'copilot', or 'codex')
- Throw descriptive error for unsupported platform
- Provide defaults for missing optional parameters

**Do NOT:**
- Hardcode paths (use paths.js or adapter logic)
- Include tool name mappings (that's Phase 2 - Platform Abstraction)
- Add Mustache logic (start with template literals as per STACK.md)
  </action>
  <verify>
```bash
node -e "
const {buildContext} = require('./bin/lib/template-system/context-builder');

// Test Claude context
const claudeCtx = buildContext('claude', {
  workDir: '/workspace',
  paths: { agents: '~/.claude/agents/' }
});
console.log('Claude context:', JSON.stringify(claudeCtx, null, 2));

// Test Copilot context
const copilotCtx = buildContext('copilot', {
  workDir: '/workspace',
  paths: { agents: './.github/copilot/agents/' }
});
console.log('Copilot supports model?', copilotCtx.supportsModel);
"
```
Should output context objects with correct platform flags and capabilities.
  </verify>
  <done>
context-builder.js exists with buildContext export. Module produces platform-specific context objects with flags (isClaude, isCopilot, isCodex) and capability booleans (supportsModel, supportsHooks, supportsMCP).
  </done>
</task>

<task type="auto">
  <name>Create template engine with YAML validation</name>
  <files>bin/lib/template-system/engine.js</files>
  <action>
Implement engine.js with template rendering and YAML validation:

**Module purpose:**
Render templates with variable substitution and validate YAML output structure.

**Key functionality:**

1. **render(template, context)** - Main rendering function
   - Uses ES6 template literals for variable substitution
   - Parameters:
     - `template`: String with {{variable}} placeholders
     - `context`: Object with variable values
   - Returns: Rendered string with variables replaced
   - Strategy: Start with simple regex-based substitution (per STACK.md recommendation)

2. **validate(yamlString)** - YAML validation
   - Uses js-yaml to parse and validate
   - Parameters:
     - `yamlString`: String containing YAML
   - Returns: {valid: boolean, errors: []}
   - Catches parse errors and extracts line numbers from error.mark.line

3. **Simple variable substitution:**
```javascript
function render(template, context) {
  return template.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
    if (!(varName in context)) {
      throw new Error(`Undefined variable: ${varName}`);
    }
    return context[varName];
  });
}
```

4. **YAML validation with helpful errors:**
```javascript
function validate(yamlString) {
  try {
    const yaml = require('js-yaml');
    yaml.load(yamlString);
    return { valid: true, errors: [] };
  } catch (err) {
    const lineNum = err.mark ? err.mark.line + 1 : 'unknown';
    return {
      valid: false,
      errors: [{
        line: lineNum,
        message: err.message,
        snippet: err.mark ? err.mark.snippet : null
      }]
    };
  }
}
```

**Advanced features (optional, if time allows):**
- Support for conditional sections {{#if}}...{{/if}} using simple regex
- Escape special characters in variable values
- Nested variable access (context.paths.agents)

**Do NOT:**
- Implement full Mustache logic (that's optional upgrade per STACK.md)
- Allow arbitrary code execution in templates
- Use eval() or Function() constructor
- Add complex helpers/filters (keep it logic-less)

**Dependencies:**
Requires js-yaml (installed in Plan 01).
  </action>
  <verify>
```bash
node -e "
const {render, validate} = require('./bin/lib/template-system/engine');

// Test variable substitution
const template = 'name: {{agentName}}\ndescription: {{desc}}';
const context = { agentName: 'test-agent', desc: 'Test description' };
const rendered = render(template, context);
console.log('Rendered:', rendered);

// Test YAML validation (valid)
const validYaml = 'name: test\ntools: [Bash, Read]';
const result1 = validate(validYaml);
console.log('Valid YAML:', result1.valid);

// Test YAML validation (invalid)
const invalidYaml = 'name: test\ntools: [Bash, Read';  // Missing closing bracket
const result2 = validate(invalidYaml);
console.log('Invalid YAML detected:', !result2.valid);
console.log('Error line:', result2.errors[0].line);
"
```
Should output rendered template with variables replaced, valid YAML passes, invalid YAML caught with line number.
  </verify>
  <done>
engine.js exists with render and validate exports. render() replaces {{variable}} placeholders. validate() uses js-yaml to parse and catch errors with line numbers. Both functions handle errors gracefully.
  </done>
</task>

<task type="auto">
  <name>Add unit tests for context-builder and engine</name>
  <files>bin/lib/template-system/context-builder.test.js, bin/lib/template-system/engine.test.js</files>
  <action>
Create unit tests for both modules:

**context-builder.test.js:**
Test cases:
1. Claude context has correct flags (isClaude=true, isCopilot=false)
2. Copilot context has correct capabilities (supportsModel=false)
3. Invalid platform throws error
4. Additional variables merged into context
5. Paths correctly populated from options

**engine.test.js:**
Test cases:
1. Simple variable substitution ({{var}} → value)
2. Multiple variables in same template
3. Undefined variable throws error with variable name
4. Valid YAML passes validation
5. Invalid YAML caught with line number
6. Malformed YAML provides helpful error message

**Test structure (using Node.js assert):**
```javascript
const assert = require('assert');
const {buildContext} = require('./context-builder');
// ... test cases

console.log('✓ All context-builder tests passed');
```

Run both test files to verify:
```bash
node bin/lib/template-system/context-builder.test.js
node bin/lib/template-system/engine.test.js
```
  </action>
  <verify>
```bash
# Run tests
node bin/lib/template-system/context-builder.test.js && \
node bin/lib/template-system/engine.test.js && \
echo "✓ All Plan 02 tests passed"
```
Should complete with no assertion errors.
  </verify>
  <done>
context-builder.test.js and engine.test.js exist with comprehensive test coverage. Running both files produces "All tests passed" output with no errors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Modules exist:**
   ```bash
   ls -la bin/lib/template-system/{context-builder,engine}.js
   ```

2. **Module exports:**
   ```bash
   node -e "
   const cb = require('./bin/lib/template-system/context-builder');
   const en = require('./bin/lib/template-system/engine');
   console.log('context-builder exports:', Object.keys(cb));
   console.log('engine exports:', Object.keys(en));
   "
   ```

3. **Integration test - render template with platform context:**
   ```bash
   node -e "
   const {buildContext} = require('./bin/lib/template-system/context-builder');
   const {render, validate} = require('./bin/lib/template-system/engine');
   
   const ctx = buildContext('claude', { workDir: '/workspace' });
   const template = 'Platform: {{isClaude}}\nWorkDir: {{workDir}}';
   const rendered = render(template, ctx);
   console.log('Rendered template:\n', rendered);
   
   // Validate YAML output
   const result = validate(rendered);
   console.log('Valid YAML:', result.valid);
   "
   ```

4. **Tests pass:**
   ```bash
   for test in bin/lib/template-system/*.test.js; do
     node "$test" || exit 1
   done
   echo "✓ All tests passed"
   ```
</verification>

<success_criteria>
1. ✅ context-builder.js exports buildContext function that returns platform-specific context
2. ✅ Context includes platform flags (isClaude, isCopilot, isCodex) and capability booleans
3. ✅ engine.js exports render function that performs variable substitution
4. ✅ engine.js exports validate function that uses js-yaml to catch invalid YAML
5. ✅ YAML validation errors include line numbers from error.mark.line
6. ✅ Unit tests verify both modules work correctly with various inputs
7. ✅ Integration test confirms render + validate work together
</success_criteria>

<output>
After completion, create `.planning/phases/01-template-engine-foundation/01-02-SUMMARY.md` documenting:
- context-builder implementation (platform flags and capabilities)
- engine implementation (variable substitution strategy)
- YAML validation approach
- Test coverage
- Integration notes for Plan 03 (generator will use both modules)
</output>
