---
phase: 06-orchestration-validation
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - bin/lib/orchestration/sequential-spawn-validator.js
  - bin/lib/orchestration/reference-resolver.js
  - bin/lib/orchestration/sequential-spawn-validator.test.js
  - bin/lib/orchestration/reference-resolver.test.js
autonomous: true
must_haves:
  - Sequential spawn validator verifies checkpoint continuation pattern (spawn → checkpoint → respawn)
  - Reference resolver validates @-references point to existing files
  - Reference resolver handles variable interpolation ({var} and @{var} formats)
  - Test suite validates gsd-research-phase sequential spawning with checkpoint
  - Test suite validates gsd-execute-phase @-reference resolution with variables
---

# Phase 6, Plan 2: Sequential Spawning + @-References

## Objective

Create validators for sequential spawning patterns (checkpoint continuation) and @-reference resolution (context passing between agents). These patterns enable long-running operations and rich context sharing.

## Context

**From RESEARCH.md:**
- Sequential spawning: gsd-research-phase spawns agent → checkpoint file → respawn with @-reference
- @-references: Load file content into agent context (e.g., `@.planning/STATE.md`)
- Variable interpolation: Both `{var}` and `@{var}` formats, must interpolate before file resolution
- Checkpoint files: `.planning/phases/XX-name/.continue-here.md` pattern

**Wave 2 scope:** Build sequential and reference validation, test against gsd-research-phase and gsd-execute-phase.

**Dependencies:** Plan 1 provides structured return parser (needed for checkpoint detection).

**Next wave:** Plan 3 integrates all validators into comprehensive test suite.

## Tasks

<task name="create-sequential-spawn-validator" type="auto">
  <files>bin/lib/orchestration/sequential-spawn-validator.js</files>
  <action>
Create sequential spawning validator that verifies checkpoint continuation pattern.

**Function: validateSequentialSpawning(orchestratorCmd, checkpointPattern, testPrompt)**

Input:
- orchestratorCmd: Command name (e.g., 'gsd-research-phase')
- checkpointPattern: Regex or string to detect checkpoint files (e.g., '.continue-here.md')
- testPrompt: Prompt to pass to orchestrator

Output: Object with { success: boolean, checkpointFound: boolean, respawnDetected: boolean, contextPassed: boolean }

**Logic:**
1. Invoke orchestrator with testPrompt
2. Watch for checkpoint file creation (monitor .planning/ directory)
3. Detect respawn with @-reference to checkpoint (parse agent output)
4. Verify context passing: checkpoint content appears in respawned agent prompt
5. Return validation result

**Checkpoint detection:**
- Monitor file creation events during orchestrator execution
- Look for files matching checkpointPattern
- Record checkpoint file path

**Respawn detection:**
- Parse orchestrator output for second Task() call
- Check if prompt includes @-reference to checkpoint file
- Use structured-return-parser from Plan 1 to detect completion

**Reference pattern:** RESEARCH.md Sequential Spawning section (lines 309-327)

**Integration:** Reuse structured-return-parser.js from Plan 1

**Error handling:**
- No checkpoint created: checkpointFound = false
- No respawn detected: respawnDetected = false
- Context not passed: contextPassed = false
  </action>
  <verify>
```bash
# Check module exports correct interface
node -e "
const validator = require('./bin/lib/orchestration/sequential-spawn-validator');
console.assert(typeof validator.validateSequentialSpawning === 'function', 'Should export validateSequentialSpawning');
console.log('✓ Sequential spawn validator module loaded');
"

# Manual test will be added in task 3 (unit tests)
```
  </verify>
  <done>
Sequential spawn validator module exists, verifies checkpoint continuation pattern used by long-running operations.
  </done>
</task>

<task name="create-reference-resolver" type="auto">
  <files>bin/lib/orchestration/reference-resolver.js</files>
  <action>
Create @-reference resolver that validates file references in agent prompts.

**Function: validateReferences(prompt, baseDir = '.planning')**

Input:
- prompt: Agent prompt text containing @-references
- baseDir: Base directory for relative path resolution

Output: Object with { valid: boolean, references: string[], errors: string[], resolvedPaths: string[] }

**Logic:**
1. Extract @-references using regex: `/@([^\s,}]+)/g`
2. For each reference:
   - Resolve relative paths (relative to baseDir)
   - Resolve absolute paths (start with /)
   - Check file existence
   - Record error if missing
3. Return validation result

**Function: interpolateVariables(template, variables)**

Input:
- template: String with {var} and @{var} placeholders
- variables: Object with variable values

Output: String with variables replaced

**Logic:**
1. Replace {var} format first: `/{(\w+)}/g`
2. Replace @{var} format second: `/@{(\w+)}/g`
3. Order matters: @{var} depends on {var} being replaced first
4. Return interpolated string

**Reference pattern:** RESEARCH.md Pattern 3 and 4 (lines 157-218)

**Error handling:**
- Missing files: Add to errors array, include path
- Invalid syntax: Handle gracefully, report error
- Undefined variables: Replace with placeholder, add warning

**Example:**
```javascript
const prompt = "Execute @{plan_path}\n\nContext: @.planning/STATE.md";
const variables = { plan_path: '.planning/phases/01-foundation/01-01-PLAN.md' };

const interpolated = interpolateVariables(prompt, variables);
const validation = validateReferences(interpolated, '.planning');

// validation.valid === true if both files exist
// validation.references === ['.planning/phases/01-foundation/01-01-PLAN.md', '.planning/STATE.md']
```
  </action>
  <verify>
```bash
node -e "
const resolver = require('./bin/lib/orchestration/reference-resolver');

// Test 1: Variable interpolation
const template = 'Execute {plan_path} and load @{plan_path}';
const vars = { plan_path: '.planning/STATE.md' };
const result = resolver.interpolateVariables(template, vars);
console.assert(!result.includes('{plan_path}'), 'Variables should be replaced');
console.assert(result.includes('.planning/STATE.md'), 'Should include interpolated value');

// Test 2: Reference extraction
const prompt = 'Load @.planning/STATE.md and @.planning/ROADMAP.md';
const validation = resolver.validateReferences(prompt, '.planning');
console.assert(validation.references.length === 2, 'Should find 2 references');
console.assert(validation.valid === true, 'Should validate existing files');

console.log('✓ Reference resolver working');
"
```
  </verify>
  <done>
Reference resolver module exists, validates @-references and interpolates variables in agent prompts.
  </done>
</task>

<task name="write-unit-tests" type="auto">
  <files>
    bin/lib/orchestration/sequential-spawn-validator.test.js
    bin/lib/orchestration/reference-resolver.test.js
  </files>
  <action>
Create unit tests for both modules using Node.js assert.

**sequential-spawn-validator.test.js:**
Test cases:
1. Module loads and exports function
2. Function signature validation
3. Mock checkpoint detection logic
4. Mock respawn detection logic
5. Error handling for missing checkpoint

**reference-resolver.test.js:**
Test cases:
1. Extract @-references from prompt
2. Validate existing files
3. Detect missing files
4. Interpolate {var} format
5. Interpolate @{var} format
6. Interpolation order (@{var} after {var})
7. Handle undefined variables
8. Resolve relative vs absolute paths

**Test structure:**
```javascript
const assert = require('assert');
const fs = require('fs');
const path = require('path');
const module = require('./module-name');

async function runTests() {
  console.log('Testing module-name...');
  
  // Test with actual .planning/ files
  const validation = module.validateReferences(
    'Load @.planning/STATE.md',
    '.planning'
  );
  
  assert.strictEqual(validation.valid, true, 'STATE.md should exist');
  assert.strictEqual(validation.references.length, 1, 'Should find 1 reference');
  
  console.log('✓ All tests passed');
}

runTests().catch(err => {
  console.error('Test failed:', err);
  process.exit(1);
});
```

**Test data:** Use actual .planning/ files (STATE.md, ROADMAP.md exist) for realistic validation

**Run tests:**
```bash
node bin/lib/orchestration/sequential-spawn-validator.test.js
node bin/lib/orchestration/reference-resolver.test.js
```
  </action>
  <verify>
```bash
# Run both test suites
echo "Running sequential-spawn-validator tests..."
node bin/lib/orchestration/sequential-spawn-validator.test.js

echo ""
echo "Running reference-resolver tests..."
node bin/lib/orchestration/reference-resolver.test.js

echo ""
echo "✓ All unit tests passed"
```
  </verify>
  <done>
Unit tests exist and pass, covering checkpoint continuation and @-reference resolution patterns.
  </done>
</task>

## Verification

After all tasks complete, verify:

```bash
# 1. Check all files created
ls -l bin/lib/orchestration/sequential-spawn-validator.js \
      bin/lib/orchestration/reference-resolver.js \
      bin/lib/orchestration/sequential-spawn-validator.test.js \
      bin/lib/orchestration/reference-resolver.test.js

# 2. Run tests
node bin/lib/orchestration/sequential-spawn-validator.test.js
node bin/lib/orchestration/reference-resolver.test.js

# 3. Test against actual commands (manual)
# Example: Run gsd-research-phase, verify checkpoint creation and respawn
# Example: Test @-reference resolution with .planning/STATE.md
```

## Success Criteria

- [ ] Sequential spawn validator detects checkpoint files
- [ ] Sequential spawn validator verifies respawn with context passing
- [ ] Reference resolver extracts @-references from prompts
- [ ] Reference resolver validates file existence
- [ ] Reference resolver interpolates {var} and @{var} formats correctly
- [ ] Variable interpolation order correct (@{var} after {var})
- [ ] Unit tests pass for both modules

## Output

Two new validation modules in `bin/lib/orchestration/`:
1. **sequential-spawn-validator.js** - Validate checkpoint continuation pattern
2. **reference-resolver.js** - Validate @-references and variable interpolation

Ready for Plan 3: Integration suite combining all validators.
