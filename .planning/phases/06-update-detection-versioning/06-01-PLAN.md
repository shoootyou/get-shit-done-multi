---
phase: 06-update-detection-versioning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - bin/lib/version/installation-finder.js
  - bin/lib/version/manifest-reader.js
  - bin/lib/version/version-checker.js
  - tests/version/installation-finder.test.js
  - tests/version/manifest-reader.test.js
  - tests/version/version-checker.test.js
autonomous: true
must_haves:
  - goal: "User re-runs installer → sees installed version, gets prompted if update available"
    truths:
      - "Installer can find all manifests in scope-appropriate paths"
      - "Installer reads manifests successfully or repairs corrupted ones"
      - "Installer compares versions correctly using semver"
      - "Downgrade attempts are blocked with helpful message"
      - "Major version bumps are detected for warnings"
    artifacts:
      - "bin/lib/version/installation-finder.js exports findInstallations(scope, customPaths?)"
      - "bin/lib/version/manifest-reader.js exports readManifestWithRepair(path)"
      - "bin/lib/version/version-checker.js exports compareVersions(installed, current)"
      - "package.json includes semver ^7.7.3 dependency"
    wiring:
      - "installation-finder uses os.homedir() for global paths"
      - "manifest-reader attempts repair on corruption via directory scan"
      - "version-checker uses semver.coerce() before all comparisons"
    key_links:
      - "installation-finder → manifest-reader (reads found manifests)"
      - "version-checker → semver library (all version operations)"
---

# Phase 6 Plan 1: Core Version Detection Modules

## Objective

Create foundation for update detection: discover installations, read/repair manifests, and compare versions using semantic versioning.

## Context

Phase 5 created manifest generation. Now we need the inverse: read those manifests, detect installations, and compare versions to prompt for updates. This plan builds the three core modules that enable version detection without any UI integration (that's Plan 2).

**From 06-CONTEXT.md:**
- Scope-based discovery: global checks ~/.xxx/, local checks .xxx/
- Manifest repair: attempt reconstruction from directory scan
- Downgrade blocking: no --force override, completely blocked
- Major version warnings: detect 2.x → 3.x jumps

**From 06-RESEARCH.md:**
- Use semver package (npm's official parser, already standard)
- Use fs-extra for file operations (already in package.json)
- Parallel Promise.all for file discovery (6 paths safe)
- Two-pass read: try parse → validate structure → attempt repair if needed

## Tasks

<task name="install-semver" type="auto">
  <files>package.json</files>
  <action>
    Install semver dependency for semantic version comparison.
    
    ```bash
    npm install semver@^7.7.3
    ```
    
    Verify installation:
    ```bash
    npm list semver
    ```
  </action>
  <verify>
    ```bash
    grep '"semver"' package.json
    node -e "const semver = require('semver'); console.log(semver.valid('2.0.0'))"
    ```
  </verify>
  <done>semver ^7.7.3 appears in package.json dependencies, can be required in modules</done>
</task>

<task name="create-installation-finder" type="auto">
  <files>bin/lib/version/installation-finder.js</files>
  <action>
    Create installation discovery module that finds GSD manifests by scope.
    
    **Module structure:**
    ```javascript
    import fs from 'fs-extra';
    import os from 'os';
    import path from 'path';
    
    const MANIFEST_FILE = '.gsd-install-manifest.json';
    
    export async function findInstallations(scope, customPaths = []) {
      // Get standard paths for scope
      const standardPaths = getManifestPaths(scope);
      
      // Combine with custom paths
      const allPaths = [...standardPaths, ...customPaths];
      
      // Check all paths in parallel (Promise.all safe for read-only)
      const checks = await Promise.all(
        allPaths.map(async (manifestPath) => {
          const exists = await fs.pathExists(manifestPath);
          if (!exists) return null;
          
          return {
            path: manifestPath,
            scope: deriveScope(manifestPath),
            platform: derivePlatform(manifestPath)
          };
        })
      );
      
      return checks.filter(c => c !== null);
    }
    
    function getManifestPaths(scope) {
      const homeDir = os.homedir();
      
      if (scope === 'global') {
        return [
          path.join(homeDir, '.claude', 'get-shit-done', MANIFEST_FILE),
          path.join(homeDir, '.copilot', 'get-shit-done', MANIFEST_FILE),
          path.join(homeDir, '.codex', 'get-shit-done', MANIFEST_FILE)
        ];
      } else {
        return [
          path.join(process.cwd(), '.claude', 'get-shit-done', MANIFEST_FILE),
          path.join(process.cwd(), '.github', 'get-shit-done', MANIFEST_FILE),
          path.join(process.cwd(), '.codex', 'get-shit-done', MANIFEST_FILE)
        ];
      }
    }
    
    function deriveScope(manifestPath) {
      const homeDir = os.homedir();
      return manifestPath.startsWith(homeDir) ? 'global' : 'local';
    }
    
    function derivePlatform(manifestPath) {
      // Extract platform from path structure
      // Example: ~/.claude/get-shit-done/... → 'claude'
      const parts = manifestPath.split(path.sep);
      const platformDirIndex = parts.findIndex(p => 
        p === '.claude' || p === '.copilot' || p === '.codex' || p === '.github'
      );
      
      if (platformDirIndex === -1) return 'unknown';
      
      const platformDir = parts[platformDirIndex];
      // Map .github to copilot (local copilot uses .github)
      if (platformDir === '.github') return 'copilot';
      return platformDir.substring(1); // Remove leading dot
    }
    ```
    
    **Features:**
    - Parallel path checking (6 standard paths checked simultaneously)
    - Custom path support for non-standard installations
    - Scope derivation from path (contains homedir = global)
    - Platform derivation from directory structure
    - Returns only found installations (filters nulls)
  </action>
  <verify>
    ```bash
    # Verify module structure
    grep -q "export async function findInstallations" bin/lib/version/installation-finder.js
    grep -q "getManifestPaths" bin/lib/version/installation-finder.js
    grep -q "Promise.all" bin/lib/version/installation-finder.js
    
    # Manual test
    node -e "
    import('./bin/lib/version/installation-finder.js').then(m => {
      m.findInstallations('global').then(r => console.log('Found:', r.length, 'installations'));
    });
    "
    ```
  </verify>
  <done>installation-finder.js exists, exports findInstallations(scope, customPaths), uses parallel Promise.all for path checking</done>
</task>

<task name="create-manifest-reader" type="auto">
  <files>bin/lib/version/manifest-reader.js</files>
  <action>
    Create manifest reading module with automatic repair on corruption.
    
    **Module structure:**
    ```javascript
    import fs from 'fs-extra';
    import path from 'path';
    import os from 'os';
    
    export async function readManifestWithRepair(manifestPath) {
      // Try normal read first
      try {
        if (!await fs.pathExists(manifestPath)) {
          return { success: false, reason: 'not_found', manifest: null };
        }
        
        const content = await fs.readFile(manifestPath, 'utf8');
        const manifest = JSON.parse(content);
        
        // Validate required fields
        const requiredFields = ['gsd_version', 'platform', 'scope', 'installed_at'];
        const missingFields = requiredFields.filter(field => !manifest[field]);
        
        if (missingFields.length > 0) {
          throw new Error(`Missing required fields: ${missingFields.join(', ')}`);
        }
        
        return { success: true, manifest };
        
      } catch (error) {
        // Handle specific error types
        if (error.code === 'EACCES') {
          return {
            success: false,
            reason: 'permission_denied',
            error: error.message,
            manifest: null
          };
        }
        
        if (error instanceof SyntaxError || error.message.includes('Missing required fields')) {
          // Attempt repair
          console.warn(`⚠️  Corrupt manifest detected: ${manifestPath}`);
          console.warn('   Attempting automatic repair...');
          return await attemptRepair(manifestPath);
        }
        
        return {
          success: false,
          reason: 'unknown_error',
          error: error.message,
          manifest: null
        };
      }
    }
    
    async function attemptRepair(manifestPath) {
      try {
        const installDir = path.dirname(manifestPath);
        
        // Scan directory to reconstruct file list
        const files = [];
        try {
          const entries = await fs.readdir(installDir, { recursive: true, withFileTypes: true });
          for (const entry of entries) {
            if (entry.isFile() && !entry.name.startsWith('.gsd-')) {
              const relativePath = path.relative(installDir, path.join(entry.path || entry.parentPath, entry.name));
              files.push({ path: relativePath });
            }
          }
        } catch (error) {
          console.warn('   Could not scan directory:', error.message);
        }
        
        // Try to extract version from nearby package.json
        let version = 'unknown';
        const parentDir = path.dirname(installDir);
        const pkgPath = path.join(parentDir, 'package.json');
        if (await fs.pathExists(pkgPath)) {
          try {
            const pkg = await fs.readJson(pkgPath);
            version = pkg.version || 'unknown';
          } catch {}
        }
        
        // Derive platform from directory structure
        const platform = derivePlatformFromPath(installDir);
        
        // Derive scope from path
        const homeDir = os.homedir();
        const scope = installDir.includes(homeDir) ? 'global' : 'local';
        
        // Reconstruct manifest
        const repairedManifest = {
          gsd_version: version,
          platform: platform,
          scope: scope,
          installed_at: new Date().toISOString(),
          files: files.sort((a, b) => a.path.localeCompare(b.path)),
          _repaired: true,
          _repair_date: new Date().toISOString(),
          _repair_reason: 'corrupt_or_incomplete'
        };
        
        // Write repaired manifest
        await fs.writeJson(manifestPath, repairedManifest, { spaces: 2 });
        console.log('   ✓ Manifest repaired successfully');
        
        return { success: true, manifest: repairedManifest, repaired: true };
      } catch (repairError) {
        return {
          success: false,
          reason: 'repair_failed',
          error: repairError.message,
          manifest: null
        };
      }
    }
    
    function derivePlatformFromPath(installDir) {
      const parts = installDir.split(path.sep);
      const platformDirIndex = parts.findIndex(p => 
        p === '.claude' || p === '.copilot' || p === '.codex' || p === '.github'
      );
      
      if (platformDirIndex === -1) return 'unknown';
      
      const platformDir = parts[platformDirIndex];
      if (platformDir === '.github') return 'copilot';
      return platformDir.substring(1);
    }
    ```
    
    **Features:**
    - Try-catch with specific error handling (EACCES, SyntaxError)
    - Validation of required fields after parse
    - Automatic repair via directory scan + version heuristics
    - Marks repaired manifests with _repaired flag
    - Returns structured result object (success, reason, manifest)
  </action>
  <verify>
    ```bash
    # Verify module structure
    grep -q "export async function readManifestWithRepair" bin/lib/version/manifest-reader.js
    grep -q "attemptRepair" bin/lib/version/manifest-reader.js
    grep -q "EACCES" bin/lib/version/manifest-reader.js
    
    # Check for proper error handling
    grep -q "success: false" bin/lib/version/manifest-reader.js
    grep -q "_repaired: true" bin/lib/version/manifest-reader.js
    ```
  </verify>
  <done>manifest-reader.js exists, exports readManifestWithRepair(path), handles corruption with repair attempt, returns structured result</done>
</task>

<task name="create-version-checker" type="auto">
  <files>bin/lib/version/version-checker.js</files>
  <action>
    Create version comparison module using semver for all operations.
    
    **Module structure:**
    ```javascript
    import semver from 'semver';
    
    export function compareVersions(installedVersion, currentVersion) {
      // Coerce versions to handle "v1.2.3" format and other variations
      const installed = semver.coerce(installedVersion);
      const current = semver.coerce(currentVersion);
      
      // Handle invalid versions
      if (!installed || !current) {
        return {
          status: 'unknown',
          reason: 'invalid_version',
          installed: installedVersion,
          current: currentVersion
        };
      }
      
      // Check for downgrade (block completely per context 2.3)
      if (semver.lt(current, installed)) {
        return {
          status: 'downgrade',
          installed: installed.version,
          current: current.version,
          message: 'Cannot downgrade. Use latest version.',
          blocking: true
        };
      }
      
      // Check for major version bump (warn user per context 2.4)
      const installedMajor = semver.major(installed);
      const currentMajor = semver.major(current);
      if (currentMajor > installedMajor) {
        return {
          status: 'major_update',
          installed: installed.version,
          current: current.version,
          majorJump: `${installedMajor}.x → ${currentMajor}.x`,
          message: 'Major version update - breaking changes possible',
          updateType: 'major'
        };
      }
      
      // Check for update available
      if (semver.gt(current, installed)) {
        const diff = semver.diff(current, installed); // 'minor' | 'patch'
        return {
          status: 'update_available',
          installed: installed.version,
          current: current.version,
          updateType: diff,
          message: `Update available: v${installed.version} → v${current.version}`
        };
      }
      
      // Already up to date
      return {
        status: 'up_to_date',
        installed: installed.version,
        current: current.version
      };
    }
    
    export function formatPlatformOption(platform, versionStatus) {
      const baseName = getPlatformDisplayName(platform);
      
      if (!versionStatus || versionStatus.status === 'not_installed') {
        return baseName;
      }
      
      if (versionStatus.status === 'up_to_date') {
        return `${baseName} (v${versionStatus.installed})`;
      }
      
      if (versionStatus.status === 'update_available') {
        return `${baseName} (v${versionStatus.installed} → v${versionStatus.current})`;
      }
      
      if (versionStatus.status === 'major_update') {
        return `${baseName} (v${versionStatus.installed} → v${versionStatus.current} ⚠️  major)`;
      }
      
      return baseName;
    }
    
    function getPlatformDisplayName(platform) {
      const names = {
        'claude': 'Claude Code',
        'copilot': 'GitHub Copilot',
        'codex': 'Codex'
      };
      return names[platform] || platform;
    }
    ```
    
    **Features:**
    - semver.coerce() for version normalization ("v1.2.3" → "1.2.3")
    - Downgrade detection with blocking flag
    - Major version jump detection (2.x → 3.x)
    - Update type identification (major/minor/patch)
    - Inline display formatting helper
    - Structured return objects for easy UI integration
  </action>
  <verify>
    ```bash
    # Verify module structure
    grep -q "export function compareVersions" bin/lib/version/version-checker.js
    grep -q "semver.coerce" bin/lib/version/version-checker.js
    grep -q "semver.lt" bin/lib/version/version-checker.js
    grep -q "semver.major" bin/lib/version/version-checker.js
    
    # Manual test
    node -e "
    import('./bin/lib/version/version-checker.js').then(m => {
      const r1 = m.compareVersions('2.0.0', '2.1.0');
      console.log('Update test:', r1.status === 'update_available' ? 'PASS' : 'FAIL');
      
      const r2 = m.compareVersions('2.0.0', '1.9.0');
      console.log('Downgrade test:', r2.status === 'downgrade' ? 'PASS' : 'FAIL');
      
      const r3 = m.compareVersions('2.5.0', '3.0.0');
      console.log('Major test:', r3.status === 'major_update' ? 'PASS' : 'FAIL');
    });
    "
    ```
  </verify>
  <done>version-checker.js exists, exports compareVersions and formatPlatformOption, uses semver for all comparisons, detects downgrades and major bumps</done>
</task>

<task name="create-tests" type="auto">
  <files>
    tests/version/installation-finder.test.js
    tests/version/manifest-reader.test.js
    tests/version/version-checker.test.js
  </files>
  <action>
    Create comprehensive unit tests for all three version modules.
    
    **installation-finder.test.js:**
    ```javascript
    import { describe, it, expect, beforeEach, afterEach } from 'vitest';
    import fs from 'fs-extra';
    import path from 'path';
    import os from 'os';
    import { findInstallations } from '../../bin/lib/version/installation-finder.js';
    
    describe('installation-finder', () => {
      let testDir;
      
      beforeEach(async () => {
        testDir = path.join(os.tmpdir(), `gsd-test-finder-${Date.now()}`);
        await fs.ensureDir(testDir);
      });
      
      afterEach(async () => {
        await fs.remove(testDir);
      });
      
      it('should find global installations', async () => {
        // Create mock global manifest
        const manifestPath = path.join(os.homedir(), '.claude', 'get-shit-done', '.gsd-install-manifest.json');
        const exists = await fs.pathExists(manifestPath);
        
        if (exists) {
          const installations = await findInstallations('global');
          expect(installations).toBeInstanceOf(Array);
          expect(installations.length).toBeGreaterThanOrEqual(0);
        }
      });
      
      it('should find local installations', async () => {
        // Create mock local manifest
        const manifestDir = path.join(testDir, '.claude', 'get-shit-done');
        await fs.ensureDir(manifestDir);
        await fs.writeJson(path.join(manifestDir, '.gsd-install-manifest.json'), {
          gsd_version: '2.0.0',
          platform: 'claude',
          scope: 'local'
        });
        
        // Change to test directory
        const originalCwd = process.cwd();
        process.chdir(testDir);
        
        const installations = await findInstallations('local');
        expect(installations.length).toBe(1);
        expect(installations[0].platform).toBe('claude');
        
        process.chdir(originalCwd);
      });
      
      it('should support custom paths', async () => {
        const customPath = path.join(testDir, 'custom', '.gsd-install-manifest.json');
        await fs.ensureDir(path.dirname(customPath));
        await fs.writeJson(customPath, { gsd_version: '2.0.0' });
        
        const installations = await findInstallations('global', [customPath]);
        const found = installations.find(i => i.path === customPath);
        expect(found).toBeDefined();
      });
      
      it('should return empty array when no installations found', async () => {
        const originalCwd = process.cwd();
        process.chdir(testDir);
        
        const installations = await findInstallations('local');
        expect(installations).toEqual([]);
        
        process.chdir(originalCwd);
      });
      
      it('should derive correct platform from path', async () => {
        const platforms = ['.claude', '.github', '.codex'];
        const originalCwd = process.cwd();
        process.chdir(testDir);
        
        for (const platformDir of platforms) {
          const manifestDir = path.join(testDir, platformDir, 'get-shit-done');
          await fs.ensureDir(manifestDir);
          await fs.writeJson(path.join(manifestDir, '.gsd-install-manifest.json'), {
            gsd_version: '2.0.0'
          });
        }
        
        const installations = await findInstallations('local');
        expect(installations.length).toBe(3);
        
        const platforms_found = installations.map(i => i.platform).sort();
        expect(platforms_found).toEqual(['claude', 'codex', 'copilot']);
        
        process.chdir(originalCwd);
      });
    });
    ```
    
    **manifest-reader.test.js:**
    ```javascript
    import { describe, it, expect, beforeEach, afterEach } from 'vitest';
    import fs from 'fs-extra';
    import path from 'path';
    import os from 'os';
    import { readManifestWithRepair } from '../../bin/lib/version/manifest-reader.js';
    
    describe('manifest-reader', () => {
      let testDir;
      
      beforeEach(async () => {
        testDir = path.join(os.tmpdir(), `gsd-test-reader-${Date.now()}`);
        await fs.ensureDir(testDir);
      });
      
      afterEach(async () => {
        await fs.remove(testDir);
      });
      
      it('should read valid manifest', async () => {
        const manifestPath = path.join(testDir, '.gsd-install-manifest.json');
        const manifest = {
          gsd_version: '2.0.0',
          platform: 'claude',
          scope: 'local',
          installed_at: new Date().toISOString(),
          files: []
        };
        await fs.writeJson(manifestPath, manifest);
        
        const result = await readManifestWithRepair(manifestPath);
        expect(result.success).toBe(true);
        expect(result.manifest.gsd_version).toBe('2.0.0');
      });
      
      it('should return not_found for missing manifest', async () => {
        const manifestPath = path.join(testDir, 'nonexistent.json');
        
        const result = await readManifestWithRepair(manifestPath);
        expect(result.success).toBe(false);
        expect(result.reason).toBe('not_found');
      });
      
      it('should detect corrupt JSON', async () => {
        const manifestPath = path.join(testDir, '.gsd-install-manifest.json');
        await fs.writeFile(manifestPath, '{invalid json}');
        
        const result = await readManifestWithRepair(manifestPath);
        // Should attempt repair
        expect(result.success).toBeDefined();
      });
      
      it('should repair manifest with missing fields', async () => {
        const installDir = path.join(testDir, '.claude', 'get-shit-done');
        await fs.ensureDir(installDir);
        
        const manifestPath = path.join(installDir, '.gsd-install-manifest.json');
        await fs.writeJson(manifestPath, { incomplete: true });
        
        const result = await readManifestWithRepair(manifestPath);
        // Should succeed after repair or fail gracefully
        expect(result).toBeDefined();
      });
      
      it('should mark repaired manifests', async () => {
        const installDir = path.join(testDir, '.claude', 'get-shit-done');
        await fs.ensureDir(installDir);
        
        // Create some files to scan
        await fs.writeFile(path.join(installDir, 'test.txt'), 'test');
        
        const manifestPath = path.join(installDir, '.gsd-install-manifest.json');
        await fs.writeJson(manifestPath, { partial: true });
        
        const result = await readManifestWithRepair(manifestPath);
        if (result.success && result.repaired) {
          expect(result.manifest._repaired).toBe(true);
          expect(result.manifest._repair_date).toBeDefined();
        }
      });
    });
    ```
    
    **version-checker.test.js:**
    ```javascript
    import { describe, it, expect } from 'vitest';
    import { compareVersions, formatPlatformOption } from '../../bin/lib/version/version-checker.js';
    
    describe('version-checker', () => {
      describe('compareVersions', () => {
        it('should detect update available', () => {
          const result = compareVersions('2.0.0', '2.1.0');
          expect(result.status).toBe('update_available');
          expect(result.updateType).toBe('minor');
        });
        
        it('should detect patch update', () => {
          const result = compareVersions('2.0.0', '2.0.1');
          expect(result.status).toBe('update_available');
          expect(result.updateType).toBe('patch');
        });
        
        it('should detect up to date', () => {
          const result = compareVersions('2.0.0', '2.0.0');
          expect(result.status).toBe('up_to_date');
        });
        
        it('should detect downgrade attempt', () => {
          const result = compareVersions('2.0.0', '1.9.0');
          expect(result.status).toBe('downgrade');
          expect(result.blocking).toBe(true);
        });
        
        it('should detect major version jump', () => {
          const result = compareVersions('2.5.0', '3.0.0');
          expect(result.status).toBe('major_update');
          expect(result.majorJump).toBe('2.x → 3.x');
        });
        
        it('should handle version with v prefix', () => {
          const result = compareVersions('v2.0.0', 'v2.1.0');
          expect(result.status).toBe('update_available');
        });
        
        it('should handle invalid versions', () => {
          const result = compareVersions('invalid', '2.0.0');
          expect(result.status).toBe('unknown');
          expect(result.reason).toBe('invalid_version');
        });
        
        it('should correctly compare 1.10.0 > 1.9.0', () => {
          const result = compareVersions('1.9.0', '1.10.0');
          expect(result.status).toBe('update_available');
        });
      });
      
      describe('formatPlatformOption', () => {
        it('should format platform without status', () => {
          const formatted = formatPlatformOption('claude', null);
          expect(formatted).toBe('Claude Code');
        });
        
        it('should format up to date status', () => {
          const status = { status: 'up_to_date', installed: '2.0.0', current: '2.0.0' };
          const formatted = formatPlatformOption('claude', status);
          expect(formatted).toBe('Claude Code (v2.0.0)');
        });
        
        it('should format update available', () => {
          const status = { status: 'update_available', installed: '2.0.0', current: '2.1.0' };
          const formatted = formatPlatformOption('copilot', status);
          expect(formatted).toBe('GitHub Copilot (v2.0.0 → v2.1.0)');
        });
        
        it('should format major update', () => {
          const status = { status: 'major_update', installed: '2.0.0', current: '3.0.0' };
          const formatted = formatPlatformOption('codex', status);
          expect(formatted).toBe('Codex (v2.0.0 → v3.0.0 ⚠️  major)');
        });
      });
    });
    ```
    
    **Run tests:**
    ```bash
    npm test -- tests/version/
    ```
  </action>
  <verify>
    ```bash
    # Run all version tests
    npm test -- tests/version/ 2>&1 | tee /tmp/test-output.txt
    
    # Verify all passed
    grep -q "✓" /tmp/test-output.txt && echo "Tests created and passing"
    ```
  </verify>
  <done>All three test files created with comprehensive coverage, tests passing for finder, reader, and version-checker modules</done>
</task>

## Verification

**Manual checks:**
```bash
# 1. Verify semver installed
npm list semver

# 2. Verify modules created
ls -la bin/lib/version/

# 3. Test version comparison
node -e "
import('./bin/lib/version/version-checker.js').then(m => {
  console.log('Test 1:', m.compareVersions('2.0.0', '2.1.0'));
  console.log('Test 2:', m.compareVersions('2.0.0', '1.9.0'));
  console.log('Test 3:', m.compareVersions('2.0.0', '3.0.0'));
});
"

# 4. Run all tests
npm test -- tests/version/
```

## Success Criteria

1. ✅ semver ^7.7.3 installed in package.json
2. ✅ installation-finder.js finds manifests in scope-appropriate paths
3. ✅ installation-finder.js supports custom paths via optional parameter
4. ✅ manifest-reader.js reads valid manifests successfully
5. ✅ manifest-reader.js attempts repair on corrupted manifests
6. ✅ manifest-reader.js marks repaired manifests with _repaired flag
7. ✅ version-checker.js compares versions using semver.coerce()
8. ✅ version-checker.js detects downgrades with blocking flag
9. ✅ version-checker.js detects major version jumps
10. ✅ version-checker.js identifies update types (major/minor/patch)
11. ✅ formatPlatformOption() formats inline display strings
12. ✅ All tests passing (15+ tests across 3 files)

## Output

**Core version detection foundation:**
- Three independent modules (finder, reader, checker)
- Semver dependency added
- Comprehensive test coverage
- Ready for UI integration in Plan 2
