---
phase: 05-state-management
plan: 03
type: execute
wave: 2
depends_on: [05-01, 05-02]
files_modified:
  - lib-ghcc/session-manager.js
  - lib-ghcc/state-validator.js
autonomous: true

must_haves:
  truths:
    - "User switches from Claude to Codex and session state preserved"
    - "Concurrent CLI usage doesn't corrupt state files"
    - "State inconsistencies automatically detected and repaired"
    - "User sees clear error when state corruption detected"
  artifacts:
    - path: "lib-ghcc/session-manager.js"
      provides: "Session persistence across CLI switches"
      exports: ["SessionManager"]
      min_lines: 120
    - path: "lib-ghcc/state-validator.js"
      provides: "State validation and repair utilities"
      exports: ["StateValidator"]
      min_lines: 100
  key_links:
    - from: "lib-ghcc/session-manager.js"
      to: "lib-ghcc/directory-lock.js"
      via: "uses locks for concurrent safety"
      pattern: "DirectoryLock"
    - from: "lib-ghcc/state-validator.js"
      to: "lib-ghcc/state-manager.js"
      via: "validates state structure"
      pattern: "StateManager"
---

<objective>
Enable session persistence across CLI switches and ensure state consistency with validation/repair.

Purpose: Users can start work in one CLI and resume in another without data loss
Output: SessionManager for persistence and StateValidator for consistency checks
</objective>

<execution_context>
@.github/skills/get-shit-done/get-shit-done/workflows/execute-plan.md
@.github/skills/get-shit-done/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-state-management/05-RESEARCH.md
@.planning/phases/05-state-management/05-01-PLAN.md
@.planning/phases/05-state-management/05-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session persistence manager</name>
  <files>lib-ghcc/session-manager.js</files>
  <action>
Create `lib-ghcc/session-manager.js` implementing SessionManager class:

**SessionManager class:**

Constructor(stateDir = '.planning'):
- Store stateDir
- sessionFile = '.planning/.session.json'
- lockPath = '.planning/.lock'

async saveSession(sessionData):
- sessionData structure:
  ```js
  {
    cli: detectCLI(),  // current CLI
    timestamp: Date.now(),
    currentPhase: string,
    currentPlan: string,
    context: {}, // any session-specific temp data
    _version: 1
  }
  ```
- Use DirectoryLock for safe write
- await lock.withLock(async () => atomicWriteJSON(sessionFile, sessionData))
- Import DirectoryLock from './directory-lock.js'
- Import atomicWriteJSON from './state-io.js'
- Import { detectCLI } from existing detect.js (update path as needed)

async loadSession():
- Use atomicReadJSON with default: null
- If session exists and timestamp < 24 hours old, return session
- If stale (>24 hours), return null (expired)
- Return null if file doesn't exist

async clearSession():
- Delete .planning/.session.json safely
- Use fs.promises.unlink with ENOENT catch

async switchCLI(newCLI):
- Load current session
- Update cli field to newCLI
- Update timestamp
- Save session
- Log CLI switch for debugging

async restoreSession():
- Load session
- If valid session exists, return session data
- If null/expired, return { cli: detectCLI(), context: {} }

Use ES modules, import DirectoryLock, atomicWriteJSON, atomicReadJSON.
Zero npm dependencies.

**Why this approach:**
- DirectoryLock ensures concurrent CLI usage doesn't corrupt session file
- 24-hour expiry prevents stale session data from persisting indefinitely
- Session separate from persistent state (STATE.md) - session is temp work
- switchCLI() explicit method makes CLI changes trackable
  </action>
  <verify>
```bash
node -e "import('./lib-ghcc/session-manager.js').then(m => console.log(Object.keys(m)))"
```
Should output: [ 'SessionManager' ]
  </verify>
  <done>
- lib-ghcc/session-manager.js exists with SessionManager class
- saveSession uses DirectoryLock for concurrent safety
- loadSession handles stale session expiry (24 hours)
- switchCLI method tracks CLI changes
- Session data includes CLI, timestamp, phase, plan, context
  </done>
</task>

<task type="auto">
  <name>Task 2: Create state validation and repair utilities</name>
  <files>lib-ghcc/state-validator.js</files>
  <action>
Create `lib-ghcc/state-validator.js` implementing StateValidator class:

**StateValidator class:**

Constructor(stateDir = '.planning'):
- Store stateDir

async validate():
- Check directory structure:
  - .planning/ exists
  - .planning/phases/ exists
  - .planning/config.json parseable
  - .planning/STATE.md exists (optional)
- Check file integrity:
  - All .json files parse without SyntaxError
  - All files have valid _version field
- Return:
  ```js
  {
    valid: boolean,
    errors: [],  // blocking issues
    warnings: [], // non-blocking concerns
    repaired: false
  }
  ```

async repair(options = { autoFix: false }):
- Fix issues detected by validate():
  - Create missing directories (phases/, metrics/)
  - Create default config.json if missing
  - Remove unparseable JSON files (move to .backup/)
- If options.autoFix false, return repair plan without executing
- If options.autoFix true, execute repairs and return results
- Return:
  ```js
  {
    repaired: boolean,
    actions: [],  // list of repairs performed
    errors: []    // repairs that failed
  }
  ```

async detectConcurrentModifications():
- Read .planning/.meta.json
- Check if modified by different CLI since last read
- Return { concurrent: boolean, lastCLI: string, currentCLI: string }

async ensureConsistency():
- Run validate()
- If errors found and autoFix enabled, run repair()
- Log warnings to console
- Return validation results

Import StateManager from './state-manager.js'.
Import atomicReadJSON from './state-io.js'.
Use fs/promises for file checks.
Zero npm dependencies.

**Why this approach:**
- Validate without modifying by default (safe to run frequently)
- Repair requires explicit autoFix flag (prevents accidental data changes)
- Backup unparseable files rather than deleting (data recovery option)
- detectConcurrentModifications helps debug race conditions
  </action>
  <verify>
```bash
node -e "import('./lib-ghcc/state-validator.js').then(m => console.log(Object.keys(m)))"
```
Should output: [ 'StateValidator' ]
  </verify>
  <done>
- lib-ghcc/state-validator.js exists with StateValidator class
- validate() checks directory structure and file integrity
- repair() can fix common issues with autoFix flag
- detectConcurrentModifications tracks multi-CLI access
- Validation results structured with errors, warnings, repaired flag
  </done>
</task>

</tasks>

<verification>
Run CLI coordination smoke tests:
```bash
# Test session persistence
node -e "import('./lib-ghcc/session-manager.js').then(async m => {
  const sm = new m.SessionManager('/tmp/test-planning');
  await sm.saveSession({ currentPhase: '01', context: {} });
  const session = await sm.loadSession();
  console.log('Session:', session.currentPhase === '01' ? 'PASS' : 'FAIL');
})"

# Test state validation
node -e "import('./lib-ghcc/state-validator.js').then(async m => {
  const sv = new m.StateValidator('/tmp/test-planning');
  const result = await sv.validate();
  console.log('Validator:', typeof result.valid === 'boolean' ? 'PASS' : 'FAIL');
})"
```
</verification>

<success_criteria>
1. SessionManager saves and loads session data with locking for concurrent safety
2. Session data expires after 24 hours to prevent stale state
3. StateValidator detects missing directories and unparseable JSON files
4. StateValidator.repair() creates backups before removing corrupted files
5. detectConcurrentModifications tracks which CLI last modified state
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-management/05-03-SUMMARY.md`
</output>
